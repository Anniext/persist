// Code generated by persist. DO NOT EDIT.
// source: user.go

package data

import (
	"encoding/base64"
	"encoding/binary"
	"encoding/json"
	"log"
	"math"
	"runtime/debug"

	"github.com/getsentry/sentry-go"
	jsoniter "github.com/json-iterator/go"
	"xorm.io/xorm"

	"reflect"
	"strings"
	"sync"
	"time"

	"bytes"
	"errors"

	"xorm.io/core"

	"io/ioutil"
	"os"
	"runtime"
	"sync/atomic"

	"github.com/spelens-gud/persist/utils"

	persistCore	"github.com/spelens-gud/persist/core"

	"github.com/spelens-gud/persist/model"
)

// 警告:
// 内部接口禁止调用(仅供内部 和 测试代码使用)
// SaveDB, DataToFailQueue, LoadFile, SaveFile, RemoveFile
// RecoverBomb, MergeQueue, AsyncSave, Collect, CheckOverload

// 工具接口, 无副作用, 按需使用
// BytesToPersist, PersistToBytes, PersistToPersistByBitSet, BytesToPersistSync, PersistSyncToBytes,
// StringToPersistSync, PersistSyncToString, UnmarshalFailQueue, MarshalFailQueue

// 需要先导入数据再使用
// 除以下接口不需要先导入, 其他接口必须 先导入! 先导入! 先导入!
// Run, Dead, Load LoadAll, Exit, Sync, SyncData(补救没有标记写回数据, 代码正确不需要使用)

// 其他接口
// New Delete 接口按需使用
// 尽量使用MarkUpdateByBitSet 多个修改一起提交
// 只修改单条数据使用MarkUpdateByFieldIndex
// 少用或者不用MarkUpdate 全标记开销太大, 除非业务太复杂想不清楚

// 支持 hash index:[group,unique], 不支持 tree index
// op 1:insert 2:update 3:delete 4:unload

// 对象序列化接口 string, slice, array, map json序列化,
// 第一版二进制结构：
// 		指针结构：含1字节标识位(0000 0001 是否nil) + 其他
// 		string, slice, map, 复杂结构， 结构体等： 4字节长度 + ToDB|json.Marshal长度
// 		其他简单基础结构：按照最大字节存储
// 		core.Conversion 只会检查指针 例如:
// 			(m *Persist) FromDB(data []byte) error
// 			(m *Persist) ToDB(data []byte, err error)
// 自定义解析字段， 暂时不允许是其他包的结构，分析引入关系比较复杂

// 待优化功能:
// 1: LoadMany方法, 一次导入多个玩家数据
// 2: 优化对象序列化大小，添加tag 一定程度兼容新旧结构, 支持更多的类型优化

const (
	EUserShareManagerStateIdle   = 0 // 初始化
	EUserShareManagerStateNormal = 1 // 正常运行
	EUserShareManagerStatePanic  = 2 // 非法停止

	EUserShareTableStateDisk      = 0 // 导出
	EUserShareTableStateLoading   = 1 // 全导入开始
	EUserShareTableStateMemory    = 2 // 全导入完成
	EUserShareTableStateUnloading = 3 // 正在全导出

	EUserShareLoadStateDisk             = 0 // 不存在 or 导出
	EUserShareLoadStateLoading          = 1 // 导入开始
	EUserShareLoadStateMemory           = 2 // 导入完成
	EUserShareLoadStatePrepareUnloading = 3 // 准备导出
	EUserShareLoadStateUnloading        = 4 // 正在导出

	EUserShareOpInsert = 1 // 新建
	EUserShareOpUpdate = 2 // 修改
	EUserShareOpDelete = 3 // 删除
	EUserShareOpUnload = 4 // 导出

	EUserShareCollectStateNormal    = 0 // 正常
	EUserShareCollectStateSaveSync  = 1 // 开始退出, 清理同步队列
	EUserShareCollectStateSaveCache = 2 // 开始退出,清理缓存队列
	EUserShareCollectStateSaveDone  = 3 // 写回完成

)

type UserShare = model.UserShare

// UserShareDeepCopy persist对象必须支持并发访问, 不实现该接口默认深拷贝对象 (1 建议实现该接口,反射效率较低  2 map 建议生成syncmap  3 slice 建议深拷贝)
type UserShareDeepCopy interface {
	CopyTo(t *model.UserShare)
}

// UserShareOverload 未落地数据超过阈值时调用
type UserShareOverload interface {
	Overload(queueSize int, lastWriteBackTime time.Duration)
}

type UserShareUid struct {
	Uid int64
}

type UserShareUserNameStatus struct {
	UserName string
	Status   int64
}

type UserShareMobile struct {
	Mobile string
}

type UserShareKeyTypeHashUid = UserShareUid

type UserShareKeyTypeHashUserNameStatus = UserShareUserNameStatus

type UserShareKeyTypeHashMobile = UserShareMobile

// UserShareManager 索引类型定义

// only define type UserShareHashUidMark map[UserShareKeyTypeHashUid]bool

// only define type UserShareHashUid map[UserShareKeyTypeHashUid]*model.UserShare

// only define type UserShareHashUserNameStatus map[UserShareKeyTypeHashUserNameStatus]*model.UserShare

// only define type UserShareHashMobile map[UserShareKeyTypeHashMobile]*model.UserShare

// UserShareFieldIndex 所有列index枚举
// UserShareBitSet begin
// 读ast计算FieldLength 生成所有字段常量 0~length
type UserShareFieldIndex = uint

const EUserShareFieldIndexZero UserShareFieldIndex = 0

const EUserShareFieldIndexUid UserShareFieldIndex = 0

const EUserShareFieldIndexUserName UserShareFieldIndex = 1

const EUserShareFieldIndexNickName UserShareFieldIndex = 2

const EUserShareFieldIndexPassword UserShareFieldIndex = 3

const EUserShareFieldIndexMobile UserShareFieldIndex = 4

const EUserShareFieldIndexGender UserShareFieldIndex = 5

const EUserShareFieldIndexEmail UserShareFieldIndex = 6

const EUserShareFieldIndexAvatar UserShareFieldIndex = 7

const EUserShareFieldIndexStatus UserShareFieldIndex = 8

const EUserShareFieldIndexDeptId UserShareFieldIndex = 9

const EUserShareFieldIndexRoleId UserShareFieldIndex = 10

const EUserShareFieldIndexToken UserShareFieldIndex = 11

const EUserShareFieldIndexRemark UserShareFieldIndex = 12

const EUserShareFieldIndexCreateBy UserShareFieldIndex = 13

const EUserShareFieldIndexUpdateBy UserShareFieldIndex = 14

const EUserShareFieldIndexLastLoginTime UserShareFieldIndex = 15

const EUserShareFieldIndexLastLoginIp UserShareFieldIndex = 16

const EUserShareFiledIndexLength UserShareFieldIndex = 17

var UserShareStructFiledMap = [EUserShareFiledIndexLength]string{
	"Uid",
	"UserName",
	"NickName",
	"Password",
	"Mobile",
	"Gender",
	"Email",
	"Avatar",
	"Status",
	"DeptId",
	"RoleId",
	"Token",
	"Remark",
	"CreateBy",
	"UpdateBy",
	"LastLoginTime",
	"LastLoginIp",
}

var UserShareDBFiledMap [EUserShareFiledIndexLength]string

// EUserShareWordSize the EUserShareWordSize of a bit set
const EUserShareWordSize = UserShareFieldIndex(64)

// EUserShareLog2WordSize is lg(EUserShareWordSize)
const EUserShareLog2WordSize = UserShareFieldIndex(6)

// EUserShareAllBits has every bit set
const EUserShareAllBits uint64 = 0xffffffffffffffff

type UserShareBitSet struct {
	set [(EUserShareFiledIndexLength >> EUserShareLog2WordSize) + 1]uint64
}

// Get whether bit i is set.
func (b *UserShareBitSet) Get(i UserShareFieldIndex) bool {
	if i >= EUserShareFiledIndexLength {
		return false
	}
	return b.set[i>>EUserShareLog2WordSize]&(1<<(i&(EUserShareWordSize-1))) != 0
}

// Set bit i to 1
func (b *UserShareBitSet) Set(i UserShareFieldIndex) *UserShareBitSet {
	if i >= EUserShareFiledIndexLength {
		return nil
	}
	b.set[i>>EUserShareLog2WordSize] |= 1 << (i & (EUserShareWordSize - 1))
	return b
}

func (b *UserShareBitSet) Clear(i UserShareFieldIndex) *UserShareBitSet {
	if i >= EUserShareFiledIndexLength {
		return b
	}
	b.set[i>>EUserShareLog2WordSize] &^= 1 << (i & (EUserShareWordSize - 1))
	return b
}

// Merge compare to b
func (b *UserShareBitSet) Merge(compare UserShareBitSet) *UserShareBitSet {
	for i, word := range b.set {
		b.set[i] = word | compare.set[i]
	}
	return b
}

func (b *UserShareBitSet) ClearAll() *UserShareBitSet {
	if b != nil {
		for i := range b.set {
			b.set[i] = 0
		}
	}
	return b
}

func (b *UserShareBitSet) SetAll() *UserShareBitSet {
	if b != nil {
		for i := range b.set {
			b.set[i] = EUserShareAllBits
		}
	}
	return b
}

func (b *UserShareBitSet) IsSetAll() bool {
	if b != nil {
		for i := range b.set {
			if b.set[i] != EUserShareAllBits {
				return false
			}
		}
	}
	return true
}

// UserShareBitSet end

// UserShareSync 结构定义

type UserShareSync struct {
	Data   *model.UserShare
	Op     int8
	BitSet UserShareBitSet
}

// UserShareManager 结构定义

type UserShareManager struct {

	// 0:初始化  1:正常运行  2:非法停止
	managerState int32
	// 0:导出  1:全导入开始  2:全导入完成  3:正在全导出
	loadAll int32

	// 不存在 or 0:导出  1:导入开始  2:导入完成  3:准备导出  4:正在导出
	loadUidMap UserShareMapUnload // map[Uid]state(atom)

	pool              *sync.Pool
	syncChan          chan *UserShareSync
	syncQueue         *[]*UserShareSync
	cacheQueue        *[]*UserShareSync
	FailQueue         []*UserShareSync
	lastWriteBackTime time.Duration

	InsertQueue []*UserShareSync

	syncBegin chan bool
	syncEnd   chan bool
	exitBegin chan bool
	exitEnd   chan bool

	engine *xorm.Engine

	hashUid UserShareHashUid

	hashUserNameStatus UserShareHashUserNameStatus

	hashMobile UserShareHashMobile

	// hashUidMark UserShareHashUidMark

	bitSetAll UserShareBitSet
}

var gUserShareNil = &model.UserShare{}

func NewUserShareManager(engine *xorm.Engine) (m *UserShareManager) {
	m = &UserShareManager{engine: engine}

	m.syncChan = make(chan *UserShareSync, runtime.NumCPU()*2)
	tmpSyncQueue := make([]*UserShareSync, 0)
	m.syncQueue = &tmpSyncQueue
	m.syncEnd = make(chan bool)
	m.syncBegin = make(chan bool)
	m.exitBegin = make(chan bool)
	m.exitEnd = make(chan bool)
	tmpCacheQueue := make([]*UserShareSync, 0)
	m.cacheQueue = &tmpCacheQueue
	m.lastWriteBackTime = 1 * time.Millisecond
	m.pool = &sync.Pool{New: func() interface{} { return &model.UserShare{} }}

	m.bitSetAll.SetAll()

	if engine != nil {
		for idx, name := range UserShareStructFiledMap {
			UserShareDBFiledMap[idx] = engine.GetColumnMapper().Obj2Table(name)
		}
	}

	return
}

// NewUserShare 通过主键创建对象, 已经存在直接返回. (1 数据没有导入或已经导出) 会返回nil. (2 数据已存在) 返回已存在的值
func NewUserShare(Uid int64) (ormCls *model.UserShare) {

	if GUserShareManager.LoadState(Uid) != EUserShareLoadStateMemory {
		ormCls = nil
		return
	}

	ormCls = GUserShareManager.GetUserShareByUid(Uid)
	if ormCls != nil {
		return
	}
	ormCls, _ = GUserShareManager.NewUserShare(&model.UserShare{Uid: Uid})
	return
}

// PersistName 返回persist类名
func (m *UserShareManager) PersistName() string {
	return reflect.TypeOf(*gUserShareNil).Name()
}

// PersistObj 返回persist interface{}
func (m *UserShareManager) PersistUserNilObjInterface() interface{} {
	return &model.UserShare{}
}

// PersistObj 返回persist interface{} list
func (m *UserShareManager) PersistUserNilObjInterfaceList() interface{} {
	plist := make([]*model.UserShare, 0, 0)
	return &plist
}

// Run 运行并导入上次失败数据
func (m *UserShareManager) Run() error {
	if atomic.CompareAndSwapInt32(&m.managerState, EUserShareManagerStateIdle, EUserShareManagerStateNormal) {
		if err := m.LoadFile(); err != nil {
			return err
		}
		go m.Collect()
	} else if atomic.CompareAndSwapInt32(&m.managerState, EUserShareManagerStatePanic, EUserShareManagerStateNormal) {
		if err := m.LoadFile(); err != nil {
			return err
		}
		go m.Collect()
	} else {
	}
	return nil
}

// Dead 管理类是否出错
func (m *UserShareManager) Dead() bool {
	return atomic.LoadInt32(&m.managerState) != EUserShareManagerStateNormal
}

func (m *UserShareManager) BytesToPersistInterface(data []byte) (cls interface{}) {
	return m.BytesToPersist(data)
}

// BytesToPersist反序列化
func (m *UserShareManager) BytesToPersist(data []byte) (cls *model.UserShare) {
	var err error
	if data == nil {
		return nil
	}
	defer func() {
		if r := recover(); r != nil {
			log.Println("recovered in ", r)
			log.Println("stack: ", string(debug.Stack()))
		}
		if err != nil {
			log.Println("BytesToPersist Error", err.Error())
		}
	}()
	i := 0
	cls = &model.UserShare{}

	//Uid	int64

	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1

		cls.Uid = int64(binary.LittleEndian.Uint64(data[i:]))
		i += 64 / 8
	} else {
		i += 1
	}

	//UserName	string

	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1

		lenFieldDataUserName := int(binary.LittleEndian.Uint32(data[i:]))
		i += 4
		cls.UserName = string(data[i : i+lenFieldDataUserName])
		i += lenFieldDataUserName
	} else {
		i += 1
	}

	//NickName	string

	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1

		lenFieldDataNickName := int(binary.LittleEndian.Uint32(data[i:]))
		i += 4
		cls.NickName = string(data[i : i+lenFieldDataNickName])
		i += lenFieldDataNickName
	} else {
		i += 1
	}

	//Password	string

	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1

		lenFieldDataPassword := int(binary.LittleEndian.Uint32(data[i:]))
		i += 4
		cls.Password = string(data[i : i+lenFieldDataPassword])
		i += lenFieldDataPassword
	} else {
		i += 1
	}

	//Mobile	string

	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1

		lenFieldDataMobile := int(binary.LittleEndian.Uint32(data[i:]))
		i += 4
		cls.Mobile = string(data[i : i+lenFieldDataMobile])
		i += lenFieldDataMobile
	} else {
		i += 1
	}

	//Gender	int32

	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1

		cls.Gender = int32(binary.LittleEndian.Uint32(data[i:]))
		i += 32 / 8
	} else {
		i += 1
	}

	//Email	string

	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1

		lenFieldDataEmail := int(binary.LittleEndian.Uint32(data[i:]))
		i += 4
		cls.Email = string(data[i : i+lenFieldDataEmail])
		i += lenFieldDataEmail
	} else {
		i += 1
	}

	//Avatar	string

	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1

		lenFieldDataAvatar := int(binary.LittleEndian.Uint32(data[i:]))
		i += 4
		cls.Avatar = string(data[i : i+lenFieldDataAvatar])
		i += lenFieldDataAvatar
	} else {
		i += 1
	}

	//Status	int64

	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1

		cls.Status = int64(binary.LittleEndian.Uint64(data[i:]))
		i += 64 / 8
	} else {
		i += 1
	}

	//DeptId	int64

	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1

		cls.DeptId = int64(binary.LittleEndian.Uint64(data[i:]))
		i += 64 / 8
	} else {
		i += 1
	}

	//RoleId	int64

	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1

		cls.RoleId = int64(binary.LittleEndian.Uint64(data[i:]))
		i += 64 / 8
	} else {
		i += 1
	}

	//Token	string

	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1

		lenFieldDataToken := int(binary.LittleEndian.Uint32(data[i:]))
		i += 4
		cls.Token = string(data[i : i+lenFieldDataToken])
		i += lenFieldDataToken
	} else {
		i += 1
	}

	//Remark	string

	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1

		lenFieldDataRemark := int(binary.LittleEndian.Uint32(data[i:]))
		i += 4
		cls.Remark = string(data[i : i+lenFieldDataRemark])
		i += lenFieldDataRemark
	} else {
		i += 1
	}

	//CreateBy	int64

	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1

		cls.CreateBy = int64(binary.LittleEndian.Uint64(data[i:]))
		i += 64 / 8
	} else {
		i += 1
	}

	//UpdateBy	int64

	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1

		cls.UpdateBy = int64(binary.LittleEndian.Uint64(data[i:]))
		i += 64 / 8
	} else {
		i += 1
	}

	//LastLoginTime	int64

	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1

		cls.LastLoginTime = int64(binary.LittleEndian.Uint64(data[i:]))
		i += 64 / 8
	} else {
		i += 1
	}

	//LastLoginIp	string

	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1

		lenFieldDataLastLoginIp := int(binary.LittleEndian.Uint32(data[i:]))
		i += 4
		cls.LastLoginIp = string(data[i : i+lenFieldDataLastLoginIp])
		i += lenFieldDataLastLoginIp
	} else {
		i += 1
	}

	return
}

//

func (m *UserShareManager) PersistInterfaceToBytes(i interface{}) (data []byte) {
	return m.PersistToBytes(i.(*model.UserShare), m.bitSetAll)
}

func (m *UserShareManager) PersistInterfaceToPkStruct(i interface{}) interface{} {
	cls, ok := i.(*model.UserShare)
	_ = cls
	if !ok {
		return nil
	}

	pk := UserShareUid{

		Uid: cls.Uid,
	}
	return pk

}

// PersistToBytes 序列化
func (m *UserShareManager) PersistToBytes(cls *model.UserShare, bitSet UserShareBitSet) (data []byte) {
	var err error
	if cls == nil {
		return nil
	}
	defer func() {
		if r := recover(); r != nil {
			log.Println("recovered in ", r)
			log.Println("stack: ", string(debug.Stack()))
		}
		if err != nil {
			log.Println("PersistToBytes Error", err.Error())
		}
	}()
	size := 0

	//Uid	int64

	if true || bitSet.Get(EUserShareFieldIndexUid) {
		size += 1 + 64/8
	} else {
		size += 1
	}

	//UserName	string

	if bitSet.Get(EUserShareFieldIndexUserName) {
		size += 1 + 4 + len(cls.UserName)
	} else {
		size += 1
	}

	//NickName	string

	if bitSet.Get(EUserShareFieldIndexNickName) {
		size += 1 + 4 + len(cls.NickName)
	} else {
		size += 1
	}

	//Password	string

	if bitSet.Get(EUserShareFieldIndexPassword) {
		size += 1 + 4 + len(cls.Password)
	} else {
		size += 1
	}

	//Mobile	string

	if bitSet.Get(EUserShareFieldIndexMobile) {
		size += 1 + 4 + len(cls.Mobile)
	} else {
		size += 1
	}

	//Gender	int32

	if bitSet.Get(EUserShareFieldIndexGender) {
		size += 1 + 32/8
	} else {
		size += 1
	}

	//Email	string

	if bitSet.Get(EUserShareFieldIndexEmail) {
		size += 1 + 4 + len(cls.Email)
	} else {
		size += 1
	}

	//Avatar	string

	if bitSet.Get(EUserShareFieldIndexAvatar) {
		size += 1 + 4 + len(cls.Avatar)
	} else {
		size += 1
	}

	//Status	int64

	if bitSet.Get(EUserShareFieldIndexStatus) {
		size += 1 + 64/8
	} else {
		size += 1
	}

	//DeptId	int64

	if bitSet.Get(EUserShareFieldIndexDeptId) {
		size += 1 + 64/8
	} else {
		size += 1
	}

	//RoleId	int64

	if bitSet.Get(EUserShareFieldIndexRoleId) {
		size += 1 + 64/8
	} else {
		size += 1
	}

	//Token	string

	if bitSet.Get(EUserShareFieldIndexToken) {
		size += 1 + 4 + len(cls.Token)
	} else {
		size += 1
	}

	//Remark	string

	if bitSet.Get(EUserShareFieldIndexRemark) {
		size += 1 + 4 + len(cls.Remark)
	} else {
		size += 1
	}

	//CreateBy	int64

	if bitSet.Get(EUserShareFieldIndexCreateBy) {
		size += 1 + 64/8
	} else {
		size += 1
	}

	//UpdateBy	int64

	if bitSet.Get(EUserShareFieldIndexUpdateBy) {
		size += 1 + 64/8
	} else {
		size += 1
	}

	//LastLoginTime	int64

	if bitSet.Get(EUserShareFieldIndexLastLoginTime) {
		size += 1 + 64/8
	} else {
		size += 1
	}

	//LastLoginIp	string

	if bitSet.Get(EUserShareFieldIndexLastLoginIp) {
		size += 1 + 4 + len(cls.LastLoginIp)
	} else {
		size += 1
	}

	// ************************************ marshal ************************************
	data = make([]byte, size)
	i := 0

	//Uid	int64

	if true || bitSet.Get(EUserShareFieldIndexUid) {
		data[i] |= persistCore.EMarshalFlagBitSet
		i += 1

		binary.LittleEndian.PutUint64(data[i:], uint64(cls.Uid))
		i += 64 / 8
	} else {
		i += 1
	}

	//UserName	string

	if bitSet.Get(EUserShareFieldIndexUserName) {
		data[i] |= persistCore.EMarshalFlagBitSet
		i += 1

		binary.LittleEndian.PutUint32(data[i:], uint32(len(cls.UserName)))
		i += 4
		copy(data[i:], cls.UserName)
		i += len(cls.UserName)
	} else {
		i += 1
	}

	//NickName	string

	if bitSet.Get(EUserShareFieldIndexNickName) {
		data[i] |= persistCore.EMarshalFlagBitSet
		i += 1

		binary.LittleEndian.PutUint32(data[i:], uint32(len(cls.NickName)))
		i += 4
		copy(data[i:], cls.NickName)
		i += len(cls.NickName)
	} else {
		i += 1
	}

	//Password	string

	if bitSet.Get(EUserShareFieldIndexPassword) {
		data[i] |= persistCore.EMarshalFlagBitSet
		i += 1

		binary.LittleEndian.PutUint32(data[i:], uint32(len(cls.Password)))
		i += 4
		copy(data[i:], cls.Password)
		i += len(cls.Password)
	} else {
		i += 1
	}

	//Mobile	string

	if bitSet.Get(EUserShareFieldIndexMobile) {
		data[i] |= persistCore.EMarshalFlagBitSet
		i += 1

		binary.LittleEndian.PutUint32(data[i:], uint32(len(cls.Mobile)))
		i += 4
		copy(data[i:], cls.Mobile)
		i += len(cls.Mobile)
	} else {
		i += 1
	}

	//Gender	int32

	if bitSet.Get(EUserShareFieldIndexGender) {
		data[i] |= persistCore.EMarshalFlagBitSet
		i += 1

		binary.LittleEndian.PutUint32(data[i:], uint32(cls.Gender))
		i += 32 / 8
	} else {
		i += 1
	}

	//Email	string

	if bitSet.Get(EUserShareFieldIndexEmail) {
		data[i] |= persistCore.EMarshalFlagBitSet
		i += 1

		binary.LittleEndian.PutUint32(data[i:], uint32(len(cls.Email)))
		i += 4
		copy(data[i:], cls.Email)
		i += len(cls.Email)
	} else {
		i += 1
	}

	//Avatar	string

	if bitSet.Get(EUserShareFieldIndexAvatar) {
		data[i] |= persistCore.EMarshalFlagBitSet
		i += 1

		binary.LittleEndian.PutUint32(data[i:], uint32(len(cls.Avatar)))
		i += 4
		copy(data[i:], cls.Avatar)
		i += len(cls.Avatar)
	} else {
		i += 1
	}

	//Status	int64

	if bitSet.Get(EUserShareFieldIndexStatus) {
		data[i] |= persistCore.EMarshalFlagBitSet
		i += 1

		binary.LittleEndian.PutUint64(data[i:], uint64(cls.Status))
		i += 64 / 8
	} else {
		i += 1
	}

	//DeptId	int64

	if bitSet.Get(EUserShareFieldIndexDeptId) {
		data[i] |= persistCore.EMarshalFlagBitSet
		i += 1

		binary.LittleEndian.PutUint64(data[i:], uint64(cls.DeptId))
		i += 64 / 8
	} else {
		i += 1
	}

	//RoleId	int64

	if bitSet.Get(EUserShareFieldIndexRoleId) {
		data[i] |= persistCore.EMarshalFlagBitSet
		i += 1

		binary.LittleEndian.PutUint64(data[i:], uint64(cls.RoleId))
		i += 64 / 8
	} else {
		i += 1
	}

	//Token	string

	if bitSet.Get(EUserShareFieldIndexToken) {
		data[i] |= persistCore.EMarshalFlagBitSet
		i += 1

		binary.LittleEndian.PutUint32(data[i:], uint32(len(cls.Token)))
		i += 4
		copy(data[i:], cls.Token)
		i += len(cls.Token)
	} else {
		i += 1
	}

	//Remark	string

	if bitSet.Get(EUserShareFieldIndexRemark) {
		data[i] |= persistCore.EMarshalFlagBitSet
		i += 1

		binary.LittleEndian.PutUint32(data[i:], uint32(len(cls.Remark)))
		i += 4
		copy(data[i:], cls.Remark)
		i += len(cls.Remark)
	} else {
		i += 1
	}

	//CreateBy	int64

	if bitSet.Get(EUserShareFieldIndexCreateBy) {
		data[i] |= persistCore.EMarshalFlagBitSet
		i += 1

		binary.LittleEndian.PutUint64(data[i:], uint64(cls.CreateBy))
		i += 64 / 8
	} else {
		i += 1
	}

	//UpdateBy	int64

	if bitSet.Get(EUserShareFieldIndexUpdateBy) {
		data[i] |= persistCore.EMarshalFlagBitSet
		i += 1

		binary.LittleEndian.PutUint64(data[i:], uint64(cls.UpdateBy))
		i += 64 / 8
	} else {
		i += 1
	}

	//LastLoginTime	int64

	if bitSet.Get(EUserShareFieldIndexLastLoginTime) {
		data[i] |= persistCore.EMarshalFlagBitSet
		i += 1

		binary.LittleEndian.PutUint64(data[i:], uint64(cls.LastLoginTime))
		i += 64 / 8
	} else {
		i += 1
	}

	//LastLoginIp	string

	if bitSet.Get(EUserShareFieldIndexLastLoginIp) {
		data[i] |= persistCore.EMarshalFlagBitSet
		i += 1

		binary.LittleEndian.PutUint32(data[i:], uint32(len(cls.LastLoginIp)))
		i += 4
		copy(data[i:], cls.LastLoginIp)
		i += len(cls.LastLoginIp)
	} else {
		i += 1
	}

	return
}

// PersistToPersistByBitSet 按位图复制数据
func (m *UserShareManager) PersistToPersistByBitSet(dst, src *model.UserShare, bitSet UserShareBitSet) {
	var err error
	if dst == nil || src == nil {
		log.Println("PersistToPersistByBitSet Error, dst or src is nil")
		return
	}
	defer func() {
		if r := recover(); r != nil {
			log.Println("recovered in ", r)
			log.Println("stack: ", string(debug.Stack()))
		}
		if err != nil {
			log.Println("PersistToPersistByBitSet Error", err.Error())
		}
	}()

	//Uid	int64
	if bitSet.Get(EUserShareFieldIndexUid) {
		dst.Uid = src.Uid
	}

	//UserName	string
	if bitSet.Get(EUserShareFieldIndexUserName) {
		dst.UserName = src.UserName
	}

	//NickName	string
	if bitSet.Get(EUserShareFieldIndexNickName) {
		dst.NickName = src.NickName
	}

	//Password	string
	if bitSet.Get(EUserShareFieldIndexPassword) {
		dst.Password = src.Password
	}

	//Mobile	string
	if bitSet.Get(EUserShareFieldIndexMobile) {
		dst.Mobile = src.Mobile
	}

	//Gender	int32
	if bitSet.Get(EUserShareFieldIndexGender) {
		dst.Gender = src.Gender
	}

	//Email	string
	if bitSet.Get(EUserShareFieldIndexEmail) {
		dst.Email = src.Email
	}

	//Avatar	string
	if bitSet.Get(EUserShareFieldIndexAvatar) {
		dst.Avatar = src.Avatar
	}

	//Status	int64
	if bitSet.Get(EUserShareFieldIndexStatus) {
		dst.Status = src.Status
	}

	//DeptId	int64
	if bitSet.Get(EUserShareFieldIndexDeptId) {
		dst.DeptId = src.DeptId
	}

	//RoleId	int64
	if bitSet.Get(EUserShareFieldIndexRoleId) {
		dst.RoleId = src.RoleId
	}

	//Token	string
	if bitSet.Get(EUserShareFieldIndexToken) {
		dst.Token = src.Token
	}

	//Remark	string
	if bitSet.Get(EUserShareFieldIndexRemark) {
		dst.Remark = src.Remark
	}

	//CreateBy	int64
	if bitSet.Get(EUserShareFieldIndexCreateBy) {
		dst.CreateBy = src.CreateBy
	}

	//UpdateBy	int64
	if bitSet.Get(EUserShareFieldIndexUpdateBy) {
		dst.UpdateBy = src.UpdateBy
	}

	//LastLoginTime	int64
	if bitSet.Get(EUserShareFieldIndexLastLoginTime) {
		dst.LastLoginTime = src.LastLoginTime
	}

	//LastLoginIp	string
	if bitSet.Get(EUserShareFieldIndexLastLoginIp) {
		dst.LastLoginIp = src.LastLoginIp
	}

	return
}

// BytesToPersistSync 反序列化sync
func (m *UserShareManager) BytesToPersistSync(data []byte) (persistSync *UserShareSync) {
	var err error
	if data == nil {
		return nil
	}
	defer func() {
		if r := recover(); r != nil {
			log.Println("recovered in ", r)
			log.Println("stack: ", string(debug.Stack()))
		}
		if err != nil {
			log.Println("BytesToPersistSync Error", err.Error())
		}
	}()
	i := 0

	const bitSetSize = (int)((EUserShareFiledIndexLength>>EUserShareLog2WordSize)+1) * 8

	persistSync = &UserShareSync{}
	lenPersistData := len(data) - bitSetSize - 1

	persistSync.Data = m.BytesToPersist(data[:lenPersistData])

	i += lenPersistData
	persistSync.Op = int8(data[i])
	i += 1
	for j := 0; j < bitSetSize/8; j++ {
		persistSync.BitSet.set[j] = binary.LittleEndian.Uint64(data[i:])
		i += 8
	}

	return
}

// PersistSyncToBytes 序列化sync
func (m *UserShareManager) PersistSyncToBytes(persistSync *UserShareSync) (data []byte) {
	var err error
	if persistSync == nil {
		return nil
	}
	defer func() {
		if r := recover(); r != nil {
			log.Println("recovered in ", r)
			log.Println("stack: ", string(debug.Stack()))
		}
		if err != nil {
			log.Println("PersistSyncToBytes Error", err.Error())
		}
	}()
	size := 0

	const bitSetSize = (int)((EUserShareFiledIndexLength>>EUserShareLog2WordSize)+1) * 8

	pData := m.PersistToBytes(persistSync.Data, persistSync.BitSet)
	size += len(pData) + 1 + bitSetSize

	data = make([]byte, size)

	i := 0

	copy(data[i:], pData)
	i += len(pData)
	data[i] = uint8(persistSync.Op)
	i += 1
	for _, setItem := range persistSync.BitSet.set {
		binary.LittleEndian.PutUint64(data[i:], setItem)
		i += 8
	}

	return
}

// StringToPersistSyncInterface 反序列化2syncInterface
func (m *UserShareManager) StringToPersistSyncInterface(data string) interface{} {
	return m.StringToPersistSync(data)
}

// StringToPersistSync 反序列化2sync
func (m *UserShareManager) StringToPersistSync(data string) (persistSync *UserShareSync) {
	if data == "" {
		return nil
	}
	buf, err := base64.StdEncoding.DecodeString(data)
	if err != nil {
		return nil
	}
	return m.BytesToPersistSync(buf)
}

// PersistSyncToString 序列化2sync
func (m *UserShareManager) PersistSyncToString(persistSync *UserShareSync) (data string) {
	buf := m.PersistSyncToBytes(persistSync)
	if buf == nil {
		return ""
	}
	data = base64.StdEncoding.EncodeToString(buf)
	return
}

// UnmarshalFailQueue 失败队列反序列化
func (m *UserShareManager) UnmarshalFailQueue(data []byte, failQueue *[]*UserShareSync) (err error) {
	if data == nil || failQueue == nil {
		return nil
	}
	defer func() {
		if r := recover(); r != nil {
			log.Println("recovered in ", r)
			log.Println("stack: ", string(debug.Stack()))
		}
		if err != nil {
			log.Println("UnmarshalFailQueue Error", err.Error())
		}
	}()
	i := 0
	lenFailQueue := binary.LittleEndian.Uint32(data[i:])
	i += 4
	*failQueue = make([]*UserShareSync, lenFailQueue)
	for idx := 0; idx < int(lenFailQueue); idx++ {
		lenPersistSyncData := int(binary.LittleEndian.Uint32(data[i:]))
		i += 4
		persistSync := m.BytesToPersistSync(data[i : i+lenPersistSyncData])
		i += lenPersistSyncData
		(*failQueue)[idx] = persistSync
	}
	return nil
}

// MarshalFailQueue 失败队列序列化
func (m *UserShareManager) MarshalFailQueue(failQueue []*UserShareSync) (data []byte, err error) {
	var idx int
	var size int
	var persistSync *UserShareSync
	defer func() {
		if r := recover(); r != nil {
			log.Println("recovered in ", r)
			log.Println("stack: ", string(debug.Stack()))
		}
		if err != nil {
			log.Println("MarshalFailQueue Error", err.Error())
		}
	}()
	persistSyncDataList := make([][]byte, len(failQueue))
	size += 4
	for idx = range failQueue {
		persistSync = failQueue[idx]
		pData := m.PersistSyncToBytes(persistSync)
		persistSyncDataList[idx] = pData
		size += 4 + len(pData)
	}

	data = make([]byte, size)
	i := 0
	binary.LittleEndian.PutUint32(data[i:], uint32(len(failQueue)))
	i += 4
	for idx = range failQueue {
		binary.LittleEndian.PutUint32(data[i:], uint32(len(persistSyncDataList[idx])))
		i += 4
		copy(data[i:], persistSyncDataList[idx])
		i += len(persistSyncDataList[idx])
	}
	return
}

// acquireDeepCopyObject 拷贝一个新对象用于写回
func (m *UserShareManager) acquireDeepCopyObject(cls *model.UserShare) (ret *model.UserShare) {
	if v, ok := ((interface{})(cls)).(UserShareDeepCopy); ok {
		//ret = m.pool.Get().(*model.UserShare)
		ret = &model.UserShare{}
		v.CopyTo(ret)
	} else {
		ret = m.BytesToPersist(m.PersistToBytes(cls, m.bitSetAll))
	}
	return
}

// releaseDeepCopyObject 释放对象
func (m *UserShareManager) releaseDeepCopyObject(cls *model.UserShare) {
	//if _, ok := ((interface{})(cls)).(*UserShareDeepCopy); ok {
	//	m.pool.Put(cls)
	//}
	return
}

// CheckOverload 检查负载
func (m *UserShareManager) CheckOverload() {
	// queueLength 不是精确值,  cacheQueue, FailQueue 一写多读
	queueLength := len(*m.cacheQueue) + len(m.FailQueue)
	if queueLength > 10000 {
		if v, ok := ((interface{})(gUserShareNil)).(UserShareOverload); ok {
			go utils.SafeGoRecoverWarpFunc(func() { v.Overload(queueLength, m.lastWriteBackTime) })
		} else {
		}
	} else {
	}
}

// addUserShare添加一个对象
func (m *UserShareManager) addUserShare(cls *model.UserShare) (*model.UserShare, bool) {

	actual, loaded := m.hashUid.LoadOrStore(UserShareKeyTypeHashUid{cls.Uid}, cls)
	if !loaded {
		actual = cls

		m.hashUserNameStatus.Store(UserShareKeyTypeHashUserNameStatus{cls.UserName, cls.Status}, cls)

		m.hashMobile.Store(UserShareKeyTypeHashMobile{cls.Mobile}, cls)

	}
	return actual, !loaded
}

// removeUserShare 删除一个对象
func (m *UserShareManager) removeUserShare(cls *model.UserShare) {
	// m.hashUidMark.Delete(UserShareKeyTypeHashUid{ cls.Uid, })

	m.hashMobile.Delete(UserShareKeyTypeHashMobile{cls.Mobile})

	m.hashUserNameStatus.Delete(UserShareKeyTypeHashUserNameStatus{cls.UserName, cls.Status})

	m.hashUid.Delete(UserShareKeyTypeHashUid{cls.Uid})

	return
}

// InitDS ds并发map初始化
func (m *UserShareManager) InitDS(cls *model.UserShare) {
	// todo
	// cls.MyMap = ds.RWMapInt32Int32{}

	//Uid	int64

	//UserName	string

	//NickName	string

	//Password	string

	//Mobile	string

	//Gender	int32

	//Email	string

	//Avatar	string

	//Status	int64

	//DeptId	int64

	//RoleId	int64

	//Token	string

	//Remark	string

	//CreateBy	int64

	//UpdateBy	int64

	//LastLoginTime	int64

	//LastLoginIp	string

}

// NewUserShare 添加对象并异步写回数据库, (1 数据没有导入或已经导出, 2 数据已存在, 3 对象为空) 会返回失败
func (m *UserShareManager) NewUserShare(cls *model.UserShare) (*model.UserShare, error) {

	if cls == nil {
		return nil, persistCore.EPersistErrorNil
	}

	if m.LoadState(cls.Uid) != EUserShareLoadStateMemory {
		return nil, persistCore.EPersistErrorNotInMemory
	}

	actual, success := m.addUserShare(cls)

	if success {
		m.InitDS(cls)
		bitSet := UserShareBitSet{}
		bitSet.SetAll()
		newCls := m.acquireDeepCopyObject(cls)

		persistSync := &UserShareSync{Data: newCls, Op: EUserShareOpInsert, BitSet: bitSet}

		log.Println("[sql trace UserShare]", m.PersistSyncToString(persistSync))

		m.syncChan <- persistSync

	} else {
		return actual, persistCore.EPersistErrorAlreadyExist
	}

	return actual, nil
}

// DeleteUserShare 删除对象并异步写回数据库 (1 数据没有导入或已经导出, 2 数据已经重新导入, 3 对象为空) 会返回失败
func (m *UserShareManager) DeleteUserShare(cls *model.UserShare) error {
	if cls == nil {
		return persistCore.EPersistErrorNil
	}

	if m.LoadState(cls.Uid) != EUserShareLoadStateMemory {
		return persistCore.EPersistErrorNotInMemory
	}

	p := m.GetUserShareByUid(cls.Uid)
	if p == nil || p != cls {
		return persistCore.EPersistErrorOutOfDate
	}

	m.removeUserShare(cls)

	// 主键不能修改
	bitSet := UserShareBitSet{}
	bitSet.SetAll()
	newCls := m.acquireDeepCopyObject(cls)

	persistSync := &UserShareSync{Data: newCls, Op: EUserShareOpDelete, BitSet: bitSet}

	log.Println("[sql trace UserShare]", m.PersistSyncToString(persistSync))

	m.syncChan <- persistSync

	return nil
}

// DeleteAll 删除所有对象并异步写回数据库
func (m *UserShareManager) DeleteAll() {

	var tmpUserShareList []*model.UserShare
	m.hashUid.Range(func(k UserShareKeyTypeHashUid, v *model.UserShare) bool {
		tmpUserShareList = append(tmpUserShareList, v)
		return true
	})
	for _, cls := range tmpUserShareList {
		if cls == nil {
			continue
		}
		m.removeUserShare(cls)

		// 主键不能修改
		bitSet := UserShareBitSet{}
		bitSet.SetAll()
		newCls := m.acquireDeepCopyObject(cls)

		persistSync := &UserShareSync{Data: newCls, Op: EUserShareOpDelete, BitSet: bitSet}

		log.Println("[sql trace UserShare]", m.PersistSyncToString(persistSync))

		m.syncChan <- persistSync

	}
}

// EOptimizeFlagUsePoolAndDisableDeleteUnload 优化下不支持修改索引

// 不建议修改索引列

// SetIndexKeyUserNameStatus 修改包含索引字段, 标记脏对象并异步写回数据库, 需要保证一致性, 生成时开启 EOptimizeFlagIndexMutex
// (1 数据没有导入或已经导出, 2 数据已经重新导入, 3 对象为空) 会返回失败
func (m *UserShareManager) SetIndexKeyUserNameStatus(cls *model.UserShare, UserName string, Status int64) error {

	if cls == nil {
		return persistCore.EPersistErrorNil
	}

	if m.LoadState(cls.Uid) != EUserShareLoadStateMemory {
		return persistCore.EPersistErrorNotInMemory
	}

	m.hashUserNameStatus.Delete(UserShareKeyTypeHashUserNameStatus{cls.UserName, cls.Status})

	cls.UserName = UserName

	cls.Status = Status

	m.hashUserNameStatus.Store(UserShareKeyTypeHashUserNameStatus{cls.UserName, cls.Status}, cls)

	// return m.MarkUpdate(cls)
	bitSet := UserShareBitSet{}

	bitSet.Set(EUserShareFieldIndexUserName)

	bitSet.Set(EUserShareFieldIndexStatus)

	return m.MarkUpdateByBitSet(cls, bitSet)
}

// SetIndexKeyMobile 修改包含索引字段, 标记脏对象并异步写回数据库, 需要保证一致性, 生成时开启 EOptimizeFlagIndexMutex
// (1 数据没有导入或已经导出, 2 数据已经重新导入, 3 对象为空) 会返回失败
func (m *UserShareManager) SetIndexKeyMobile(cls *model.UserShare, Mobile string) error {

	if cls == nil {
		return persistCore.EPersistErrorNil
	}

	if m.LoadState(cls.Uid) != EUserShareLoadStateMemory {
		return persistCore.EPersistErrorNotInMemory
	}

	m.hashMobile.Delete(UserShareKeyTypeHashMobile{cls.Mobile})

	cls.Mobile = Mobile

	m.hashMobile.Store(UserShareKeyTypeHashMobile{cls.Mobile}, cls)

	// return m.MarkUpdate(cls)
	bitSet := UserShareBitSet{}

	bitSet.Set(EUserShareFieldIndexMobile)

	return m.MarkUpdateByBitSet(cls, bitSet)
}

// SetIndexKeyUserName 修改包含索引字段, 标记脏对象并异步写回数据库, 需要保证一致性, 生成时开启 EOptimizeFlagIndexMutex
// (1 数据没有导入或已经导出, 2 数据已经重新导入, 3 对象为空) 会返回失败
func (m *UserShareManager) SetIndexKeyUserName(cls *model.UserShare, UserName string) error {

	if cls == nil {
		return persistCore.EPersistErrorNil
	}

	if m.LoadState(cls.Uid) != EUserShareLoadStateMemory {
		return persistCore.EPersistErrorNotInMemory
	}

	m.hashUserNameStatus.Delete(UserShareKeyTypeHashUserNameStatus{cls.UserName, cls.Status})

	cls.UserName = UserName

	m.hashUserNameStatus.Store(UserShareKeyTypeHashUserNameStatus{cls.UserName, cls.Status}, cls)

	// return m.MarkUpdate(cls)
	bitSet := UserShareBitSet{}
	bitSet.Set(EUserShareFieldIndexUserName)
	return m.MarkUpdateByBitSet(cls, bitSet)
}

// SetIndexKeyStatus 修改包含索引字段, 标记脏对象并异步写回数据库, 需要保证一致性, 生成时开启 EOptimizeFlagIndexMutex
// (1 数据没有导入或已经导出, 2 数据已经重新导入, 3 对象为空) 会返回失败
func (m *UserShareManager) SetIndexKeyStatus(cls *model.UserShare, Status int64) error {

	if cls == nil {
		return persistCore.EPersistErrorNil
	}

	if m.LoadState(cls.Uid) != EUserShareLoadStateMemory {
		return persistCore.EPersistErrorNotInMemory
	}

	m.hashUserNameStatus.Delete(UserShareKeyTypeHashUserNameStatus{cls.UserName, cls.Status})

	cls.Status = Status

	m.hashUserNameStatus.Store(UserShareKeyTypeHashUserNameStatus{cls.UserName, cls.Status}, cls)

	// return m.MarkUpdate(cls)
	bitSet := UserShareBitSet{}
	bitSet.Set(EUserShareFieldIndexStatus)
	return m.MarkUpdateByBitSet(cls, bitSet)
}

// MarkUpdate 标记脏对象并异步写回数据库, (1 数据没有导入或已经导出, 2 数据已经重新导入, 3 对象为空) 会返回失败
func (m *UserShareManager) MarkUpdate(cls *model.UserShare) error {
	if cls == nil {
		return persistCore.EPersistErrorNil
	}

	if m.LoadState(cls.Uid) != EUserShareLoadStateMemory {
		return persistCore.EPersistErrorNotInMemory
	}

	p := m.GetUserShareByUid(cls.Uid)
	if p == nil || p != cls {
		return persistCore.EPersistErrorOutOfDate
	}

	m.InitDS(cls)
	bitSet := UserShareBitSet{}
	bitSet.SetAll()
	newCls := m.acquireDeepCopyObject(cls)

	persistSync := &UserShareSync{Data: newCls, Op: EUserShareOpUpdate, BitSet: bitSet}

	log.Println("[sql trace UserShare]", m.PersistSyncToString(persistSync))

	m.syncChan <- persistSync

	return nil
}

// MarkUpdateByBitSet 标记脏对象并异步写回数据库, (1 数据没有导入或已经导出, 2 数据已经重新导入, 3 对象为空) 会返回失败
func (m *UserShareManager) MarkUpdateByBitSet(cls *model.UserShare, bitSet UserShareBitSet) error {
	if cls == nil {
		return persistCore.EPersistErrorNil
	}

	if m.LoadState(cls.Uid) != EUserShareLoadStateMemory {
		return persistCore.EPersistErrorNotInMemory
	}

	p := m.GetUserShareByUid(cls.Uid)
	if p == nil || p != cls {
		return persistCore.EPersistErrorOutOfDate
	}

	m.InitDS(cls)

	newCls := m.acquireDeepCopyObject(cls)

	persistSync := &UserShareSync{Data: newCls, Op: EUserShareOpUpdate, BitSet: bitSet}

	log.Println("[sql trace UserShare]", m.PersistSyncToString(persistSync))

	m.syncChan <- persistSync

	return nil
}

// MarkUpdateByFieldIndex 标记脏对象并异步写回数据库, (1 数据没有导入或已经导出, 2 数据已经重新导入, 3 对象为空) 会返回失败
func (m *UserShareManager) MarkUpdateByFieldIndex(cls *model.UserShare, fieldIndex UserShareFieldIndex) error {
	return m.MarkUpdateByBitSet(cls, *((&UserShareBitSet{}).Set(fieldIndex)))
}

// GetUserShareByUid 通过索引查找对象
func (m *UserShareManager) GetUserShareByUid(Uid int64) *model.UserShare {

	if data, ok := m.hashUid.Load(UserShareKeyTypeHashUid{Uid}); ok {
		return data
	}
	return nil
}

// GetUserShareByUserNameStatus 通过索引查找对象
func (m *UserShareManager) GetUserShareByUserNameStatus(UserName string, Status int64) *model.UserShare {

	if data, ok := m.hashUserNameStatus.Load(UserShareKeyTypeHashUserNameStatus{UserName, Status}); ok {
		return data
	}
	return nil
}

// GetUserShareByMobile 通过索引查找对象
func (m *UserShareManager) GetUserShareByMobile(Mobile string) *model.UserShare {

	if data, ok := m.hashMobile.Load(UserShareKeyTypeHashMobile{Mobile}); ok {
		return data
	}
	return nil
}

// GetAll 通过主键查找所有对象
func (m *UserShareManager) GetAll() (ret []*model.UserShare) {

	m.hashUid.Range(func(k UserShareKeyTypeHashUid, v *model.UserShare) bool {
		ret = append(ret, v)
		return true
	})
	return
}

// LoadAllState 所有数据导入状态
func (m *UserShareManager) LoadAllState() int32 {
	return atomic.LoadInt32(&m.loadAll)
}

// LoadAll (非线程安全) 导入所有数据, 全导入后只能全导出, 不能再按照key导入导出
func (m *UserShareManager) LoadAll() (err error) {
	log.Println("UserShareManager LoadAll begin")
	// 未全导入状态切换到全导入
	if atomic.CompareAndSwapInt32(&m.loadAll, EUserShareTableStateDisk, EUserShareTableStateLoading) {
		rows := make([]*model.UserShare, 0)
		err = m.engine.Find(&rows, gUserShareNil)
		if err != nil {
			atomic.StoreInt32(&m.loadAll, EUserShareTableStateDisk)
			return err
		} else {

			for _, row := range rows {
				m.addUserShare(row)
			}
			atomic.StoreInt32(&m.loadAll, EUserShareTableStateMemory)
		}
	} else {
		return persistCore.EPersistErrorIncorrectState
	}
	log.Println("UserShareManager LoadAll end")
	return
}

// LoadState 查询包含该key的数据导入状态
func (m *UserShareManager) LoadState(Uid int64) int32 {
	if atomic.LoadInt32(&m.loadAll) == EUserShareTableStateDisk {
		if value, ok := m.loadUidMap.Load(Uid); ok {
			state := value
			return atomic.LoadInt32(state)
		} else {
			return EUserShareLoadStateDisk
		}
	} else {
		return EUserShareLoadStateMemory
	}
}

// SetLoadState2Memory 没有数据时, 标记数据在内存中. 仅用于第一次数据库导入空数据, 错误使用会导致未定义的行为
func (m *UserShareManager) SetLoadState2Memory(Uid int64) {
	if atomic.LoadInt32(&m.loadAll) == EUserShareTableStateDisk {
		p := int32(EUserShareLoadStateMemory)
		m.loadUidMap.Store(Uid, &p)
	} else {
	}
}

// Load 按照key导入数据, 必须存在unload key的索引
func (m *UserShareManager) Load(Uid int64) (err error) {
	// LoadAll后不能再次Load
	if atomic.LoadInt32(&m.loadAll) == EUserShareTableStateDisk {
		p := int32(0)
		value, _ := m.loadUidMap.LoadOrStore(Uid, &p)
		state := value
		// 检查导入状态
		switch atomic.LoadInt32(state) {
		// 未导入状态切换到导入
		case EUserShareLoadStateDisk:
			if atomic.CompareAndSwapInt32(state, EUserShareLoadStateDisk, EUserShareLoadStateLoading) {
				rows := make([]*model.UserShare, 0)
				err = m.engine.Find(&rows, &model.UserShare{Uid: Uid})

				if err != nil { // 导入失败, 状态回到导出
					atomic.StoreInt32(state, EUserShareLoadStateDisk)
				} else {

					for _, row := range rows {
						m.addUserShare(row)
					}
					atomic.StoreInt32(state, EUserShareLoadStateMemory)
				}
				return
			} else { // 期间状态变化,不确定操作是否成功
				return persistCore.EPersistErrorUnknownError
			}

		case EUserShareLoadStateLoading: // 正在导入
			// 并发导入暂时轮询等待
			bTime := time.Now().Unix()
			for {
				if atomic.LoadInt32(state) != EUserShareLoadStateLoading {
					break
				}
				if time.Now().Unix() > bTime+persistCore.ELoadPollingTimeOut {
					break
				}
				time.Sleep(time.Millisecond * 100)
			}
			if atomic.LoadInt32(state) == EUserShareLoadStateMemory {
				return
			} else {
				return persistCore.EPersistErrorUnknownError
			}

		case EUserShareLoadStateMemory: // 导入完成
			return

		case EUserShareLoadStatePrepareUnloading: // 准备导出,立即取消导出
			if atomic.CompareAndSwapInt32(state, EUserShareLoadStatePrepareUnloading, EUserShareLoadStateMemory) {
				return
			} else { // 期间状态变化,不确定操作是否成功
				return persistCore.EPersistErrorUnknownError
			}

		case EUserShareLoadStateUnloading: // 正在导出
			return persistCore.EPersistErrorUnloading
		default: // ???
			return persistCore.EPersistErrorUnknownError
		}
	} else {
		return
	}
}

// UnloadAll (非线程安全) 导出所有数据, 调用UnloadAll后,不允许再修改相关的数据(必须先导入才能修改数据)
func (m *UserShareManager) UnloadAll() (err error) {
	var clsList []*model.UserShare
	// 未导入状态切换到导入
	if atomic.CompareAndSwapInt32(&m.loadAll, EUserShareTableStateMemory, EUserShareTableStateUnloading) {

		m.hashUid.Range(func(k UserShareKeyTypeHashUid, v *model.UserShare) bool {
			clsList = append(clsList, v)
			return true
		})
		for _, cls := range clsList {
			m.removeUserShare(cls)
		}
		atomic.StoreInt32(&m.loadAll, EUserShareTableStateDisk)
	} else {
		return persistCore.EPersistErrorIncorrectState
	}
	return
}

// Unload 按照key导出数据, 必须存在unload key的索引. 调用Unload后,不允许再修改相关的数据(必须先导入才能修改数据).
func (m *UserShareManager) Unload(Uid int64) (err error) {

	// LoadAll后不能unload
	if atomic.LoadInt32(&m.loadAll) == EUserShareTableStateDisk {
		if value, ok := m.loadUidMap.Load(Uid); ok {
			state := value

			switch atomic.LoadInt32(state) {
			case EUserShareLoadStateDisk: // 未导入
				return //persistCore.EPersistErrorNotInMemory
			case EUserShareLoadStateLoading: // 正在导入
				return persistCore.EPersistErrorLoading
			case EUserShareLoadStateMemory: // 导入完成, 开始导出吧
				if atomic.CompareAndSwapInt32(state, EUserShareLoadStateMemory, EUserShareLoadStatePrepareUnloading) {
					m.syncChan <- &UserShareSync{Data: &model.UserShare{Uid: Uid}, Op: EUserShareOpUnload}
					return
				} else { // 期间状态变化,不确定操作是否成功
					return persistCore.EPersistErrorUnknownError
				}
			case EUserShareLoadStatePrepareUnloading: // 准备导出, 立即取消导出
				return //persistCore.EPersistErrorAlreadyUnload
			case EUserShareLoadStateUnloading: // 正在导出, 导入失败
				return //persistCore.EPersistErrorUnloading
			default:
				return persistCore.EPersistErrorUnknownError
			}
		} else {
			return //persistCore.EPersistErrorNotInMemory
		}
	} else {
		return persistCore.EPersistErrorAlreadyLoadAll
	}

}

// unload (非线程安全) 按照key导出数据, 必须存在unload key的索引. 调用Unload后,不允许再修改相关的数据(必须先导入才能修改数据).
func (m *UserShareManager) unload(Uid int64) {

	cls := m.GetUserShareByUid(Uid)
	if cls != nil {
		m.removeUserShare(cls)
	}

}

var GUserShareManager *UserShareManager

// init 注册管理类
func init() {

	engine := GetDB()
	if engine == nil {
		// log.Println(persistCore.EPersistErrorEngineNil)
		persistCore.RegisterPersistLazy("UserShare", GUserShareManager)
		return
	}

	GUserShareManager = NewUserShareManager(engine)
	Register("UserShare", GUserShareManager)
	// go GUserShareManager.Collect()

	//for idx, name := range UserShareStructFiledMap {
	//	UserShareDBFiledMap[idx] = engine.GetColumnMapper().Obj2Table(name)
	//}

}

// LazyInit 惰性创建注册初始化
func (m *UserShareManager) LazyInit() (err error) {

	if GetDB == nil {
		err = errors.New("GetDB is nil")
		return
	}
	engine := GetDB()
	if engine == nil {
		err = errors.New("engine is nil")
		return
	}
	GUserShareManager = NewUserShareManager(engine)
	Register("UserShare", GUserShareManager)

	return
}

// noneFunc 惰性创建注册初始化
func (m *UserShareManager) noneFunc() {
	math.Abs(1.0)
	_ = jsoniter.ConfigCompatibleWithStandardLibrary
	_ = json.Marshal
	_ = sync.Mutex{}
	_ = reflect.Value{}
	_ = time.Now()
	_ = sentry.Client{}
	_ = strings.Builder{}
	log.Println("none")
}

// SaveDB xorm写数据库
func (m *UserShareManager) SaveDB(session *xorm.Session, persistSync *UserShareSync) (err error) {
	defer func() {
		if r := recover(); r != nil {
			log.Println("recovered in ", r)
			log.Println("stack: ", string(debug.Stack()))
			if err == nil {
				err = errors.New("unknown error")
			}
		}
	}()
	switch persistSync.Op {
	case EUserShareOpInsert:

		_, err = session.Insert(persistSync.Data)

		if err != nil {
			log.Println("insert error ", err, "[sql error UserShare]", m.PersistSyncToString(persistSync))
			return
		}

	case EUserShareOpUpdate:
		cls := persistSync.Data
		bitSet := persistSync.BitSet
		if bitSet.IsSetAll() {
			_, err = session.ID(core.NewPK(cls.Uid)).AllCols().Update(cls)
			if err != nil {
				log.Println("update error ", err, "[sql error UserShare]", m.PersistSyncToString(persistSync))
				return
			}
		} else {
			var nameList []string
			for idx, name := range UserShareDBFiledMap {
				if bitSet.Get(UserShareFieldIndex(idx)) {
					nameList = append(nameList, name)
				}
			}
			if nameList != nil {
				_, err = session.ID(core.NewPK(cls.Uid)).Cols(nameList...).Update(cls)
				if err != nil {
					log.Println("update error ", err, "[sql error UserShare]", m.PersistSyncToString(persistSync))
					return
				}
			} else {
				_, err = session.ID(core.NewPK(cls.Uid)).AllCols().Update(cls)
				if err != nil {
					log.Println("update error ", err, "[sql error UserShare]", m.PersistSyncToString(persistSync))
					return
				}
			}
		}

	case EUserShareOpDelete:
		cls := persistSync.Data
		_, err = session.ID(core.NewPK(cls.Uid)).Delete(gUserShareNil)
		if err != nil {
			log.Println("delete error ", err, "[sql error UserShare]", m.PersistSyncToString(persistSync))
			return
		}

	case EUserShareOpUnload:
		cls := persistSync.Data
		Uid := cls.Uid
		if value, ok := m.loadUidMap.Load(Uid); ok {
			state := value
			// 准备导出,  不中断的清理玩家数据
			// warning 导出后又修改, 不保证数据一致性
			if atomic.CompareAndSwapInt32(state, EUserShareLoadStatePrepareUnloading, EUserShareLoadStateUnloading) {
				m.unload(Uid)
				m.loadUidMap.Delete(Uid)
				atomic.StoreInt32(state, EUserShareLoadStateDisk)
			} else {
				// 0:导出  1:导入开始  2:导入完成  4:正在导出  不确定状态
				// 以上状态跳过吧
			}
		} else {
			// 不存在的玩家,跳过吧
		}

	}
	return
}

// DataToFailQueue 未写入成功数据, 添加到失败队列
func (m *UserShareManager) DataToFailQueue() {
	var persistSync *UserShareSync

	// 一旦失败标记所有的数据都是失败, 不允许导出

	m.FailQueue = append(m.FailQueue, m.InsertQueue...)
	m.InsertQueue = m.InsertQueue[0:0]

	for i := 0; i < len(*m.syncQueue); i++ {
		persistSync = (*m.syncQueue)[i]
		switch persistSync.Op {
		case EUserShareOpInsert, EUserShareOpUpdate, EUserShareOpDelete:
			m.FailQueue = append(m.FailQueue, persistSync)

		case EUserShareOpUnload:
			// 导出状态还原
			cls := persistSync.Data
			Uid := cls.Uid
			if value, ok := m.loadUidMap.Load(Uid); ok {
				state := value
				// 导出失败状态回退
				if atomic.CompareAndSwapInt32(state, EUserShareLoadStatePrepareUnloading, EUserShareLoadStateMemory) {
				} else {
				}
			}

		default:
		}
	}
	*m.syncQueue = (*m.syncQueue)[0:0]
}

// LoadFile 文件读取写回失败数据
func (m *UserShareManager) LoadFile() error {
	bombExist := utils.Exists("_./_Users_xt_go_pumppill_data/UserShare.bomb")
	tmpExist := utils.Exists("_./_Users_xt_go_pumppill_data/UserShare.tmp")

	if tmpExist {
		return persistCore.EPersistErrorTempFileExist
	}

	if bombExist {
		data, err := ioutil.ReadFile("_./_Users_xt_go_pumppill_data/UserShare.bomb")
		if err != nil {
			return err
		}
		pos := bytes.IndexByte(data, byte(' '))
		if pos == -1 {
			return persistCore.EPersistErrorInvalidBombFile
		}
		persistData := data[pos+1:]
		err = m.UnmarshalFailQueue(persistData, &m.FailQueue)
		if err != nil {
			return err
		}

		session := m.engine.NewSession()
		defer session.Close()

		var persistSync *UserShareSync

		for i := range m.FailQueue {
			persistSync = m.FailQueue[i]
			err = m.SaveDB(session, persistSync)
			if err != nil {
				m.FailQueue = m.FailQueue[i:]
				m.SaveFile()
				return err
			}
		}
		m.FailQueue = m.FailQueue[0:0]
		m.RemoveFile()

	}
	return nil
}

// SaveFile 写回失败,记录数据,写文件,等待下次写回
func (m *UserShareManager) SaveFile() {

	m.DataToFailQueue()

	data, err := m.MarshalFailQueue(m.FailQueue)
	if err != nil {
		log.Println("SaveFile marshal error ", err)
	}
	_ = os.Mkdir("_./_Users_xt_go_pumppill_data", 0770)
	err = ioutil.WriteFile("_./_Users_xt_go_pumppill_data/UserShare.tmp", append([]byte("UserShare "), data...), 0660)
	if err != nil {
		log.Println("SaveFile write temp file error ", err)
	}
	err = ioutil.WriteFile("_./_Users_xt_go_pumppill_data/UserShare.bomb", append([]byte("UserShare "), data...), 0660)
	if err != nil {
		log.Println("SaveFile write bomb file error ", err)
	}
	_ = os.Remove("_./_Users_xt_go_pumppill_data/UserShare.tmp")
}

// RemoveFile 删除写回失败文件
func (m *UserShareManager) RemoveFile() {
	_ = os.Remove("_./_Users_xt_go_pumppill_data/UserShare.tmp")
	_ = os.Remove("_./_Users_xt_go_pumppill_data/UserShare.bomb")
	_ = os.Remove("_./_Users_xt_go_pumppill_data")
}

// RecoverBomb bomb数据写入数据库
func (m *UserShareManager) RecoverBomb(bomb []byte) (err error) {
	var persistSync *UserShareSync
	var failQueue []*UserShareSync
	session := m.engine.NewSession()
	defer session.Close()
	err = m.UnmarshalFailQueue(bomb, &failQueue)
	if err != nil {
		return
	}
	var i int
	for i = range failQueue {
		persistSync = failQueue[i]
		err = m.SaveDB(session, persistSync)
		if err != nil {
			break
		}
	}
	if len(failQueue)-1 > i {
		data, _ := m.MarshalFailQueue(failQueue[i:])
		_, _ = os.Stdout.Write([]byte("UserShare "))
		_, _ = os.Stdout.Write(data)
	}
	return
}

// RecoverTrace trace数据写入数据库
func (m *UserShareManager) RecoverTrace(trace [][]byte) (err error) {
	var persistSync *UserShareSync
	var traceQueue []*UserShareSync
	var insertQueue []*UserShareSync

	for i := 0; i < len(trace); i++ {
		persistSync = m.StringToPersistSync(string(trace[i]))
		if persistSync.Op == EUserShareOpInsert {
			insertQueue = append(insertQueue, persistSync)
		} else {
			traceQueue = append(traceQueue, persistSync)
		}
	}

	insertQueue2, otherQueue := m.MergeQueue(traceQueue, false)
	for _, insertItem := range insertQueue2 {
		insertQueue = append(insertQueue, insertItem)
	}

	session := m.engine.NewSession()
	defer session.Close()

	var i int
	for i = range insertQueue {
		persistSync = insertQueue[i]
		_ = m.SaveDB(session, persistSync)
	}
	for i = range otherQueue {
		persistSync = otherQueue[i]
		_ = m.SaveDB(session, persistSync)
	}
	return
}

// MergeQueue 内存中合并操作
func (m *UserShareManager) MergeQueue(q []*UserShareSync, copyAll bool) (insertQueue, otherQueue []*UserShareSync) {

	var currentPersistSync *UserShareSync
	var oldPersistSync *UserShareSync
	var ok bool

	var unloadList []*UserShareSync

	// 合并可能失败, persistSyncMap必须创建副本
	persistSyncMap := map[UserShareUid]*UserShareSync{}

	//unload 按照顺序强制移到最后
	//insert update delete 按照主键合并
	lenSyncQueue := len(q)
	fail := false

LabelForSyncQueue:
	for i := 0; i < lenSyncQueue; i++ {
		currentPersistSync = q[i]
		pk := UserShareUid{

			Uid: currentPersistSync.Data.Uid,
		}
		// 导出特殊处理
		if currentPersistSync.Op == EUserShareOpUnload {
			unloadList = append(unloadList, currentPersistSync)
			continue
		}
		// 第一次出现直接拷贝
		if oldPersistSync, ok = persistSyncMap[pk]; !ok {
			persistSyncMap[pk] = &UserShareSync{Data: currentPersistSync.Data, Op: currentPersistSync.Op, BitSet: currentPersistSync.BitSet}
			continue
		}

		switch oldPersistSync.Op {
		case EUserShareOpInsert:
			switch currentPersistSync.Op {
			case EUserShareOpInsert:
				fail = true
				break LabelForSyncQueue
			case EUserShareOpUpdate:
				oldPersistSync.Op = EUserShareOpInsert
				if copyAll {
					oldPersistSync.Data = currentPersistSync.Data
				} else {
					m.PersistToPersistByBitSet(oldPersistSync.Data, currentPersistSync.Data, currentPersistSync.BitSet)
				}
				oldPersistSync.BitSet.SetAll()
			case EUserShareOpDelete:
				delete(persistSyncMap, pk)
			}
		case EUserShareOpUpdate:
			switch currentPersistSync.Op {
			case EUserShareOpInsert:
				fail = true
				break LabelForSyncQueue
			case EUserShareOpUpdate:
				oldPersistSync.Op = EUserShareOpUpdate
				if copyAll {
					oldPersistSync.Data = currentPersistSync.Data
				} else {
					m.PersistToPersistByBitSet(oldPersistSync.Data, currentPersistSync.Data, currentPersistSync.BitSet)
				}
				oldPersistSync.BitSet.Merge(currentPersistSync.BitSet)
			case EUserShareOpDelete:
				oldPersistSync.Op = EUserShareOpDelete
				oldPersistSync.Data = currentPersistSync.Data
				oldPersistSync.BitSet.ClearAll()
			}
		case EUserShareOpDelete:
			switch currentPersistSync.Op {
			case EUserShareOpInsert:
				oldPersistSync.Op = EUserShareOpUpdate
				oldPersistSync.Data = currentPersistSync.Data
				oldPersistSync.BitSet.SetAll()
			case EUserShareOpUpdate:
				fail = true
				break LabelForSyncQueue
			case EUserShareOpDelete:
				fail = true
				break LabelForSyncQueue
			}
		}
	}
	// 遇到错误取消合并
	if fail {
		otherQueue = q
		return
	}

	// 清空队列 该函数无副作用，需要外部自行清理

	// 按照合并内容重建队列, 插入特殊处理
	for _, persistSync := range persistSyncMap {
		if persistSync.Op == EUserShareOpInsert {
			insertQueue = append(insertQueue, persistSync)
		} else {
			otherQueue = append(otherQueue, persistSync)
		}
	}

	for _, persistSync := range unloadList {
		otherQueue = append(otherQueue, persistSync)
	}

	return
}

// Save 异步写回
func (m *UserShareManager) Save() {
	var exit bool
	for {
		// 正常退出
		exit = m.AsyncSave()
		if exit {
			break
		}
	}
}

// AsyncSave 异步写回
func (m *UserShareManager) AsyncSave() (exit bool) {
	var persistSync *UserShareSync
	var err error
	var queueEmpty bool
	bTime := time.Now().UnixNano()
	defer func() {
		if r := recover(); r != nil {
			log.Println("recovered in ", r)
			log.Println("stack: ", string(debug.Stack()))
			if !queueEmpty {
				log.Println("save failed: incrementalSave")
			}
		} else {
			if !queueEmpty {
				if err == nil {
					log.Println("save success: incrementalSave")
				} else {
					log.Println("save failed: incrementalSave")
				}
			}
		}
		m.DataToFailQueue()
		m.lastWriteBackTime = time.Duration(time.Now().UnixNano() - bTime)
		m.syncEnd <- true
	}()

	needCollect := <-m.syncBegin
	if len(*m.syncQueue) == 0 {
		queueEmpty = true
		if needCollect {
			time.Sleep(time.Millisecond * 100)
		} else {
			exit = true
		}
		return
	}
	session := m.engine.NewSession()
	defer session.Close()

	log.Println("begin incrementalSave", bTime)

	if len(m.FailQueue) > 0 {
		tmpQueue := make([]*UserShareSync, len(m.FailQueue)+len(*m.syncQueue))
		copy(tmpQueue, m.FailQueue)
		copy(tmpQueue[len(m.FailQueue):], *m.syncQueue)
		insertQueue, otherQueue := m.MergeQueue(tmpQueue, true)
		m.syncQueue = &otherQueue
		m.InsertQueue = insertQueue
		m.FailQueue = m.FailQueue[0:0]
	} else {
		insertQueue, otherQueue := m.MergeQueue(*m.syncQueue, true)
		m.syncQueue = &otherQueue
		m.InsertQueue = insertQueue
	}

	multiInsertFn := func() bool {
		var err error
		defer func() {
			if r := recover(); r != nil {
				_ = session.Rollback()
			} else {
				if err == nil {
					m.InsertQueue = m.InsertQueue[0:0]
				} else {
					_ = session.Rollback()
				}
			}
		}()

		if len(m.InsertQueue) <= 0 {
			return true
		}
		err = session.Begin()
		if err != nil {
			return false
		}

		const num = 100
		var insertArray [num]*model.UserShare
		length := len(m.InsertQueue)
		quotient := length / num
		remainder := length % num
		for i := 0; i < quotient; i++ {
			//fmt.Println("queue->(", i*num, "-", (i+1)*num, "): ", m.InsertQueue[i*num:(i+1)*num])
			for j := 0; j < num; j++ {
				insertArray[j] = m.InsertQueue[i*num+j].Data
			}

			_, err = session.InsertMulti(insertArray[:])

			if err != nil {
				log.Println("InsertMulti error ", err)
				return false
			}
		}
		if remainder != 0 {
			//fmt.Println("queue->(", quotient*num, "-", length, "): ", m.InsertQueue[quotient*num:length])

			insertArray = [num]*model.UserShare{}
			for j := 0; j < remainder; j++ {
				insertArray[j] = m.InsertQueue[quotient*num+j].Data
			}

			_, err = session.InsertMulti(insertArray[:remainder])

			if err != nil {
				log.Println("InsertMulti error ", err)
				return false
			}
		}
		err = session.Commit()
		if err != nil {
			return false
		}
		return true
	}

	multiInsertSuccess := multiInsertFn()

	// 批量插入失败, 改为单条插入
	if !multiInsertSuccess {
		for idx, persistSync := range m.InsertQueue {
			err = m.SaveDB(session, persistSync)
			if err != nil {
				m.InsertQueue = m.InsertQueue[idx:]
				m.SaveFile()
				return
			}
		}
		m.InsertQueue = m.InsertQueue[0:0]
	}

	for i := 0; i < len(*m.syncQueue); i++ {
		persistSync = (*m.syncQueue)[i]
		err = m.SaveDB(session, persistSync)
		if err != nil {
			*m.syncQueue = (*m.syncQueue)[i:]
			m.SaveFile()
			return
		}
	}
	*m.syncQueue = (*m.syncQueue)[0:0]
	m.RemoveFile()
	return
}

// Collect 收集数据
func (m *UserShareManager) Collect() {
	var persistSync *UserShareSync
	var ok bool
	// 0:normal  1:exit begin, save sync  2:save cache  3:save done
	var state int8
	go m.Save()
	m.syncBegin <- true
	for {
		select {
		case persistSync, ok = <-m.syncChan:
			if ok {
				*m.cacheQueue = append(*m.cacheQueue, persistSync)
			}
		case _, ok = <-m.syncEnd:
			if ok {
				m.CheckOverload()
				m.cacheQueue, m.syncQueue = m.syncQueue, m.cacheQueue
				switch state {
				case EUserShareCollectStateNormal:
					//go m.AsyncSave()
					m.syncBegin <- true
				case EUserShareCollectStateSaveSync:
					//go m.AsyncSave()
					m.syncBegin <- true
					state = EUserShareCollectStateSaveCache
				case EUserShareCollectStateSaveCache:
					//go m.AsyncSave()
					m.syncBegin <- true
					state = EUserShareCollectStateSaveDone
				case EUserShareCollectStateSaveDone:
					m.syncBegin <- false
					<-m.syncEnd
					m.exitEnd <- true
					return
				}
			}
		case _, ok = <-m.exitBegin:
			if ok {
				state = EUserShareCollectStateSaveSync
			}
			//default:
			//	time.Sleep(time.Second/10)
		}
	}
}

// Exit 管理类退出
func (m *UserShareManager) Exit(wg *sync.WaitGroup) {
	defer wg.Done()

	if atomic.LoadInt32(&m.managerState) != EUserShareManagerStateNormal {
		return
	}

	m.exitBegin <- true
	<-m.exitEnd
	atomic.StoreInt32(&m.managerState, EUserShareManagerStateIdle)
	return
}

// Sync 数据库表结构同步
func (m *UserShareManager) Sync(wg *sync.WaitGroup) (err error) {
	defer wg.Done()

	err = m.engine.Sync2(gUserShareNil)

	return
}

// Segmentation 检查是否需要换表 如果需要换表 则根据时间 和切换间隔计算是否需要换表 否则为不处理
func (m *UserShareManager) Segmentation(wg *sync.WaitGroup) (err error) {
	defer wg.Done()
	return
}

// compareAndUpdate 比较数据库，不相同则更新
func (m *UserShareManager) compareAndUpdate(session *xorm.Session, cls *model.UserShare, sentryDebug bool) (err error) {
	update := func(session *xorm.Session, cls *model.UserShare, memData, dbData string) {
		log.Println("SyncData error. missing mark Mem. [sql error UserShare]", memData)
		log.Println("SyncData error. missing mark  Db. [sql error UserShare]", dbData)
		_, err = session.ID(core.NewPK(cls.Uid)).AllCols().Update(cls)
		if err != nil {
			log.Println("SyncData update error.", err, "[sql error UserShare]", m.PersistSyncToString(&UserShareSync{
				Data:   cls,
				Op:     EUserShareOpUpdate,
				BitSet: m.bitSetAll,
			}))
			return
		}
	}
	resetTimeNSec := func(clsMem, clsDb *model.UserShare) {
		defer func() {
			if r := recover(); r != nil {
				log.Println("recovered in ", r)
				log.Println("stack: ", string(debug.Stack()))
			}
		}()
		typeF := reflect.TypeOf(*clsMem)
		valueMemF := reflect.ValueOf(clsMem).Elem()
		valueDbF := reflect.ValueOf(clsDb).Elem()
		for i := 0; i < typeF.NumField(); i++ {
			if typeF.Field(i).Type.Name() == "Time" {
				f := valueMemF.Field(i)
				if f.CanInterface() {
					v := time.Unix(f.Interface().(time.Time).Unix(), 0)
					f.Set(reflect.ValueOf(v))
				}
				vMem := valueMemF.Field(i).Interface().(time.Time)
				vDb := valueDbF.Field(i).Interface().(time.Time)
				if vMem.Equal(vDb) {
					f.Set(reflect.ValueOf(vDb))
				}
			}
		}
	}

	dbCls := &model.UserShare{

		Uid: cls.Uid,
	}
	var has bool
	has, err = session.Get(dbCls)
	if err != nil || !has {
		log.Println("SyncData query error.", err, "[sql error UserShare]", m.PersistSyncToString(&UserShareSync{
			Data:   cls,
			Op:     0,
			BitSet: m.bitSetAll,
		}))
		return
	}
	memCls := m.GetUserShareByUid(cls.Uid)
	if memCls != nil {
		resetTimeNSec(memCls, dbCls)
		memData := m.PersistSyncToString(&UserShareSync{
			Data:   memCls,
			Op:     0,
			BitSet: m.bitSetAll,
		})
		dbData := m.PersistSyncToString(&UserShareSync{
			Data:   dbCls,
			Op:     0,
			BitSet: m.bitSetAll,
		})
		// 数据库内存不一致
		if strings.Compare(memData, dbData) != 0 {
			if sentryDebug {
				func() {
					defer func() {
						memClsJson, _ := json.Marshal(&UserShareSync{
							Data:   memCls,
							Op:     0,
							BitSet: m.bitSetAll,
						})
						dbClsJson, _ := json.Marshal(&UserShareSync{
							Data:   dbCls,
							Op:     0,
							BitSet: m.bitSetAll,
						})
						sentry.WithScope(func(scope *sentry.Scope) {
							tag := "CompareError" + "UserShare"
							scope.SetTag(tag, "UserShare")
							scope.SetTag("transaction", "UserShare")
							scope.SetExtra("memClsJson", string(memClsJson))
							scope.SetExtra("dbClsJson", string(dbClsJson))
							sentry.CaptureMessage(tag)
						})
					}()
				}()
			}
			update(session, memCls, memData, dbData)
		}
	}
	return
}

// SyncData 全部内存数据写入数据库, 本接口耗时长,仅用于停服后.  补救没有标记写回数据(只处理未标记数据,New Delete不存在漏写)
func (m *UserShareManager) SyncData(wg *sync.WaitGroup, sentryDebug bool) (err error) {
	defer wg.Done()

	session := m.engine.NewSession()
	defer session.Close()

	if sentryDebug {
		func() {
			defer func() {
				for _, cls := range m.GetAll() {
					updateErr := m.compareAndUpdate(session, cls, sentryDebug)
					if updateErr != nil {
						err = updateErr
					}
				}
				if err != nil {
					sentry.WithScope(func(scope *sentry.Scope) {
						tagtag := "SyncDataError" + "UserShare"
						scope.SetTag("SyncDataError", "UserShare")
						scope.SetTag("transaction", "UserShare")
						scope.SetExtra(err.Error(), 1)
						sentry.CaptureMessage(tagtag)
					})
				}
			}()
		}()
	} else {
		for _, cls := range m.GetAll() {
			updateErr := m.compareAndUpdate(session, cls, sentryDebug)
			if updateErr != nil {
				err = updateErr
			}
		}
	}
	return

}

// SyncUserData 用户内存和数据库数据比较并更新, 不允许并发， 用于数据导出时，补救没有标记写回数据(只处理未标记数据,New Delete不存在漏写)
// sentryDebug debug模式下启用sentry
func (m *UserShareManager) SyncUserData(Uid int64, sentryDebug bool) (err error) {
	session := m.engine.NewSession()
	defer session.Close()
	var clsList []*model.UserShare

	// 业务代码必须保证，不使用正在导出的数据， 否则可能引发崩溃
	func() {
		defer func() {
			if r := recover(); r != nil {
				log.Println("recovered in ", r)
				log.Println("stack: ", string(debug.Stack()))
				err = errors.New("SyncUserData error")
			}
		}()

		cls := m.GetUserShareByUid(Uid)
		if cls != nil {
			clsList = append(clsList, m.acquireDeepCopyObject(cls))
		}

	}()

	if err != nil {
		return
	}

	for _, cls := range clsList {
		err = m.compareAndUpdate(session, cls, sentryDebug)
		if sentryDebug {
			func() {
				defer func() {
					if err != nil {
						sentry.WithScope(func(scope *sentry.Scope) {
							tagtag := "SyncDataError" + "UserShare"
							scope.SetTag("SyncDataError", "UserShare")
							scope.SetTag("transaction", "UserShare")
							scope.SetExtra(err.Error(), 1)
							sentry.CaptureMessage(tagtag)
						})
					}
				}()
			}()
		}
		if err != nil {
			return
		}
	}

	return

}

// object pool
