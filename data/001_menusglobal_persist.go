// Code generated by persist. DO NOT EDIT.
// source: menus.go

package data

import (
	"encoding/base64"
	"encoding/binary"
	"encoding/json"
	"log"
	"math"
	"runtime/debug"

	"github.com/getsentry/sentry-go"
	jsoniter "github.com/json-iterator/go"
	"xorm.io/xorm"

	"reflect"
	"strings"
	"sync"
	"time"

	"bytes"
	"errors"

	"xorm.io/core"

	"io/ioutil"
	"os"
	"runtime"
	"sync/atomic"

	"github.com/spelens-gud/persist/utils"

	persistCore	"github.com/spelens-gud/persist/core"

	"github.com/spelens-gud/persist/model"
)

// 警告:
// 内部接口禁止调用(仅供内部 和 测试代码使用)
// SaveDB, DataToFailQueue, LoadFile, SaveFile, RemoveFile
// RecoverBomb, MergeQueue, AsyncSave, Collect, CheckOverload

// 工具接口, 无副作用, 按需使用
// BytesToPersist, PersistToBytes, PersistToPersistByBitSet, BytesToPersistSync, PersistSyncToBytes,
// StringToPersistSync, PersistSyncToString, UnmarshalFailQueue, MarshalFailQueue

// 需要先导入数据再使用
// 除以下接口不需要先导入, 其他接口必须 先导入! 先导入! 先导入!
// Run, Dead, Load LoadAll, Exit, Sync, SyncData(补救没有标记写回数据, 代码正确不需要使用)

// 其他接口
// New Delete 接口按需使用
// 尽量使用MarkUpdateByBitSet 多个修改一起提交
// 只修改单条数据使用MarkUpdateByFieldIndex
// 少用或者不用MarkUpdate 全标记开销太大, 除非业务太复杂想不清楚

// 支持 hash index:[group,unique], 不支持 tree index
// op 1:insert 2:update 3:delete 4:unload

// 对象序列化接口 string, slice, array, map json序列化,
// 第一版二进制结构：
// 		指针结构：含1字节标识位(0000 0001 是否nil) + 其他
// 		string, slice, map, 复杂结构， 结构体等： 4字节长度 + ToDB|json.Marshal长度
// 		其他简单基础结构：按照最大字节存储
// 		core.Conversion 只会检查指针 例如:
// 			(m *Persist) FromDB(data []byte) error
// 			(m *Persist) ToDB(data []byte, err error)
// 自定义解析字段， 暂时不允许是其他包的结构，分析引入关系比较复杂

// 待优化功能:
// 1: LoadMany方法, 一次导入多个玩家数据
// 2: 优化对象序列化大小，添加tag 一定程度兼容新旧结构, 支持更多的类型优化

const (
	EMenusGlobalManagerStateIdle   = 0 // 初始化
	EMenusGlobalManagerStateNormal = 1 // 正常运行
	EMenusGlobalManagerStatePanic  = 2 // 非法停止

	EMenusGlobalTableStateDisk      = 0 // 导出
	EMenusGlobalTableStateLoading   = 1 // 全导入开始
	EMenusGlobalTableStateMemory    = 2 // 全导入完成
	EMenusGlobalTableStateUnloading = 3 // 正在全导出

	EMenusGlobalLoadStateDisk             = 0 // 不存在 or 导出
	EMenusGlobalLoadStateLoading          = 1 // 导入开始
	EMenusGlobalLoadStateMemory           = 2 // 导入完成
	EMenusGlobalLoadStatePrepareUnloading = 3 // 准备导出
	EMenusGlobalLoadStateUnloading        = 4 // 正在导出

	EMenusGlobalOpInsert = 1 // 新建
	EMenusGlobalOpUpdate = 2 // 修改
	EMenusGlobalOpDelete = 3 // 删除
	EMenusGlobalOpUnload = 4 // 导出

	EMenusGlobalCollectStateNormal    = 0 // 正常
	EMenusGlobalCollectStateSaveSync  = 1 // 开始退出, 清理同步队列
	EMenusGlobalCollectStateSaveCache = 2 // 开始退出,清理缓存队列
	EMenusGlobalCollectStateSaveDone  = 3 // 写回完成

)

type MenusGlobal = model.MenusGlobal

// MenusGlobalDeepCopy persist对象必须支持并发访问, 不实现该接口默认深拷贝对象 (1 建议实现该接口,反射效率较低  2 map 建议生成syncmap  3 slice 建议深拷贝)
type MenusGlobalDeepCopy interface {
	CopyTo(t *model.MenusGlobal)
}

// MenusGlobalOverload 未落地数据超过阈值时调用
type MenusGlobalOverload interface {
	Overload(queueSize int, lastWriteBackTime time.Duration)
}

type MenusGlobalAuthId struct {
	AuthId int64
}

type MenusGlobalAuthIdType struct {
	AuthId int64
	Type   string
}

type MenusGlobalKeyTypeHashAuthId = MenusGlobalAuthId

type MenusGlobalKeyTypeHashAuthIdType = MenusGlobalAuthIdType

// MenusGlobalManager 索引类型定义

// only define type MenusGlobalHashAuthIdMark map[MenusGlobalKeyTypeHashAuthId]bool

// only define type MenusGlobalHashAuthId map[MenusGlobalKeyTypeHashAuthId]*model.MenusGlobal

// only define type MenusGlobalHashAuthIdType map[MenusGlobalKeyTypeHashAuthIdType]map[*model.MenusGlobal]bool

// MenusGlobalFieldIndex 所有列index枚举
// MenusGlobalBitSet begin
// 读ast计算FieldLength 生成所有字段常量 0~length
type MenusGlobalFieldIndex = uint

const EMenusGlobalFieldIndexZero MenusGlobalFieldIndex = 0

const EMenusGlobalFieldIndexAuthId MenusGlobalFieldIndex = 0

const EMenusGlobalFieldIndexParentId MenusGlobalFieldIndex = 1

const EMenusGlobalFieldIndexTreePath MenusGlobalFieldIndex = 2

const EMenusGlobalFieldIndexName MenusGlobalFieldIndex = 3

const EMenusGlobalFieldIndexType MenusGlobalFieldIndex = 4

const EMenusGlobalFieldIndexRouteName MenusGlobalFieldIndex = 5

const EMenusGlobalFieldIndexPath MenusGlobalFieldIndex = 6

const EMenusGlobalFieldIndexComponent MenusGlobalFieldIndex = 7

const EMenusGlobalFieldIndexPerm MenusGlobalFieldIndex = 8

const EMenusGlobalFieldIndexStatus MenusGlobalFieldIndex = 9

const EMenusGlobalFieldIndexAffixTab MenusGlobalFieldIndex = 10

const EMenusGlobalFieldIndexHideChildrenInMenu MenusGlobalFieldIndex = 11

const EMenusGlobalFieldIndexHideInBreadcrumb MenusGlobalFieldIndex = 12

const EMenusGlobalFieldIndexHideInMenu MenusGlobalFieldIndex = 13

const EMenusGlobalFieldIndexHideInTab MenusGlobalFieldIndex = 14

const EMenusGlobalFieldIndexKeepAlive MenusGlobalFieldIndex = 15

const EMenusGlobalFieldIndexSort MenusGlobalFieldIndex = 16

const EMenusGlobalFieldIndexIcon MenusGlobalFieldIndex = 17

const EMenusGlobalFieldIndexRedirect MenusGlobalFieldIndex = 18

const EMenusGlobalFiledIndexLength MenusGlobalFieldIndex = 19

var MenusGlobalStructFiledMap = [EMenusGlobalFiledIndexLength]string{
	"AuthId",
	"ParentId",
	"TreePath",
	"Name",
	"Type",
	"RouteName",
	"Path",
	"Component",
	"Perm",
	"Status",
	"AffixTab",
	"HideChildrenInMenu",
	"HideInBreadcrumb",
	"HideInMenu",
	"HideInTab",
	"KeepAlive",
	"Sort",
	"Icon",
	"Redirect",
}

var MenusGlobalDBFiledMap [EMenusGlobalFiledIndexLength]string

// EMenusGlobalWordSize the EMenusGlobalWordSize of a bit set
const EMenusGlobalWordSize = MenusGlobalFieldIndex(64)

// EMenusGlobalLog2WordSize is lg(EMenusGlobalWordSize)
const EMenusGlobalLog2WordSize = MenusGlobalFieldIndex(6)

// EMenusGlobalAllBits has every bit set
const EMenusGlobalAllBits uint64 = 0xffffffffffffffff

type MenusGlobalBitSet struct {
	set [(EMenusGlobalFiledIndexLength >> EMenusGlobalLog2WordSize) + 1]uint64
}

// Get whether bit i is set.
func (b *MenusGlobalBitSet) Get(i MenusGlobalFieldIndex) bool {
	if i >= EMenusGlobalFiledIndexLength {
		return false
	}
	return b.set[i>>EMenusGlobalLog2WordSize]&(1<<(i&(EMenusGlobalWordSize-1))) != 0
}

// Set bit i to 1
func (b *MenusGlobalBitSet) Set(i MenusGlobalFieldIndex) *MenusGlobalBitSet {
	if i >= EMenusGlobalFiledIndexLength {
		return nil
	}
	b.set[i>>EMenusGlobalLog2WordSize] |= 1 << (i & (EMenusGlobalWordSize - 1))
	return b
}

func (b *MenusGlobalBitSet) Clear(i MenusGlobalFieldIndex) *MenusGlobalBitSet {
	if i >= EMenusGlobalFiledIndexLength {
		return b
	}
	b.set[i>>EMenusGlobalLog2WordSize] &^= 1 << (i & (EMenusGlobalWordSize - 1))
	return b
}

// Merge compare to b
func (b *MenusGlobalBitSet) Merge(compare MenusGlobalBitSet) *MenusGlobalBitSet {
	for i, word := range b.set {
		b.set[i] = word | compare.set[i]
	}
	return b
}

func (b *MenusGlobalBitSet) ClearAll() *MenusGlobalBitSet {
	if b != nil {
		for i := range b.set {
			b.set[i] = 0
		}
	}
	return b
}

func (b *MenusGlobalBitSet) SetAll() *MenusGlobalBitSet {
	if b != nil {
		for i := range b.set {
			b.set[i] = EMenusGlobalAllBits
		}
	}
	return b
}

func (b *MenusGlobalBitSet) IsSetAll() bool {
	if b != nil {
		for i := range b.set {
			if b.set[i] != EMenusGlobalAllBits {
				return false
			}
		}
	}
	return true
}

// MenusGlobalBitSet end

// MenusGlobalSync 结构定义

type MenusGlobalSync struct {
	Data   *model.MenusGlobal
	Op     int8
	BitSet MenusGlobalBitSet
}

// MenusGlobalManager 结构定义

type MenusGlobalManager struct {

	// 0:初始化  1:正常运行  2:非法停止
	managerState int32
	// 0:导出  1:全导入开始  2:全导入完成  3:正在全导出
	loadAll int32

	pool              *sync.Pool
	syncChan          chan *MenusGlobalSync
	syncQueue         *[]*MenusGlobalSync
	cacheQueue        *[]*MenusGlobalSync
	FailQueue         []*MenusGlobalSync
	lastWriteBackTime time.Duration

	InsertQueue []*MenusGlobalSync

	syncBegin chan bool
	syncEnd   chan bool
	exitBegin chan bool
	exitEnd   chan bool

	engine *xorm.Engine

	hashAuthId MenusGlobalHashAuthId

	hashAuthIdType MenusGlobalHashAuthIdType

	// hashAuthIdMark MenusGlobalHashAuthIdMark

	bitSetAll MenusGlobalBitSet
}

var gMenusGlobalNil = &model.MenusGlobal{}

func NewMenusGlobalManager(engine *xorm.Engine) (m *MenusGlobalManager) {
	m = &MenusGlobalManager{engine: engine}

	m.syncChan = make(chan *MenusGlobalSync, runtime.NumCPU()*2)
	tmpSyncQueue := make([]*MenusGlobalSync, 0)
	m.syncQueue = &tmpSyncQueue
	m.syncEnd = make(chan bool)
	m.syncBegin = make(chan bool)
	m.exitBegin = make(chan bool)
	m.exitEnd = make(chan bool)
	tmpCacheQueue := make([]*MenusGlobalSync, 0)
	m.cacheQueue = &tmpCacheQueue
	m.lastWriteBackTime = 1 * time.Millisecond
	m.pool = &sync.Pool{New: func() interface{} { return &model.MenusGlobal{} }}

	m.bitSetAll.SetAll()

	if engine != nil {
		for idx, name := range MenusGlobalStructFiledMap {
			MenusGlobalDBFiledMap[idx] = engine.GetColumnMapper().Obj2Table(name)
		}
	}

	return
}

// NewMenusGlobal 通过主键创建对象, 已经存在直接返回. (1 数据没有导入或已经导出) 会返回nil. (2 数据已存在) 返回已存在的值
func NewMenusGlobal(AuthId int64) (ormCls *model.MenusGlobal) {

	ormCls = GMenusGlobalManager.GetMenusGlobalByAuthId(AuthId)
	if ormCls != nil {
		return
	}
	ormCls, _ = GMenusGlobalManager.NewMenusGlobal(&model.MenusGlobal{AuthId: AuthId})
	return
}

// PersistName 返回persist类名
func (m *MenusGlobalManager) PersistName() string {
	return reflect.TypeOf(*gMenusGlobalNil).Name()
}

// PersistObj 返回persist interface{}
func (m *MenusGlobalManager) PersistUserNilObjInterface() interface{} {
	return &model.MenusGlobal{}
}

// PersistObj 返回persist interface{} list
func (m *MenusGlobalManager) PersistUserNilObjInterfaceList() interface{} {
	plist := make([]*model.MenusGlobal, 0, 0)
	return &plist
}

// Run 运行并导入上次失败数据
func (m *MenusGlobalManager) Run() error {
	if atomic.CompareAndSwapInt32(&m.managerState, EMenusGlobalManagerStateIdle, EMenusGlobalManagerStateNormal) {
		if err := m.LoadFile(); err != nil {
			return err
		}
		go m.Collect()
	} else if atomic.CompareAndSwapInt32(&m.managerState, EMenusGlobalManagerStatePanic, EMenusGlobalManagerStateNormal) {
		if err := m.LoadFile(); err != nil {
			return err
		}
		go m.Collect()
	} else {
	}
	return nil
}

// Dead 管理类是否出错
func (m *MenusGlobalManager) Dead() bool {
	return atomic.LoadInt32(&m.managerState) != EMenusGlobalManagerStateNormal
}

func (m *MenusGlobalManager) BytesToPersistInterface(data []byte) (cls interface{}) {
	return m.BytesToPersist(data)
}

// BytesToPersist反序列化
func (m *MenusGlobalManager) BytesToPersist(data []byte) (cls *model.MenusGlobal) {
	var err error
	if data == nil {
		return nil
	}
	defer func() {
		if r := recover(); r != nil {
			log.Println("recovered in ", r)
			log.Println("stack: ", string(debug.Stack()))
		}
		if err != nil {
			log.Println("BytesToPersist Error", err.Error())
		}
	}()
	i := 0
	cls = &model.MenusGlobal{}

	//AuthId	int64

	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1

		cls.AuthId = int64(binary.LittleEndian.Uint64(data[i:]))
		i += 64 / 8
	} else {
		i += 1
	}

	//ParentId	int64

	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1

		cls.ParentId = int64(binary.LittleEndian.Uint64(data[i:]))
		i += 64 / 8
	} else {
		i += 1
	}

	//TreePath	string

	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1

		lenFieldDataTreePath := int(binary.LittleEndian.Uint32(data[i:]))
		i += 4
		cls.TreePath = string(data[i : i+lenFieldDataTreePath])
		i += lenFieldDataTreePath
	} else {
		i += 1
	}

	//Name	string

	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1

		lenFieldDataName := int(binary.LittleEndian.Uint32(data[i:]))
		i += 4
		cls.Name = string(data[i : i+lenFieldDataName])
		i += lenFieldDataName
	} else {
		i += 1
	}

	//Type	string

	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1

		lenFieldDataType := int(binary.LittleEndian.Uint32(data[i:]))
		i += 4
		cls.Type = string(data[i : i+lenFieldDataType])
		i += lenFieldDataType
	} else {
		i += 1
	}

	//RouteName	string

	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1

		lenFieldDataRouteName := int(binary.LittleEndian.Uint32(data[i:]))
		i += 4
		cls.RouteName = string(data[i : i+lenFieldDataRouteName])
		i += lenFieldDataRouteName
	} else {
		i += 1
	}

	//Path	string

	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1

		lenFieldDataPath := int(binary.LittleEndian.Uint32(data[i:]))
		i += 4
		cls.Path = string(data[i : i+lenFieldDataPath])
		i += lenFieldDataPath
	} else {
		i += 1
	}

	//Component	string

	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1

		lenFieldDataComponent := int(binary.LittleEndian.Uint32(data[i:]))
		i += 4
		cls.Component = string(data[i : i+lenFieldDataComponent])
		i += lenFieldDataComponent
	} else {
		i += 1
	}

	//Perm	string

	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1

		lenFieldDataPerm := int(binary.LittleEndian.Uint32(data[i:]))
		i += 4
		cls.Perm = string(data[i : i+lenFieldDataPerm])
		i += lenFieldDataPerm
	} else {
		i += 1
	}

	//Status	int64

	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1

		cls.Status = int64(binary.LittleEndian.Uint64(data[i:]))
		i += 64 / 8
	} else {
		i += 1
	}

	//AffixTab	int64

	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1

		cls.AffixTab = int64(binary.LittleEndian.Uint64(data[i:]))
		i += 64 / 8
	} else {
		i += 1
	}

	//HideChildrenInMenu	int64

	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1

		cls.HideChildrenInMenu = int64(binary.LittleEndian.Uint64(data[i:]))
		i += 64 / 8
	} else {
		i += 1
	}

	//HideInBreadcrumb	int64

	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1

		cls.HideInBreadcrumb = int64(binary.LittleEndian.Uint64(data[i:]))
		i += 64 / 8
	} else {
		i += 1
	}

	//HideInMenu	int64

	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1

		cls.HideInMenu = int64(binary.LittleEndian.Uint64(data[i:]))
		i += 64 / 8
	} else {
		i += 1
	}

	//HideInTab	int64

	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1

		cls.HideInTab = int64(binary.LittleEndian.Uint64(data[i:]))
		i += 64 / 8
	} else {
		i += 1
	}

	//KeepAlive	int64

	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1

		cls.KeepAlive = int64(binary.LittleEndian.Uint64(data[i:]))
		i += 64 / 8
	} else {
		i += 1
	}

	//Sort	int64

	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1

		cls.Sort = int64(binary.LittleEndian.Uint64(data[i:]))
		i += 64 / 8
	} else {
		i += 1
	}

	//Icon	string

	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1

		lenFieldDataIcon := int(binary.LittleEndian.Uint32(data[i:]))
		i += 4
		cls.Icon = string(data[i : i+lenFieldDataIcon])
		i += lenFieldDataIcon
	} else {
		i += 1
	}

	//Redirect	string

	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1

		lenFieldDataRedirect := int(binary.LittleEndian.Uint32(data[i:]))
		i += 4
		cls.Redirect = string(data[i : i+lenFieldDataRedirect])
		i += lenFieldDataRedirect
	} else {
		i += 1
	}

	return
}

//

func (m *MenusGlobalManager) PersistInterfaceToBytes(i interface{}) (data []byte) {
	return m.PersistToBytes(i.(*model.MenusGlobal), m.bitSetAll)
}

func (m *MenusGlobalManager) PersistInterfaceToPkStruct(i interface{}) interface{} {
	cls, ok := i.(*model.MenusGlobal)
	_ = cls
	if !ok {
		return nil
	}

	pk := MenusGlobalAuthId{

		AuthId: cls.AuthId,
	}
	return pk

}

// PersistToBytes 序列化
func (m *MenusGlobalManager) PersistToBytes(cls *model.MenusGlobal, bitSet MenusGlobalBitSet) (data []byte) {
	var err error
	if cls == nil {
		return nil
	}
	defer func() {
		if r := recover(); r != nil {
			log.Println("recovered in ", r)
			log.Println("stack: ", string(debug.Stack()))
		}
		if err != nil {
			log.Println("PersistToBytes Error", err.Error())
		}
	}()
	size := 0

	//AuthId	int64

	if true || bitSet.Get(EMenusGlobalFieldIndexAuthId) {
		size += 1 + 64/8
	} else {
		size += 1
	}

	//ParentId	int64

	if bitSet.Get(EMenusGlobalFieldIndexParentId) {
		size += 1 + 64/8
	} else {
		size += 1
	}

	//TreePath	string

	if bitSet.Get(EMenusGlobalFieldIndexTreePath) {
		size += 1 + 4 + len(cls.TreePath)
	} else {
		size += 1
	}

	//Name	string

	if bitSet.Get(EMenusGlobalFieldIndexName) {
		size += 1 + 4 + len(cls.Name)
	} else {
		size += 1
	}

	//Type	string

	if bitSet.Get(EMenusGlobalFieldIndexType) {
		size += 1 + 4 + len(cls.Type)
	} else {
		size += 1
	}

	//RouteName	string

	if bitSet.Get(EMenusGlobalFieldIndexRouteName) {
		size += 1 + 4 + len(cls.RouteName)
	} else {
		size += 1
	}

	//Path	string

	if bitSet.Get(EMenusGlobalFieldIndexPath) {
		size += 1 + 4 + len(cls.Path)
	} else {
		size += 1
	}

	//Component	string

	if bitSet.Get(EMenusGlobalFieldIndexComponent) {
		size += 1 + 4 + len(cls.Component)
	} else {
		size += 1
	}

	//Perm	string

	if bitSet.Get(EMenusGlobalFieldIndexPerm) {
		size += 1 + 4 + len(cls.Perm)
	} else {
		size += 1
	}

	//Status	int64

	if bitSet.Get(EMenusGlobalFieldIndexStatus) {
		size += 1 + 64/8
	} else {
		size += 1
	}

	//AffixTab	int64

	if bitSet.Get(EMenusGlobalFieldIndexAffixTab) {
		size += 1 + 64/8
	} else {
		size += 1
	}

	//HideChildrenInMenu	int64

	if bitSet.Get(EMenusGlobalFieldIndexHideChildrenInMenu) {
		size += 1 + 64/8
	} else {
		size += 1
	}

	//HideInBreadcrumb	int64

	if bitSet.Get(EMenusGlobalFieldIndexHideInBreadcrumb) {
		size += 1 + 64/8
	} else {
		size += 1
	}

	//HideInMenu	int64

	if bitSet.Get(EMenusGlobalFieldIndexHideInMenu) {
		size += 1 + 64/8
	} else {
		size += 1
	}

	//HideInTab	int64

	if bitSet.Get(EMenusGlobalFieldIndexHideInTab) {
		size += 1 + 64/8
	} else {
		size += 1
	}

	//KeepAlive	int64

	if bitSet.Get(EMenusGlobalFieldIndexKeepAlive) {
		size += 1 + 64/8
	} else {
		size += 1
	}

	//Sort	int64

	if bitSet.Get(EMenusGlobalFieldIndexSort) {
		size += 1 + 64/8
	} else {
		size += 1
	}

	//Icon	string

	if bitSet.Get(EMenusGlobalFieldIndexIcon) {
		size += 1 + 4 + len(cls.Icon)
	} else {
		size += 1
	}

	//Redirect	string

	if bitSet.Get(EMenusGlobalFieldIndexRedirect) {
		size += 1 + 4 + len(cls.Redirect)
	} else {
		size += 1
	}

	// ************************************ marshal ************************************
	data = make([]byte, size)
	i := 0

	//AuthId	int64

	if true || bitSet.Get(EMenusGlobalFieldIndexAuthId) {
		data[i] |= persistCore.EMarshalFlagBitSet
		i += 1

		binary.LittleEndian.PutUint64(data[i:], uint64(cls.AuthId))
		i += 64 / 8
	} else {
		i += 1
	}

	//ParentId	int64

	if bitSet.Get(EMenusGlobalFieldIndexParentId) {
		data[i] |= persistCore.EMarshalFlagBitSet
		i += 1

		binary.LittleEndian.PutUint64(data[i:], uint64(cls.ParentId))
		i += 64 / 8
	} else {
		i += 1
	}

	//TreePath	string

	if bitSet.Get(EMenusGlobalFieldIndexTreePath) {
		data[i] |= persistCore.EMarshalFlagBitSet
		i += 1

		binary.LittleEndian.PutUint32(data[i:], uint32(len(cls.TreePath)))
		i += 4
		copy(data[i:], cls.TreePath)
		i += len(cls.TreePath)
	} else {
		i += 1
	}

	//Name	string

	if bitSet.Get(EMenusGlobalFieldIndexName) {
		data[i] |= persistCore.EMarshalFlagBitSet
		i += 1

		binary.LittleEndian.PutUint32(data[i:], uint32(len(cls.Name)))
		i += 4
		copy(data[i:], cls.Name)
		i += len(cls.Name)
	} else {
		i += 1
	}

	//Type	string

	if bitSet.Get(EMenusGlobalFieldIndexType) {
		data[i] |= persistCore.EMarshalFlagBitSet
		i += 1

		binary.LittleEndian.PutUint32(data[i:], uint32(len(cls.Type)))
		i += 4
		copy(data[i:], cls.Type)
		i += len(cls.Type)
	} else {
		i += 1
	}

	//RouteName	string

	if bitSet.Get(EMenusGlobalFieldIndexRouteName) {
		data[i] |= persistCore.EMarshalFlagBitSet
		i += 1

		binary.LittleEndian.PutUint32(data[i:], uint32(len(cls.RouteName)))
		i += 4
		copy(data[i:], cls.RouteName)
		i += len(cls.RouteName)
	} else {
		i += 1
	}

	//Path	string

	if bitSet.Get(EMenusGlobalFieldIndexPath) {
		data[i] |= persistCore.EMarshalFlagBitSet
		i += 1

		binary.LittleEndian.PutUint32(data[i:], uint32(len(cls.Path)))
		i += 4
		copy(data[i:], cls.Path)
		i += len(cls.Path)
	} else {
		i += 1
	}

	//Component	string

	if bitSet.Get(EMenusGlobalFieldIndexComponent) {
		data[i] |= persistCore.EMarshalFlagBitSet
		i += 1

		binary.LittleEndian.PutUint32(data[i:], uint32(len(cls.Component)))
		i += 4
		copy(data[i:], cls.Component)
		i += len(cls.Component)
	} else {
		i += 1
	}

	//Perm	string

	if bitSet.Get(EMenusGlobalFieldIndexPerm) {
		data[i] |= persistCore.EMarshalFlagBitSet
		i += 1

		binary.LittleEndian.PutUint32(data[i:], uint32(len(cls.Perm)))
		i += 4
		copy(data[i:], cls.Perm)
		i += len(cls.Perm)
	} else {
		i += 1
	}

	//Status	int64

	if bitSet.Get(EMenusGlobalFieldIndexStatus) {
		data[i] |= persistCore.EMarshalFlagBitSet
		i += 1

		binary.LittleEndian.PutUint64(data[i:], uint64(cls.Status))
		i += 64 / 8
	} else {
		i += 1
	}

	//AffixTab	int64

	if bitSet.Get(EMenusGlobalFieldIndexAffixTab) {
		data[i] |= persistCore.EMarshalFlagBitSet
		i += 1

		binary.LittleEndian.PutUint64(data[i:], uint64(cls.AffixTab))
		i += 64 / 8
	} else {
		i += 1
	}

	//HideChildrenInMenu	int64

	if bitSet.Get(EMenusGlobalFieldIndexHideChildrenInMenu) {
		data[i] |= persistCore.EMarshalFlagBitSet
		i += 1

		binary.LittleEndian.PutUint64(data[i:], uint64(cls.HideChildrenInMenu))
		i += 64 / 8
	} else {
		i += 1
	}

	//HideInBreadcrumb	int64

	if bitSet.Get(EMenusGlobalFieldIndexHideInBreadcrumb) {
		data[i] |= persistCore.EMarshalFlagBitSet
		i += 1

		binary.LittleEndian.PutUint64(data[i:], uint64(cls.HideInBreadcrumb))
		i += 64 / 8
	} else {
		i += 1
	}

	//HideInMenu	int64

	if bitSet.Get(EMenusGlobalFieldIndexHideInMenu) {
		data[i] |= persistCore.EMarshalFlagBitSet
		i += 1

		binary.LittleEndian.PutUint64(data[i:], uint64(cls.HideInMenu))
		i += 64 / 8
	} else {
		i += 1
	}

	//HideInTab	int64

	if bitSet.Get(EMenusGlobalFieldIndexHideInTab) {
		data[i] |= persistCore.EMarshalFlagBitSet
		i += 1

		binary.LittleEndian.PutUint64(data[i:], uint64(cls.HideInTab))
		i += 64 / 8
	} else {
		i += 1
	}

	//KeepAlive	int64

	if bitSet.Get(EMenusGlobalFieldIndexKeepAlive) {
		data[i] |= persistCore.EMarshalFlagBitSet
		i += 1

		binary.LittleEndian.PutUint64(data[i:], uint64(cls.KeepAlive))
		i += 64 / 8
	} else {
		i += 1
	}

	//Sort	int64

	if bitSet.Get(EMenusGlobalFieldIndexSort) {
		data[i] |= persistCore.EMarshalFlagBitSet
		i += 1

		binary.LittleEndian.PutUint64(data[i:], uint64(cls.Sort))
		i += 64 / 8
	} else {
		i += 1
	}

	//Icon	string

	if bitSet.Get(EMenusGlobalFieldIndexIcon) {
		data[i] |= persistCore.EMarshalFlagBitSet
		i += 1

		binary.LittleEndian.PutUint32(data[i:], uint32(len(cls.Icon)))
		i += 4
		copy(data[i:], cls.Icon)
		i += len(cls.Icon)
	} else {
		i += 1
	}

	//Redirect	string

	if bitSet.Get(EMenusGlobalFieldIndexRedirect) {
		data[i] |= persistCore.EMarshalFlagBitSet
		i += 1

		binary.LittleEndian.PutUint32(data[i:], uint32(len(cls.Redirect)))
		i += 4
		copy(data[i:], cls.Redirect)
		i += len(cls.Redirect)
	} else {
		i += 1
	}

	return
}

// PersistToPersistByBitSet 按位图复制数据
func (m *MenusGlobalManager) PersistToPersistByBitSet(dst, src *model.MenusGlobal, bitSet MenusGlobalBitSet) {
	var err error
	if dst == nil || src == nil {
		log.Println("PersistToPersistByBitSet Error, dst or src is nil")
		return
	}
	defer func() {
		if r := recover(); r != nil {
			log.Println("recovered in ", r)
			log.Println("stack: ", string(debug.Stack()))
		}
		if err != nil {
			log.Println("PersistToPersistByBitSet Error", err.Error())
		}
	}()

	//AuthId	int64
	if bitSet.Get(EMenusGlobalFieldIndexAuthId) {
		dst.AuthId = src.AuthId
	}

	//ParentId	int64
	if bitSet.Get(EMenusGlobalFieldIndexParentId) {
		dst.ParentId = src.ParentId
	}

	//TreePath	string
	if bitSet.Get(EMenusGlobalFieldIndexTreePath) {
		dst.TreePath = src.TreePath
	}

	//Name	string
	if bitSet.Get(EMenusGlobalFieldIndexName) {
		dst.Name = src.Name
	}

	//Type	string
	if bitSet.Get(EMenusGlobalFieldIndexType) {
		dst.Type = src.Type
	}

	//RouteName	string
	if bitSet.Get(EMenusGlobalFieldIndexRouteName) {
		dst.RouteName = src.RouteName
	}

	//Path	string
	if bitSet.Get(EMenusGlobalFieldIndexPath) {
		dst.Path = src.Path
	}

	//Component	string
	if bitSet.Get(EMenusGlobalFieldIndexComponent) {
		dst.Component = src.Component
	}

	//Perm	string
	if bitSet.Get(EMenusGlobalFieldIndexPerm) {
		dst.Perm = src.Perm
	}

	//Status	int64
	if bitSet.Get(EMenusGlobalFieldIndexStatus) {
		dst.Status = src.Status
	}

	//AffixTab	int64
	if bitSet.Get(EMenusGlobalFieldIndexAffixTab) {
		dst.AffixTab = src.AffixTab
	}

	//HideChildrenInMenu	int64
	if bitSet.Get(EMenusGlobalFieldIndexHideChildrenInMenu) {
		dst.HideChildrenInMenu = src.HideChildrenInMenu
	}

	//HideInBreadcrumb	int64
	if bitSet.Get(EMenusGlobalFieldIndexHideInBreadcrumb) {
		dst.HideInBreadcrumb = src.HideInBreadcrumb
	}

	//HideInMenu	int64
	if bitSet.Get(EMenusGlobalFieldIndexHideInMenu) {
		dst.HideInMenu = src.HideInMenu
	}

	//HideInTab	int64
	if bitSet.Get(EMenusGlobalFieldIndexHideInTab) {
		dst.HideInTab = src.HideInTab
	}

	//KeepAlive	int64
	if bitSet.Get(EMenusGlobalFieldIndexKeepAlive) {
		dst.KeepAlive = src.KeepAlive
	}

	//Sort	int64
	if bitSet.Get(EMenusGlobalFieldIndexSort) {
		dst.Sort = src.Sort
	}

	//Icon	string
	if bitSet.Get(EMenusGlobalFieldIndexIcon) {
		dst.Icon = src.Icon
	}

	//Redirect	string
	if bitSet.Get(EMenusGlobalFieldIndexRedirect) {
		dst.Redirect = src.Redirect
	}

	return
}

// BytesToPersistSync 反序列化sync
func (m *MenusGlobalManager) BytesToPersistSync(data []byte) (persistSync *MenusGlobalSync) {
	var err error
	if data == nil {
		return nil
	}
	defer func() {
		if r := recover(); r != nil {
			log.Println("recovered in ", r)
			log.Println("stack: ", string(debug.Stack()))
		}
		if err != nil {
			log.Println("BytesToPersistSync Error", err.Error())
		}
	}()
	i := 0

	const bitSetSize = (int)((EMenusGlobalFiledIndexLength>>EMenusGlobalLog2WordSize)+1) * 8

	persistSync = &MenusGlobalSync{}
	lenPersistData := len(data) - bitSetSize - 1

	persistSync.Data = m.BytesToPersist(data[:lenPersistData])

	i += lenPersistData
	persistSync.Op = int8(data[i])
	i += 1
	for j := 0; j < bitSetSize/8; j++ {
		persistSync.BitSet.set[j] = binary.LittleEndian.Uint64(data[i:])
		i += 8
	}

	return
}

// PersistSyncToBytes 序列化sync
func (m *MenusGlobalManager) PersistSyncToBytes(persistSync *MenusGlobalSync) (data []byte) {
	var err error
	if persistSync == nil {
		return nil
	}
	defer func() {
		if r := recover(); r != nil {
			log.Println("recovered in ", r)
			log.Println("stack: ", string(debug.Stack()))
		}
		if err != nil {
			log.Println("PersistSyncToBytes Error", err.Error())
		}
	}()
	size := 0

	const bitSetSize = (int)((EMenusGlobalFiledIndexLength>>EMenusGlobalLog2WordSize)+1) * 8

	pData := m.PersistToBytes(persistSync.Data, persistSync.BitSet)
	size += len(pData) + 1 + bitSetSize

	data = make([]byte, size)

	i := 0

	copy(data[i:], pData)
	i += len(pData)
	data[i] = uint8(persistSync.Op)
	i += 1
	for _, setItem := range persistSync.BitSet.set {
		binary.LittleEndian.PutUint64(data[i:], setItem)
		i += 8
	}

	return
}

// StringToPersistSyncInterface 反序列化2syncInterface
func (m *MenusGlobalManager) StringToPersistSyncInterface(data string) interface{} {
	return m.StringToPersistSync(data)
}

// StringToPersistSync 反序列化2sync
func (m *MenusGlobalManager) StringToPersistSync(data string) (persistSync *MenusGlobalSync) {
	if data == "" {
		return nil
	}
	buf, err := base64.StdEncoding.DecodeString(data)
	if err != nil {
		return nil
	}
	return m.BytesToPersistSync(buf)
}

// PersistSyncToString 序列化2sync
func (m *MenusGlobalManager) PersistSyncToString(persistSync *MenusGlobalSync) (data string) {
	buf := m.PersistSyncToBytes(persistSync)
	if buf == nil {
		return ""
	}
	data = base64.StdEncoding.EncodeToString(buf)
	return
}

// UnmarshalFailQueue 失败队列反序列化
func (m *MenusGlobalManager) UnmarshalFailQueue(data []byte, failQueue *[]*MenusGlobalSync) (err error) {
	if data == nil || failQueue == nil {
		return nil
	}
	defer func() {
		if r := recover(); r != nil {
			log.Println("recovered in ", r)
			log.Println("stack: ", string(debug.Stack()))
		}
		if err != nil {
			log.Println("UnmarshalFailQueue Error", err.Error())
		}
	}()
	i := 0
	lenFailQueue := binary.LittleEndian.Uint32(data[i:])
	i += 4
	*failQueue = make([]*MenusGlobalSync, lenFailQueue)
	for idx := 0; idx < int(lenFailQueue); idx++ {
		lenPersistSyncData := int(binary.LittleEndian.Uint32(data[i:]))
		i += 4
		persistSync := m.BytesToPersistSync(data[i : i+lenPersistSyncData])
		i += lenPersistSyncData
		(*failQueue)[idx] = persistSync
	}
	return nil
}

// MarshalFailQueue 失败队列序列化
func (m *MenusGlobalManager) MarshalFailQueue(failQueue []*MenusGlobalSync) (data []byte, err error) {
	var idx int
	var size int
	var persistSync *MenusGlobalSync
	defer func() {
		if r := recover(); r != nil {
			log.Println("recovered in ", r)
			log.Println("stack: ", string(debug.Stack()))
		}
		if err != nil {
			log.Println("MarshalFailQueue Error", err.Error())
		}
	}()
	persistSyncDataList := make([][]byte, len(failQueue))
	size += 4
	for idx = range failQueue {
		persistSync = failQueue[idx]
		pData := m.PersistSyncToBytes(persistSync)
		persistSyncDataList[idx] = pData
		size += 4 + len(pData)
	}

	data = make([]byte, size)
	i := 0
	binary.LittleEndian.PutUint32(data[i:], uint32(len(failQueue)))
	i += 4
	for idx = range failQueue {
		binary.LittleEndian.PutUint32(data[i:], uint32(len(persistSyncDataList[idx])))
		i += 4
		copy(data[i:], persistSyncDataList[idx])
		i += len(persistSyncDataList[idx])
	}
	return
}

// acquireDeepCopyObject 拷贝一个新对象用于写回
func (m *MenusGlobalManager) acquireDeepCopyObject(cls *model.MenusGlobal) (ret *model.MenusGlobal) {
	if v, ok := ((interface{})(cls)).(MenusGlobalDeepCopy); ok {
		//ret = m.pool.Get().(*model.MenusGlobal)
		ret = &model.MenusGlobal{}
		v.CopyTo(ret)
	} else {
		ret = m.BytesToPersist(m.PersistToBytes(cls, m.bitSetAll))
	}
	return
}

// releaseDeepCopyObject 释放对象
func (m *MenusGlobalManager) releaseDeepCopyObject(cls *model.MenusGlobal) {
	//if _, ok := ((interface{})(cls)).(*MenusGlobalDeepCopy); ok {
	//	m.pool.Put(cls)
	//}
	return
}

// CheckOverload 检查负载
func (m *MenusGlobalManager) CheckOverload() {
	// queueLength 不是精确值,  cacheQueue, FailQueue 一写多读
	queueLength := len(*m.cacheQueue) + len(m.FailQueue)
	if queueLength > 10000 {
		if v, ok := ((interface{})(gMenusGlobalNil)).(MenusGlobalOverload); ok {
			go utils.SafeGoRecoverWarpFunc(func() { v.Overload(queueLength, m.lastWriteBackTime) })
		} else {
		}
	} else {
	}
}

// addMenusGlobal添加一个对象
func (m *MenusGlobalManager) addMenusGlobal(cls *model.MenusGlobal) (*model.MenusGlobal, bool) {

	actual, loaded := m.hashAuthId.LoadOrStore(MenusGlobalKeyTypeHashAuthId{cls.AuthId}, cls)
	if !loaded {
		actual = cls

		if v, ok := m.hashAuthIdType.LoadOrStore(MenusGlobalKeyTypeHashAuthIdType{cls.AuthId, cls.Type}, &MenusGlobalSet{}); !ok {
			v.Store(cls, true)
		} else {
			v.Store(cls, true)
		}

	}
	return actual, !loaded
}

// removeMenusGlobal 删除一个对象
func (m *MenusGlobalManager) removeMenusGlobal(cls *model.MenusGlobal) {
	// m.hashAuthIdMark.Delete(MenusGlobalKeyTypeHashAuthId{ cls.AuthId, })

	if v, ok := m.hashAuthIdType.Load(MenusGlobalKeyTypeHashAuthIdType{cls.AuthId, cls.Type}); ok {
		v.Delete(cls)
	}
	if v, ok := m.hashAuthIdType.Load(MenusGlobalKeyTypeHashAuthIdType{cls.AuthId, cls.Type}); ok {
		has := false
		v.Range(func(key *model.MenusGlobal, value bool) bool {
			has = true
			return false
		})
		if !has {
			m.hashAuthIdType.Delete(MenusGlobalKeyTypeHashAuthIdType{cls.AuthId, cls.Type})
		}
	}

	m.hashAuthId.Delete(MenusGlobalKeyTypeHashAuthId{cls.AuthId})

	return
}

// InitDS ds并发map初始化
func (m *MenusGlobalManager) InitDS(cls *model.MenusGlobal) {
	// todo
	// cls.MyMap = ds.RWMapInt32Int32{}

	//AuthId	int64

	//ParentId	int64

	//TreePath	string

	//Name	string

	//Type	string

	//RouteName	string

	//Path	string

	//Component	string

	//Perm	string

	//Status	int64

	//AffixTab	int64

	//HideChildrenInMenu	int64

	//HideInBreadcrumb	int64

	//HideInMenu	int64

	//HideInTab	int64

	//KeepAlive	int64

	//Sort	int64

	//Icon	string

	//Redirect	string

}

// NewMenusGlobal 添加对象并异步写回数据库, (1 数据没有导入或已经导出, 2 数据已存在, 3 对象为空) 会返回失败
func (m *MenusGlobalManager) NewMenusGlobal(cls *model.MenusGlobal) (*model.MenusGlobal, error) {

	if cls == nil {
		return nil, persistCore.EPersistErrorNil
	}

	if m.LoadAllState() != EMenusGlobalLoadStateMemory {
		return nil, persistCore.EPersistErrorNotInMemory
	}

	actual, success := m.addMenusGlobal(cls)

	if success {
		m.InitDS(cls)
		bitSet := MenusGlobalBitSet{}
		bitSet.SetAll()
		newCls := m.acquireDeepCopyObject(cls)

		persistSync := &MenusGlobalSync{Data: newCls, Op: EMenusGlobalOpInsert, BitSet: bitSet}

		log.Println("[sql trace MenusGlobal]", m.PersistSyncToString(persistSync))

		m.syncChan <- persistSync

	} else {
		return actual, persistCore.EPersistErrorAlreadyExist
	}

	return actual, nil
}

// DeleteMenusGlobal 删除对象并异步写回数据库 (1 数据没有导入或已经导出, 2 数据已经重新导入, 3 对象为空) 会返回失败
func (m *MenusGlobalManager) DeleteMenusGlobal(cls *model.MenusGlobal) error {
	if cls == nil {
		return persistCore.EPersistErrorNil
	}

	if m.LoadAllState() != EMenusGlobalLoadStateMemory {
		return persistCore.EPersistErrorNotInMemory
	}

	p := m.GetMenusGlobalByAuthId(cls.AuthId)
	if p == nil || p != cls {
		return persistCore.EPersistErrorOutOfDate
	}

	m.removeMenusGlobal(cls)

	// 主键不能修改
	bitSet := MenusGlobalBitSet{}
	bitSet.SetAll()
	newCls := m.acquireDeepCopyObject(cls)

	persistSync := &MenusGlobalSync{Data: newCls, Op: EMenusGlobalOpDelete, BitSet: bitSet}

	log.Println("[sql trace MenusGlobal]", m.PersistSyncToString(persistSync))

	m.syncChan <- persistSync

	return nil
}

// DeleteAll 删除所有对象并异步写回数据库
func (m *MenusGlobalManager) DeleteAll() {

	var tmpMenusGlobalList []*model.MenusGlobal
	m.hashAuthId.Range(func(k MenusGlobalKeyTypeHashAuthId, v *model.MenusGlobal) bool {
		tmpMenusGlobalList = append(tmpMenusGlobalList, v)
		return true
	})
	for _, cls := range tmpMenusGlobalList {
		if cls == nil {
			continue
		}
		m.removeMenusGlobal(cls)

		// 主键不能修改
		bitSet := MenusGlobalBitSet{}
		bitSet.SetAll()
		newCls := m.acquireDeepCopyObject(cls)

		persistSync := &MenusGlobalSync{Data: newCls, Op: EMenusGlobalOpDelete, BitSet: bitSet}

		log.Println("[sql trace MenusGlobal]", m.PersistSyncToString(persistSync))

		m.syncChan <- persistSync

	}
}

// EOptimizeFlagUsePoolAndDisableDeleteUnload 优化下不支持修改索引

// 不建议修改索引列

// SetIndexKeyAuthIdType 修改包含索引字段, 标记脏对象并异步写回数据库, 需要保证一致性, 生成时开启 EOptimizeFlagIndexMutex
// (1 数据没有导入或已经导出, 2 数据已经重新导入, 3 对象为空) 会返回失败
func (m *MenusGlobalManager) SetIndexKeyAuthIdType(cls *model.MenusGlobal, Type string) error {

	if cls == nil {
		return persistCore.EPersistErrorNil
	}

	if m.LoadAllState() != EMenusGlobalLoadStateMemory {
		return persistCore.EPersistErrorNotInMemory
	}

	if v, ok := m.hashAuthIdType.Load(MenusGlobalKeyTypeHashAuthIdType{cls.AuthId, cls.Type}); ok {
		v.Delete(cls)
	}
	if v, ok := m.hashAuthIdType.Load(MenusGlobalKeyTypeHashAuthIdType{cls.AuthId, cls.Type}); ok {
		has := false
		v.Range(func(key *model.MenusGlobal, value bool) bool {
			has = true
			return false
		})
		if !has {
			m.hashAuthIdType.Delete(MenusGlobalKeyTypeHashAuthIdType{cls.AuthId, cls.Type})
		}
	}

	cls.Type = Type

	if v, ok := m.hashAuthIdType.LoadOrStore(MenusGlobalKeyTypeHashAuthIdType{cls.AuthId, cls.Type}, &MenusGlobalSet{}); !ok {
		v.Store(cls, true)
	} else {
		v.Store(cls, true)
	}

	// return m.MarkUpdate(cls)
	bitSet := MenusGlobalBitSet{}

	bitSet.Set(EMenusGlobalFieldIndexType)

	return m.MarkUpdateByBitSet(cls, bitSet)
}

// SetIndexKeyType 修改包含索引字段, 标记脏对象并异步写回数据库, 需要保证一致性, 生成时开启 EOptimizeFlagIndexMutex
// (1 数据没有导入或已经导出, 2 数据已经重新导入, 3 对象为空) 会返回失败
func (m *MenusGlobalManager) SetIndexKeyType(cls *model.MenusGlobal, Type string) error {

	if cls == nil {
		return persistCore.EPersistErrorNil
	}

	if m.LoadAllState() != EMenusGlobalLoadStateMemory {
		return persistCore.EPersistErrorNotInMemory
	}

	if v, ok := m.hashAuthIdType.Load(MenusGlobalKeyTypeHashAuthIdType{cls.AuthId, cls.Type}); ok {
		v.Delete(cls)
	}
	if v, ok := m.hashAuthIdType.Load(MenusGlobalKeyTypeHashAuthIdType{cls.AuthId, cls.Type}); ok {
		has := false
		v.Range(func(key *model.MenusGlobal, value bool) bool {
			has = true
			return false
		})
		if !has {
			m.hashAuthIdType.Delete(MenusGlobalKeyTypeHashAuthIdType{cls.AuthId, cls.Type})
		}
	}

	cls.Type = Type

	if v, ok := m.hashAuthIdType.LoadOrStore(MenusGlobalKeyTypeHashAuthIdType{cls.AuthId, cls.Type}, &MenusGlobalSet{}); !ok {
		v.Store(cls, true)
	} else {
		v.Store(cls, true)
	}

	// return m.MarkUpdate(cls)
	bitSet := MenusGlobalBitSet{}
	bitSet.Set(EMenusGlobalFieldIndexType)
	return m.MarkUpdateByBitSet(cls, bitSet)
}

// MarkUpdate 标记脏对象并异步写回数据库, (1 数据没有导入或已经导出, 2 数据已经重新导入, 3 对象为空) 会返回失败
func (m *MenusGlobalManager) MarkUpdate(cls *model.MenusGlobal) error {
	if cls == nil {
		return persistCore.EPersistErrorNil
	}

	if m.LoadAllState() != EMenusGlobalLoadStateMemory {
		return persistCore.EPersistErrorNotInMemory
	}

	p := m.GetMenusGlobalByAuthId(cls.AuthId)
	if p == nil || p != cls {
		return persistCore.EPersistErrorOutOfDate
	}

	m.InitDS(cls)
	bitSet := MenusGlobalBitSet{}
	bitSet.SetAll()
	newCls := m.acquireDeepCopyObject(cls)

	persistSync := &MenusGlobalSync{Data: newCls, Op: EMenusGlobalOpUpdate, BitSet: bitSet}

	log.Println("[sql trace MenusGlobal]", m.PersistSyncToString(persistSync))

	m.syncChan <- persistSync

	return nil
}

// MarkUpdateByBitSet 标记脏对象并异步写回数据库, (1 数据没有导入或已经导出, 2 数据已经重新导入, 3 对象为空) 会返回失败
func (m *MenusGlobalManager) MarkUpdateByBitSet(cls *model.MenusGlobal, bitSet MenusGlobalBitSet) error {
	if cls == nil {
		return persistCore.EPersistErrorNil
	}

	if m.LoadAllState() != EMenusGlobalLoadStateMemory {
		return persistCore.EPersistErrorNotInMemory
	}

	p := m.GetMenusGlobalByAuthId(cls.AuthId)
	if p == nil || p != cls {
		return persistCore.EPersistErrorOutOfDate
	}

	m.InitDS(cls)

	newCls := m.acquireDeepCopyObject(cls)

	persistSync := &MenusGlobalSync{Data: newCls, Op: EMenusGlobalOpUpdate, BitSet: bitSet}

	log.Println("[sql trace MenusGlobal]", m.PersistSyncToString(persistSync))

	m.syncChan <- persistSync

	return nil
}

// MarkUpdateByFieldIndex 标记脏对象并异步写回数据库, (1 数据没有导入或已经导出, 2 数据已经重新导入, 3 对象为空) 会返回失败
func (m *MenusGlobalManager) MarkUpdateByFieldIndex(cls *model.MenusGlobal, fieldIndex MenusGlobalFieldIndex) error {
	return m.MarkUpdateByBitSet(cls, *((&MenusGlobalBitSet{}).Set(fieldIndex)))
}

// GetMenusGlobalByAuthId 通过索引查找对象
func (m *MenusGlobalManager) GetMenusGlobalByAuthId(AuthId int64) *model.MenusGlobal {

	if data, ok := m.hashAuthId.Load(MenusGlobalKeyTypeHashAuthId{AuthId}); ok {
		return data
	}
	return nil
}

// GetMenusGlobalsByAuthIdType 通过索引查找对象
func (m *MenusGlobalManager) GetMenusGlobalsByAuthIdType(AuthId int64, Type string) (ret []*model.MenusGlobal) {

	if data, ok := m.hashAuthIdType.Load(MenusGlobalKeyTypeHashAuthIdType{AuthId, Type}); ok {
		data.Range(func(k *model.MenusGlobal, v bool) bool {
			ret = append(ret, k)
			return true
		})
	}
	return
}

// GetAll 通过主键查找所有对象
func (m *MenusGlobalManager) GetAll() (ret []*model.MenusGlobal) {

	m.hashAuthId.Range(func(k MenusGlobalKeyTypeHashAuthId, v *model.MenusGlobal) bool {
		ret = append(ret, v)
		return true
	})
	return
}

// LoadAllState 所有数据导入状态
func (m *MenusGlobalManager) LoadAllState() int32 {
	return atomic.LoadInt32(&m.loadAll)
}

// LoadAll (非线程安全) 导入所有数据, 全导入后只能全导出, 不能再按照key导入导出
func (m *MenusGlobalManager) LoadAll() (err error) {
	log.Println("MenusGlobalManager LoadAll begin")
	// 未全导入状态切换到全导入
	if atomic.CompareAndSwapInt32(&m.loadAll, EMenusGlobalTableStateDisk, EMenusGlobalTableStateLoading) {
		rows := make([]*model.MenusGlobal, 0)
		err = m.engine.Find(&rows, gMenusGlobalNil)
		if err != nil {
			atomic.StoreInt32(&m.loadAll, EMenusGlobalTableStateDisk)
			return err
		} else {

			for _, row := range rows {
				m.addMenusGlobal(row)
			}
			atomic.StoreInt32(&m.loadAll, EMenusGlobalTableStateMemory)
		}
	} else {
		return persistCore.EPersistErrorIncorrectState
	}
	log.Println("MenusGlobalManager LoadAll end")
	return
}

// UnloadAll (非线程安全) 导出所有数据, 调用UnloadAll后,不允许再修改相关的数据(必须先导入才能修改数据)
func (m *MenusGlobalManager) UnloadAll() (err error) {
	var clsList []*model.MenusGlobal
	// 未导入状态切换到导入
	if atomic.CompareAndSwapInt32(&m.loadAll, EMenusGlobalTableStateMemory, EMenusGlobalTableStateUnloading) {

		m.hashAuthId.Range(func(k MenusGlobalKeyTypeHashAuthId, v *model.MenusGlobal) bool {
			clsList = append(clsList, v)
			return true
		})
		for _, cls := range clsList {
			m.removeMenusGlobal(cls)
		}
		atomic.StoreInt32(&m.loadAll, EMenusGlobalTableStateDisk)
	} else {
		return persistCore.EPersistErrorIncorrectState
	}
	return
}

var GMenusGlobalManager *MenusGlobalManager

// init 注册管理类
func init() {

	engine := GetDB()
	if engine == nil {
		// log.Println(persistCore.EPersistErrorEngineNil)
		persistCore.RegisterPersistLazy("MenusGlobal", GMenusGlobalManager)
		return
	}

	GMenusGlobalManager = NewMenusGlobalManager(engine)
	Register("MenusGlobal", GMenusGlobalManager)
	// go GMenusGlobalManager.Collect()

	//for idx, name := range MenusGlobalStructFiledMap {
	//	MenusGlobalDBFiledMap[idx] = engine.GetColumnMapper().Obj2Table(name)
	//}

}

// LazyInit 惰性创建注册初始化
func (m *MenusGlobalManager) LazyInit() (err error) {

	if GetDB == nil {
		err = errors.New("GetDB is nil")
		return
	}
	engine := GetDB()
	if engine == nil {
		err = errors.New("engine is nil")
		return
	}
	GMenusGlobalManager = NewMenusGlobalManager(engine)
	Register("MenusGlobal", GMenusGlobalManager)

	return
}

// noneFunc 惰性创建注册初始化
func (m *MenusGlobalManager) noneFunc() {
	math.Abs(1.0)
	_ = jsoniter.ConfigCompatibleWithStandardLibrary
	_ = json.Marshal
	_ = sync.Mutex{}
	_ = reflect.Value{}
	_ = time.Now()
	_ = sentry.Client{}
	_ = strings.Builder{}
	log.Println("none")
}

// SaveDB xorm写数据库
func (m *MenusGlobalManager) SaveDB(session *xorm.Session, persistSync *MenusGlobalSync) (err error) {
	defer func() {
		if r := recover(); r != nil {
			log.Println("recovered in ", r)
			log.Println("stack: ", string(debug.Stack()))
			if err == nil {
				err = errors.New("unknown error")
			}
		}
	}()
	switch persistSync.Op {
	case EMenusGlobalOpInsert:

		_, err = session.Insert(persistSync.Data)

		if err != nil {
			log.Println("insert error ", err, "[sql error MenusGlobal]", m.PersistSyncToString(persistSync))
			return
		}

	case EMenusGlobalOpUpdate:
		cls := persistSync.Data
		bitSet := persistSync.BitSet
		if bitSet.IsSetAll() {
			_, err = session.ID(core.NewPK(cls.AuthId)).AllCols().Update(cls)
			if err != nil {
				log.Println("update error ", err, "[sql error MenusGlobal]", m.PersistSyncToString(persistSync))
				return
			}
		} else {
			var nameList []string
			for idx, name := range MenusGlobalDBFiledMap {
				if bitSet.Get(MenusGlobalFieldIndex(idx)) {
					nameList = append(nameList, name)
				}
			}
			if nameList != nil {
				_, err = session.ID(core.NewPK(cls.AuthId)).Cols(nameList...).Update(cls)
				if err != nil {
					log.Println("update error ", err, "[sql error MenusGlobal]", m.PersistSyncToString(persistSync))
					return
				}
			} else {
				_, err = session.ID(core.NewPK(cls.AuthId)).AllCols().Update(cls)
				if err != nil {
					log.Println("update error ", err, "[sql error MenusGlobal]", m.PersistSyncToString(persistSync))
					return
				}
			}
		}

	case EMenusGlobalOpDelete:
		cls := persistSync.Data
		_, err = session.ID(core.NewPK(cls.AuthId)).Delete(gMenusGlobalNil)
		if err != nil {
			log.Println("delete error ", err, "[sql error MenusGlobal]", m.PersistSyncToString(persistSync))
			return
		}

	}
	return
}

// DataToFailQueue 未写入成功数据, 添加到失败队列
func (m *MenusGlobalManager) DataToFailQueue() {
	var persistSync *MenusGlobalSync

	// 一旦失败标记所有的数据都是失败, 不允许导出

	m.FailQueue = append(m.FailQueue, m.InsertQueue...)
	m.InsertQueue = m.InsertQueue[0:0]

	for i := 0; i < len(*m.syncQueue); i++ {
		persistSync = (*m.syncQueue)[i]
		switch persistSync.Op {
		case EMenusGlobalOpInsert, EMenusGlobalOpUpdate, EMenusGlobalOpDelete:
			m.FailQueue = append(m.FailQueue, persistSync)

		default:
		}
	}
	*m.syncQueue = (*m.syncQueue)[0:0]
}

// LoadFile 文件读取写回失败数据
func (m *MenusGlobalManager) LoadFile() error {
	bombExist := utils.Exists("_./_Users_xt_go_pumppill_data/MenusGlobal.bomb")
	tmpExist := utils.Exists("_./_Users_xt_go_pumppill_data/MenusGlobal.tmp")

	if tmpExist {
		return persistCore.EPersistErrorTempFileExist
	}

	if bombExist {
		data, err := ioutil.ReadFile("_./_Users_xt_go_pumppill_data/MenusGlobal.bomb")
		if err != nil {
			return err
		}
		pos := bytes.IndexByte(data, byte(' '))
		if pos == -1 {
			return persistCore.EPersistErrorInvalidBombFile
		}
		persistData := data[pos+1:]
		err = m.UnmarshalFailQueue(persistData, &m.FailQueue)
		if err != nil {
			return err
		}

		session := m.engine.NewSession()
		defer session.Close()

		var persistSync *MenusGlobalSync

		for i := range m.FailQueue {
			persistSync = m.FailQueue[i]
			err = m.SaveDB(session, persistSync)
			if err != nil {
				m.FailQueue = m.FailQueue[i:]
				m.SaveFile()
				return err
			}
		}
		m.FailQueue = m.FailQueue[0:0]
		m.RemoveFile()

	}
	return nil
}

// SaveFile 写回失败,记录数据,写文件,等待下次写回
func (m *MenusGlobalManager) SaveFile() {

	m.DataToFailQueue()

	data, err := m.MarshalFailQueue(m.FailQueue)
	if err != nil {
		log.Println("SaveFile marshal error ", err)
	}
	_ = os.Mkdir("_./_Users_xt_go_pumppill_data", 0770)
	err = ioutil.WriteFile("_./_Users_xt_go_pumppill_data/MenusGlobal.tmp", append([]byte("MenusGlobal "), data...), 0660)
	if err != nil {
		log.Println("SaveFile write temp file error ", err)
	}
	err = ioutil.WriteFile("_./_Users_xt_go_pumppill_data/MenusGlobal.bomb", append([]byte("MenusGlobal "), data...), 0660)
	if err != nil {
		log.Println("SaveFile write bomb file error ", err)
	}
	_ = os.Remove("_./_Users_xt_go_pumppill_data/MenusGlobal.tmp")
}

// RemoveFile 删除写回失败文件
func (m *MenusGlobalManager) RemoveFile() {
	_ = os.Remove("_./_Users_xt_go_pumppill_data/MenusGlobal.tmp")
	_ = os.Remove("_./_Users_xt_go_pumppill_data/MenusGlobal.bomb")
	_ = os.Remove("_./_Users_xt_go_pumppill_data")
}

// RecoverBomb bomb数据写入数据库
func (m *MenusGlobalManager) RecoverBomb(bomb []byte) (err error) {
	var persistSync *MenusGlobalSync
	var failQueue []*MenusGlobalSync
	session := m.engine.NewSession()
	defer session.Close()
	err = m.UnmarshalFailQueue(bomb, &failQueue)
	if err != nil {
		return
	}
	var i int
	for i = range failQueue {
		persistSync = failQueue[i]
		err = m.SaveDB(session, persistSync)
		if err != nil {
			break
		}
	}
	if len(failQueue)-1 > i {
		data, _ := m.MarshalFailQueue(failQueue[i:])
		_, _ = os.Stdout.Write([]byte("MenusGlobal "))
		_, _ = os.Stdout.Write(data)
	}
	return
}

// RecoverTrace trace数据写入数据库
func (m *MenusGlobalManager) RecoverTrace(trace [][]byte) (err error) {
	var persistSync *MenusGlobalSync
	var traceQueue []*MenusGlobalSync
	var insertQueue []*MenusGlobalSync

	for i := 0; i < len(trace); i++ {
		persistSync = m.StringToPersistSync(string(trace[i]))
		if persistSync.Op == EMenusGlobalOpInsert {
			insertQueue = append(insertQueue, persistSync)
		} else {
			traceQueue = append(traceQueue, persistSync)
		}
	}

	insertQueue2, otherQueue := m.MergeQueue(traceQueue, false)
	for _, insertItem := range insertQueue2 {
		insertQueue = append(insertQueue, insertItem)
	}

	session := m.engine.NewSession()
	defer session.Close()

	var i int
	for i = range insertQueue {
		persistSync = insertQueue[i]
		_ = m.SaveDB(session, persistSync)
	}
	for i = range otherQueue {
		persistSync = otherQueue[i]
		_ = m.SaveDB(session, persistSync)
	}
	return
}

// MergeQueue 内存中合并操作
func (m *MenusGlobalManager) MergeQueue(q []*MenusGlobalSync, copyAll bool) (insertQueue, otherQueue []*MenusGlobalSync) {

	var currentPersistSync *MenusGlobalSync
	var oldPersistSync *MenusGlobalSync
	var ok bool

	var unloadList []*MenusGlobalSync

	// 合并可能失败, persistSyncMap必须创建副本
	persistSyncMap := map[MenusGlobalAuthId]*MenusGlobalSync{}

	//unload 按照顺序强制移到最后
	//insert update delete 按照主键合并
	lenSyncQueue := len(q)
	fail := false

LabelForSyncQueue:
	for i := 0; i < lenSyncQueue; i++ {
		currentPersistSync = q[i]
		pk := MenusGlobalAuthId{

			AuthId: currentPersistSync.Data.AuthId,
		}
		// 导出特殊处理
		if currentPersistSync.Op == EMenusGlobalOpUnload {
			unloadList = append(unloadList, currentPersistSync)
			continue
		}
		// 第一次出现直接拷贝
		if oldPersistSync, ok = persistSyncMap[pk]; !ok {
			persistSyncMap[pk] = &MenusGlobalSync{Data: currentPersistSync.Data, Op: currentPersistSync.Op, BitSet: currentPersistSync.BitSet}
			continue
		}

		switch oldPersistSync.Op {
		case EMenusGlobalOpInsert:
			switch currentPersistSync.Op {
			case EMenusGlobalOpInsert:
				fail = true
				break LabelForSyncQueue
			case EMenusGlobalOpUpdate:
				oldPersistSync.Op = EMenusGlobalOpInsert
				if copyAll {
					oldPersistSync.Data = currentPersistSync.Data
				} else {
					m.PersistToPersistByBitSet(oldPersistSync.Data, currentPersistSync.Data, currentPersistSync.BitSet)
				}
				oldPersistSync.BitSet.SetAll()
			case EMenusGlobalOpDelete:
				delete(persistSyncMap, pk)
			}
		case EMenusGlobalOpUpdate:
			switch currentPersistSync.Op {
			case EMenusGlobalOpInsert:
				fail = true
				break LabelForSyncQueue
			case EMenusGlobalOpUpdate:
				oldPersistSync.Op = EMenusGlobalOpUpdate
				if copyAll {
					oldPersistSync.Data = currentPersistSync.Data
				} else {
					m.PersistToPersistByBitSet(oldPersistSync.Data, currentPersistSync.Data, currentPersistSync.BitSet)
				}
				oldPersistSync.BitSet.Merge(currentPersistSync.BitSet)
			case EMenusGlobalOpDelete:
				oldPersistSync.Op = EMenusGlobalOpDelete
				oldPersistSync.Data = currentPersistSync.Data
				oldPersistSync.BitSet.ClearAll()
			}
		case EMenusGlobalOpDelete:
			switch currentPersistSync.Op {
			case EMenusGlobalOpInsert:
				oldPersistSync.Op = EMenusGlobalOpUpdate
				oldPersistSync.Data = currentPersistSync.Data
				oldPersistSync.BitSet.SetAll()
			case EMenusGlobalOpUpdate:
				fail = true
				break LabelForSyncQueue
			case EMenusGlobalOpDelete:
				fail = true
				break LabelForSyncQueue
			}
		}
	}
	// 遇到错误取消合并
	if fail {
		otherQueue = q
		return
	}

	// 清空队列 该函数无副作用，需要外部自行清理

	// 按照合并内容重建队列, 插入特殊处理
	for _, persistSync := range persistSyncMap {
		if persistSync.Op == EMenusGlobalOpInsert {
			insertQueue = append(insertQueue, persistSync)
		} else {
			otherQueue = append(otherQueue, persistSync)
		}
	}

	for _, persistSync := range unloadList {
		otherQueue = append(otherQueue, persistSync)
	}

	return
}

// Save 异步写回
func (m *MenusGlobalManager) Save() {
	var exit bool
	for {
		// 正常退出
		exit = m.AsyncSave()
		if exit {
			break
		}
	}
}

// AsyncSave 异步写回
func (m *MenusGlobalManager) AsyncSave() (exit bool) {
	var persistSync *MenusGlobalSync
	var err error
	var queueEmpty bool
	bTime := time.Now().UnixNano()
	defer func() {
		if r := recover(); r != nil {
			log.Println("recovered in ", r)
			log.Println("stack: ", string(debug.Stack()))
			if !queueEmpty {
				log.Println("save failed: incrementalSave")
			}
		} else {
			if !queueEmpty {
				if err == nil {
					log.Println("save success: incrementalSave")
				} else {
					log.Println("save failed: incrementalSave")
				}
			}
		}
		m.DataToFailQueue()
		m.lastWriteBackTime = time.Duration(time.Now().UnixNano() - bTime)
		m.syncEnd <- true
	}()

	needCollect := <-m.syncBegin
	if len(*m.syncQueue) == 0 {
		queueEmpty = true
		if needCollect {
			time.Sleep(time.Millisecond * 100)
		} else {
			exit = true
		}
		return
	}
	session := m.engine.NewSession()
	defer session.Close()

	log.Println("begin incrementalSave", bTime)

	if len(m.FailQueue) > 0 {
		tmpQueue := make([]*MenusGlobalSync, len(m.FailQueue)+len(*m.syncQueue))
		copy(tmpQueue, m.FailQueue)
		copy(tmpQueue[len(m.FailQueue):], *m.syncQueue)
		insertQueue, otherQueue := m.MergeQueue(tmpQueue, true)
		m.syncQueue = &otherQueue
		m.InsertQueue = insertQueue
		m.FailQueue = m.FailQueue[0:0]
	} else {
		insertQueue, otherQueue := m.MergeQueue(*m.syncQueue, true)
		m.syncQueue = &otherQueue
		m.InsertQueue = insertQueue
	}

	multiInsertFn := func() bool {
		var err error
		defer func() {
			if r := recover(); r != nil {
				_ = session.Rollback()
			} else {
				if err == nil {
					m.InsertQueue = m.InsertQueue[0:0]
				} else {
					_ = session.Rollback()
				}
			}
		}()

		if len(m.InsertQueue) <= 0 {
			return true
		}
		err = session.Begin()
		if err != nil {
			return false
		}

		const num = 100
		var insertArray [num]*model.MenusGlobal
		length := len(m.InsertQueue)
		quotient := length / num
		remainder := length % num
		for i := 0; i < quotient; i++ {
			//fmt.Println("queue->(", i*num, "-", (i+1)*num, "): ", m.InsertQueue[i*num:(i+1)*num])
			for j := 0; j < num; j++ {
				insertArray[j] = m.InsertQueue[i*num+j].Data
			}

			_, err = session.InsertMulti(insertArray[:])

			if err != nil {
				log.Println("InsertMulti error ", err)
				return false
			}
		}
		if remainder != 0 {
			//fmt.Println("queue->(", quotient*num, "-", length, "): ", m.InsertQueue[quotient*num:length])

			insertArray = [num]*model.MenusGlobal{}
			for j := 0; j < remainder; j++ {
				insertArray[j] = m.InsertQueue[quotient*num+j].Data
			}

			_, err = session.InsertMulti(insertArray[:remainder])

			if err != nil {
				log.Println("InsertMulti error ", err)
				return false
			}
		}
		err = session.Commit()
		if err != nil {
			return false
		}
		return true
	}

	multiInsertSuccess := multiInsertFn()

	// 批量插入失败, 改为单条插入
	if !multiInsertSuccess {
		for idx, persistSync := range m.InsertQueue {
			err = m.SaveDB(session, persistSync)
			if err != nil {
				m.InsertQueue = m.InsertQueue[idx:]
				m.SaveFile()
				return
			}
		}
		m.InsertQueue = m.InsertQueue[0:0]
	}

	for i := 0; i < len(*m.syncQueue); i++ {
		persistSync = (*m.syncQueue)[i]
		err = m.SaveDB(session, persistSync)
		if err != nil {
			*m.syncQueue = (*m.syncQueue)[i:]
			m.SaveFile()
			return
		}
	}
	*m.syncQueue = (*m.syncQueue)[0:0]
	m.RemoveFile()
	return
}

// Collect 收集数据
func (m *MenusGlobalManager) Collect() {
	var persistSync *MenusGlobalSync
	var ok bool
	// 0:normal  1:exit begin, save sync  2:save cache  3:save done
	var state int8
	go m.Save()
	m.syncBegin <- true
	for {
		select {
		case persistSync, ok = <-m.syncChan:
			if ok {
				*m.cacheQueue = append(*m.cacheQueue, persistSync)
			}
		case _, ok = <-m.syncEnd:
			if ok {
				m.CheckOverload()
				m.cacheQueue, m.syncQueue = m.syncQueue, m.cacheQueue
				switch state {
				case EMenusGlobalCollectStateNormal:
					//go m.AsyncSave()
					m.syncBegin <- true
				case EMenusGlobalCollectStateSaveSync:
					//go m.AsyncSave()
					m.syncBegin <- true
					state = EMenusGlobalCollectStateSaveCache
				case EMenusGlobalCollectStateSaveCache:
					//go m.AsyncSave()
					m.syncBegin <- true
					state = EMenusGlobalCollectStateSaveDone
				case EMenusGlobalCollectStateSaveDone:
					m.syncBegin <- false
					<-m.syncEnd
					m.exitEnd <- true
					return
				}
			}
		case _, ok = <-m.exitBegin:
			if ok {
				state = EMenusGlobalCollectStateSaveSync
			}
			//default:
			//	time.Sleep(time.Second/10)
		}
	}
}

// Exit 管理类退出
func (m *MenusGlobalManager) Exit(wg *sync.WaitGroup) {
	defer wg.Done()

	if atomic.LoadInt32(&m.managerState) != EMenusGlobalManagerStateNormal {
		return
	}

	m.exitBegin <- true
	<-m.exitEnd
	atomic.StoreInt32(&m.managerState, EMenusGlobalManagerStateIdle)
	return
}

// Sync 数据库表结构同步
func (m *MenusGlobalManager) Sync(wg *sync.WaitGroup) (err error) {
	defer wg.Done()

	err = m.engine.Sync2(gMenusGlobalNil)

	return
}

// Segmentation 检查是否需要换表 如果需要换表 则根据时间 和切换间隔计算是否需要换表 否则为不处理
func (m *MenusGlobalManager) Segmentation(wg *sync.WaitGroup) (err error) {
	defer wg.Done()
	return
}

// compareAndUpdate 比较数据库，不相同则更新
func (m *MenusGlobalManager) compareAndUpdate(session *xorm.Session, cls *model.MenusGlobal, sentryDebug bool) (err error) {
	update := func(session *xorm.Session, cls *model.MenusGlobal, memData, dbData string) {
		log.Println("SyncData error. missing mark Mem. [sql error MenusGlobal]", memData)
		log.Println("SyncData error. missing mark  Db. [sql error MenusGlobal]", dbData)
		_, err = session.ID(core.NewPK(cls.AuthId)).AllCols().Update(cls)
		if err != nil {
			log.Println("SyncData update error.", err, "[sql error MenusGlobal]", m.PersistSyncToString(&MenusGlobalSync{
				Data:   cls,
				Op:     EMenusGlobalOpUpdate,
				BitSet: m.bitSetAll,
			}))
			return
		}
	}
	resetTimeNSec := func(clsMem, clsDb *model.MenusGlobal) {
		defer func() {
			if r := recover(); r != nil {
				log.Println("recovered in ", r)
				log.Println("stack: ", string(debug.Stack()))
			}
		}()
		typeF := reflect.TypeOf(*clsMem)
		valueMemF := reflect.ValueOf(clsMem).Elem()
		valueDbF := reflect.ValueOf(clsDb).Elem()
		for i := 0; i < typeF.NumField(); i++ {
			if typeF.Field(i).Type.Name() == "Time" {
				f := valueMemF.Field(i)
				if f.CanInterface() {
					v := time.Unix(f.Interface().(time.Time).Unix(), 0)
					f.Set(reflect.ValueOf(v))
				}
				vMem := valueMemF.Field(i).Interface().(time.Time)
				vDb := valueDbF.Field(i).Interface().(time.Time)
				if vMem.Equal(vDb) {
					f.Set(reflect.ValueOf(vDb))
				}
			}
		}
	}

	dbCls := &model.MenusGlobal{

		AuthId: cls.AuthId,
	}
	var has bool
	has, err = session.Get(dbCls)
	if err != nil || !has {
		log.Println("SyncData query error.", err, "[sql error MenusGlobal]", m.PersistSyncToString(&MenusGlobalSync{
			Data:   cls,
			Op:     0,
			BitSet: m.bitSetAll,
		}))
		return
	}
	memCls := m.GetMenusGlobalByAuthId(cls.AuthId)
	if memCls != nil {
		resetTimeNSec(memCls, dbCls)
		memData := m.PersistSyncToString(&MenusGlobalSync{
			Data:   memCls,
			Op:     0,
			BitSet: m.bitSetAll,
		})
		dbData := m.PersistSyncToString(&MenusGlobalSync{
			Data:   dbCls,
			Op:     0,
			BitSet: m.bitSetAll,
		})
		// 数据库内存不一致
		if strings.Compare(memData, dbData) != 0 {
			if sentryDebug {
				func() {
					defer func() {
						memClsJson, _ := json.Marshal(&MenusGlobalSync{
							Data:   memCls,
							Op:     0,
							BitSet: m.bitSetAll,
						})
						dbClsJson, _ := json.Marshal(&MenusGlobalSync{
							Data:   dbCls,
							Op:     0,
							BitSet: m.bitSetAll,
						})
						sentry.WithScope(func(scope *sentry.Scope) {
							tag := "CompareError" + "MenusGlobal"
							scope.SetTag(tag, "MenusGlobal")
							scope.SetTag("transaction", "MenusGlobal")
							scope.SetExtra("memClsJson", string(memClsJson))
							scope.SetExtra("dbClsJson", string(dbClsJson))
							sentry.CaptureMessage(tag)
						})
					}()
				}()
			}
			update(session, memCls, memData, dbData)
		}
	}
	return
}

// SyncData 全部内存数据写入数据库, 本接口耗时长,仅用于停服后.  补救没有标记写回数据(只处理未标记数据,New Delete不存在漏写)
func (m *MenusGlobalManager) SyncData(wg *sync.WaitGroup, sentryDebug bool) (err error) {
	defer wg.Done()

	session := m.engine.NewSession()
	defer session.Close()

	if sentryDebug {
		func() {
			defer func() {
				for _, cls := range m.GetAll() {
					updateErr := m.compareAndUpdate(session, cls, sentryDebug)
					if updateErr != nil {
						err = updateErr
					}
				}
				if err != nil {
					sentry.WithScope(func(scope *sentry.Scope) {
						tagtag := "SyncDataError" + "MenusGlobal"
						scope.SetTag("SyncDataError", "MenusGlobal")
						scope.SetTag("transaction", "MenusGlobal")
						scope.SetExtra(err.Error(), 1)
						sentry.CaptureMessage(tagtag)
					})
				}
			}()
		}()
	} else {
		for _, cls := range m.GetAll() {
			updateErr := m.compareAndUpdate(session, cls, sentryDebug)
			if updateErr != nil {
				err = updateErr
			}
		}
	}
	return

}

// object pool
