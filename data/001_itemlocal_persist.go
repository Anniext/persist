// Code generated by persist. DO NOT EDIT.
// source: bag.go

package data

import (
	"encoding/base64"
	"encoding/binary"
	"encoding/json"
	"math"
	"menet/log"
	"runtime/debug"

	jsoniter "github.com/json-iterator/go"
	"xorm.io/xorm"

	"reflect"
	"strings"
	"sync"
	"time"

	"github.com/getsentry/sentry-go"

	"bytes"
	"errors"

	"xorm.io/core"

	"io/ioutil"
	"menet/util"
	"os"
	"runtime"
	"sync/atomic"

	persistCore "menet/persist/core"

	"anniext.asia/xt/persist/protocol"
)

// 警告:
// 内部接口禁止调用(仅供内部 和 测试代码使用)
// SaveDB, DataToFailQueue, LoadFile, SaveFile, RemoveFile
// RecoverBomb, MergeQueue, AsyncSave, Collect, CheckOverload

// 工具接口, 无副作用, 按需使用
// BytesToPersist, PersistToBytes, PersistToPersistByBitSet, BytesToPersistSync, PersistSyncToBytes,
// StringToPersistSync, PersistSyncToString, UnmarshalFailQueue, MarshalFailQueue

// 需要先导入数据再使用
// 除以下接口不需要先导入, 其他接口必须 先导入! 先导入! 先导入!
// Run, Dead, Load LoadAll, Exit, Sync, SyncData(补救没有标记写回数据, 代码正确不需要使用)

// 其他接口
// New Delete 接口按需使用
// 尽量使用MarkUpdateByBitSet 多个修改一起提交
// 只修改单条数据使用MarkUpdateByFieldIndex
// 少用或者不用MarkUpdate 全标记开销太大, 除非业务太复杂想不清楚

// 支持 hash index:[group,unique], 不支持 tree index
// op 1:insert 2:update 3:delete 4:unload

// 对象序列化接口 string, slice, array, map json序列化,
// 第一版二进制结构：
// 		指针结构：含1字节标识位(0000 0001 是否nil) + 其他
// 		string, slice, map, 复杂结构， 结构体等： 4字节长度 + ToDB|json.Marshal长度
// 		其他简单基础结构：按照最大字节存储
// 		core.Conversion 只会检查指针 例如:
// 			(m *Persist) FromDB(data []byte) error
// 			(m *Persist) ToDB(data []byte, err error)
// 自定义解析字段， 暂时不允许是其他包的结构，分析引入关系比较复杂

// 待优化功能:
// 1: LoadMany方法, 一次导入多个玩家数据
// 2: 优化对象序列化大小，添加tag 一定程度兼容新旧结构, 支持更多的类型优化

const (
	EItemLocalManagerStateIdle   = 0 // 初始化
	EItemLocalManagerStateNormal = 1 // 正常运行
	EItemLocalManagerStatePanic  = 2 // 非法停止

	EItemLocalTableStateDisk      = 0 // 导出
	EItemLocalTableStateLoading   = 1 // 全导入开始
	EItemLocalTableStateMemory    = 2 // 全导入完成
	EItemLocalTableStateUnloading = 3 // 正在全导出

	EItemLocalLoadStateDisk             = 0 // 不存在 or 导出
	EItemLocalLoadStateLoading          = 1 // 导入开始
	EItemLocalLoadStateMemory           = 2 // 导入完成
	EItemLocalLoadStatePrepareUnloading = 3 // 准备导出
	EItemLocalLoadStateUnloading        = 4 // 正在导出

	EItemLocalOpInsert = 1 // 新建
	EItemLocalOpUpdate = 2 // 修改
	EItemLocalOpDelete = 3 // 删除
	EItemLocalOpUnload = 4 // 导出

	EItemLocalCollectStateNormal    = 0 // 正常
	EItemLocalCollectStateSaveSync  = 1 // 开始退出, 清理同步队列
	EItemLocalCollectStateSaveCache = 2 // 开始退出,清理缓存队列
	EItemLocalCollectStateSaveDone  = 3 // 写回完成

)

type ItemLocal = protocol.ItemLocal

// ItemLocalDeepCopy persist对象必须支持并发访问, 不实现该接口默认深拷贝对象 (1 建议实现该接口,反射效率较低  2 map 建议生成syncmap  3 slice 建议深拷贝)
type ItemLocalDeepCopy interface {
	CopyTo(t *protocol.ItemLocal)
}

// ItemLocalOverload 未落地数据超过阈值时调用
type ItemLocalOverload interface {
	Overload(queueSize int, lastWriteBackTime time.Duration)
}

type ItemLocalUidItemId struct {
	Uid    int32
	ItemId int32
}

type ItemLocalUid struct {
	Uid int32
}

type ItemLocalKeyTypeHashUidItemId = ItemLocalUidItemId

type ItemLocalKeyTypeHashUid = ItemLocalUid

// ItemLocalManager 索引类型定义

// only define type ItemLocalHashUidItemIdMark map[ItemLocalKeyTypeHashUidItemId]bool

// only define type ItemLocalHashUidItemId map[ItemLocalKeyTypeHashUidItemId]*protocol.ItemLocal

// only define type ItemLocalHashUid map[ItemLocalKeyTypeHashUid]map[*protocol.ItemLocal]bool

// ItemLocalFieldIndex 所有列index枚举
// ItemLocalBitSet begin
// 读ast计算FieldLength 生成所有字段常量 0~length
type ItemLocalFieldIndex = uint

const EItemLocalFieldIndexZero ItemLocalFieldIndex = 0

const EItemLocalFieldIndexUid ItemLocalFieldIndex = 0

const EItemLocalFieldIndexItemId ItemLocalFieldIndex = 1

const EItemLocalFieldIndexItemNum ItemLocalFieldIndex = 2

const EItemLocalFieldIndexItemTime ItemLocalFieldIndex = 3

const EItemLocalFiledIndexLength ItemLocalFieldIndex = 4

var ItemLocalStructFiledMap = [EItemLocalFiledIndexLength]string{
	"Uid",
	"ItemId",
	"ItemNum",
	"ItemTime",
}

var ItemLocalDBFiledMap [EItemLocalFiledIndexLength]string

// EItemLocalWordSize the EItemLocalWordSize of a bit set
const EItemLocalWordSize = ItemLocalFieldIndex(64)

// EItemLocalLog2WordSize is lg(EItemLocalWordSize)
const EItemLocalLog2WordSize = ItemLocalFieldIndex(6)

// EItemLocalAllBits has every bit set
const EItemLocalAllBits uint64 = 0xffffffffffffffff

type ItemLocalBitSet struct {
	set [(EItemLocalFiledIndexLength >> EItemLocalLog2WordSize) + 1]uint64
}

// Get whether bit i is set.
func (b *ItemLocalBitSet) Get(i ItemLocalFieldIndex) bool {
	if i >= EItemLocalFiledIndexLength {
		return false
	}
	return b.set[i>>EItemLocalLog2WordSize]&(1<<(i&(EItemLocalWordSize-1))) != 0
}

// Set bit i to 1
func (b *ItemLocalBitSet) Set(i ItemLocalFieldIndex) *ItemLocalBitSet {
	if i >= EItemLocalFiledIndexLength {
		return nil
	}
	b.set[i>>EItemLocalLog2WordSize] |= 1 << (i & (EItemLocalWordSize - 1))
	return b
}

func (b *ItemLocalBitSet) Clear(i ItemLocalFieldIndex) *ItemLocalBitSet {
	if i >= EItemLocalFiledIndexLength {
		return b
	}
	b.set[i>>EItemLocalLog2WordSize] &^= 1 << (i & (EItemLocalWordSize - 1))
	return b
}

// Merge compare to b
func (b *ItemLocalBitSet) Merge(compare ItemLocalBitSet) *ItemLocalBitSet {
	for i, word := range b.set {
		b.set[i] = word | compare.set[i]
	}
	return b
}

func (b *ItemLocalBitSet) ClearAll() *ItemLocalBitSet {
	if b != nil {
		for i := range b.set {
			b.set[i] = 0
		}
	}
	return b
}

func (b *ItemLocalBitSet) SetAll() *ItemLocalBitSet {
	if b != nil {
		for i := range b.set {
			b.set[i] = EItemLocalAllBits
		}
	}
	return b
}

func (b *ItemLocalBitSet) IsSetAll() bool {
	if b != nil {
		for i := range b.set {
			if b.set[i] != EItemLocalAllBits {
				return false
			}
		}
	}
	return true
}

// ItemLocalBitSet end

// ItemLocalSync 结构定义

type ItemLocalSync struct {
	Data   *protocol.ItemLocal
	Op     int8
	BitSet ItemLocalBitSet
}

// ItemLocalManager 结构定义

type ItemLocalManager struct {

	// 0:初始化  1:正常运行  2:非法停止
	managerState int32
	// 0:导出  1:全导入开始  2:全导入完成  3:正在全导出
	loadAll int32

	// 不存在 or 0:导出  1:导入开始  2:导入完成  3:准备导出  4:正在导出
	loadUidMap ItemLocalMapUnload // map[Uid]state(atom)

	pool              *sync.Pool
	syncChan          chan *ItemLocalSync
	syncQueue         *[]*ItemLocalSync
	cacheQueue        *[]*ItemLocalSync
	FailQueue         []*ItemLocalSync
	lastWriteBackTime time.Duration

	InsertQueue []*ItemLocalSync

	syncBegin chan bool
	syncEnd   chan bool
	exitBegin chan bool
	exitEnd   chan bool

	engine *xorm.Engine

	hashUidItemId ItemLocalHashUidItemId

	hashUid ItemLocalHashUid

	// hashUidItemIdMark ItemLocalHashUidItemIdMark

	bitSetAll ItemLocalBitSet
}

var gItemLocalNil = &protocol.ItemLocal{}

func NewItemLocalManager(engine *xorm.Engine) (m *ItemLocalManager) {
	m = &ItemLocalManager{engine: engine}

	m.syncChan = make(chan *ItemLocalSync, runtime.NumCPU()*2)
	tmpSyncQueue := make([]*ItemLocalSync, 0)
	m.syncQueue = &tmpSyncQueue
	m.syncEnd = make(chan bool)
	m.syncBegin = make(chan bool)
	m.exitBegin = make(chan bool)
	m.exitEnd = make(chan bool)
	tmpCacheQueue := make([]*ItemLocalSync, 0)
	m.cacheQueue = &tmpCacheQueue
	m.lastWriteBackTime = 1 * time.Millisecond
	m.pool = &sync.Pool{New: func() interface{} { return &protocol.ItemLocal{} }}

	m.bitSetAll.SetAll()

	if engine != nil {
		for idx, name := range ItemLocalStructFiledMap {
			ItemLocalDBFiledMap[idx] = engine.GetColumnMapper().Obj2Table(name)
		}
	}

	return
}

// NewItemLocal 通过主键创建对象, 已经存在直接返回. (1 数据没有导入或已经导出) 会返回nil. (2 数据已存在) 返回已存在的值
func NewItemLocal(Uid int32, ItemId int32) (ormCls *protocol.ItemLocal) {

	if GItemLocalManager.LoadState(Uid) != EItemLocalLoadStateMemory {
		ormCls = nil
		return
	}

	ormCls = GItemLocalManager.GetItemLocalByUidItemId(Uid, ItemId)
	if ormCls != nil {
		return
	}
	ormCls, _ = GItemLocalManager.NewItemLocal(&protocol.ItemLocal{Uid: Uid, ItemId: ItemId})
	return
}

// PersistName 返回persist类名
func (m *ItemLocalManager) PersistName() string {
	return reflect.TypeOf(*gItemLocalNil).Name()
}

// PersistObj 返回persist interface{}
func (m *ItemLocalManager) PersistUserNilObjInterface() interface{} {
	return &protocol.ItemLocal{}
}

// PersistObj 返回persist interface{} list
func (m *ItemLocalManager) PersistUserNilObjInterfaceList() interface{} {
	plist := make([]*protocol.ItemLocal, 0, 0)
	return &plist
}

// Run 运行并导入上次失败数据
func (m *ItemLocalManager) Run() error {
	if atomic.CompareAndSwapInt32(&m.managerState, EItemLocalManagerStateIdle, EItemLocalManagerStateNormal) {
		if err := m.LoadFile(); err != nil {
			return err
		}
		go m.Collect()
	} else if atomic.CompareAndSwapInt32(&m.managerState, EItemLocalManagerStatePanic, EItemLocalManagerStateNormal) {
		if err := m.LoadFile(); err != nil {
			return err
		}
		go m.Collect()
	} else {
	}
	return nil
}

// Dead 管理类是否出错
func (m *ItemLocalManager) Dead() bool {
	return atomic.LoadInt32(&m.managerState) != EItemLocalManagerStateNormal
}

func (m *ItemLocalManager) BytesToPersistInterface(data []byte) (cls interface{}) {
	return m.BytesToPersist(data)
}

// BytesToPersist反序列化
func (m *ItemLocalManager) BytesToPersist(data []byte) (cls *protocol.ItemLocal) {
	var err error
	if data == nil {
		return nil
	}
	defer func() {
		if r := recover(); r != nil {
			log.Println("recovered in ", r)
			log.Println("stack: ", string(debug.Stack()))
		}
		if err != nil {
			log.Println("BytesToPersist Error", err.Error())
		}
	}()
	i := 0
	cls = &protocol.ItemLocal{}

	//Uid	int32

	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1

		cls.Uid = int32(binary.LittleEndian.Uint32(data[i:]))
		i += 32 / 8
	} else {
		i += 1
	}

	//ItemId	int32

	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1

		cls.ItemId = int32(binary.LittleEndian.Uint32(data[i:]))
		i += 32 / 8
	} else {
		i += 1
	}

	//ItemNum	int64

	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1

		cls.ItemNum = int64(binary.LittleEndian.Uint64(data[i:]))
		i += 64 / 8
	} else {
		i += 1
	}

	//ItemTime	int64

	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1

		cls.ItemTime = int64(binary.LittleEndian.Uint64(data[i:]))
		i += 64 / 8
	} else {
		i += 1
	}

	return
}

//

func (m *ItemLocalManager) PersistInterfaceToBytes(i interface{}) (data []byte) {
	return m.PersistToBytes(i.(*protocol.ItemLocal), m.bitSetAll)
}

func (m *ItemLocalManager) PersistInterfaceToPkStruct(i interface{}) interface{} {
	cls, ok := i.(*protocol.ItemLocal)
	_ = cls
	if !ok {
		return nil
	}

	pk := ItemLocalUidItemId{

		Uid: cls.Uid,

		ItemId: cls.ItemId,
	}
	return pk

}

// PersistToBytes 序列化
func (m *ItemLocalManager) PersistToBytes(cls *protocol.ItemLocal, bitSet ItemLocalBitSet) (data []byte) {
	var err error
	if cls == nil {
		return nil
	}
	defer func() {
		if r := recover(); r != nil {
			log.Println("recovered in ", r)
			log.Println("stack: ", string(debug.Stack()))
		}
		if err != nil {
			log.Println("PersistToBytes Error", err.Error())
		}
	}()
	size := 0

	//Uid	int32

	if true || bitSet.Get(EItemLocalFieldIndexUid) {
		size += 1 + 32/8
	} else {
		size += 1
	}

	//ItemId	int32

	if true || bitSet.Get(EItemLocalFieldIndexItemId) {
		size += 1 + 32/8
	} else {
		size += 1
	}

	//ItemNum	int64

	if bitSet.Get(EItemLocalFieldIndexItemNum) {
		size += 1 + 64/8
	} else {
		size += 1
	}

	//ItemTime	int64

	if bitSet.Get(EItemLocalFieldIndexItemTime) {
		size += 1 + 64/8
	} else {
		size += 1
	}

	// ************************************ marshal ************************************
	data = make([]byte, size)
	i := 0

	//Uid	int32

	if true || bitSet.Get(EItemLocalFieldIndexUid) {
		data[i] |= persistCore.EMarshalFlagBitSet
		i += 1

		binary.LittleEndian.PutUint32(data[i:], uint32(cls.Uid))
		i += 32 / 8
	} else {
		i += 1
	}

	//ItemId	int32

	if true || bitSet.Get(EItemLocalFieldIndexItemId) {
		data[i] |= persistCore.EMarshalFlagBitSet
		i += 1

		binary.LittleEndian.PutUint32(data[i:], uint32(cls.ItemId))
		i += 32 / 8
	} else {
		i += 1
	}

	//ItemNum	int64

	if bitSet.Get(EItemLocalFieldIndexItemNum) {
		data[i] |= persistCore.EMarshalFlagBitSet
		i += 1

		binary.LittleEndian.PutUint64(data[i:], uint64(cls.ItemNum))
		i += 64 / 8
	} else {
		i += 1
	}

	//ItemTime	int64

	if bitSet.Get(EItemLocalFieldIndexItemTime) {
		data[i] |= persistCore.EMarshalFlagBitSet
		i += 1

		binary.LittleEndian.PutUint64(data[i:], uint64(cls.ItemTime))
		i += 64 / 8
	} else {
		i += 1
	}

	return
}

// PersistToPersistByBitSet 按位图复制数据
func (m *ItemLocalManager) PersistToPersistByBitSet(dst, src *protocol.ItemLocal, bitSet ItemLocalBitSet) {
	var err error
	if dst == nil || src == nil {
		log.Println("PersistToPersistByBitSet Error, dst or src is nil")
		return
	}
	defer func() {
		if r := recover(); r != nil {
			log.Println("recovered in ", r)
			log.Println("stack: ", string(debug.Stack()))
		}
		if err != nil {
			log.Println("PersistToPersistByBitSet Error", err.Error())
		}
	}()

	//Uid	int32
	if bitSet.Get(EItemLocalFieldIndexUid) {
		dst.Uid = src.Uid
	}

	//ItemId	int32
	if bitSet.Get(EItemLocalFieldIndexItemId) {
		dst.ItemId = src.ItemId
	}

	//ItemNum	int64
	if bitSet.Get(EItemLocalFieldIndexItemNum) {
		dst.ItemNum = src.ItemNum
	}

	//ItemTime	int64
	if bitSet.Get(EItemLocalFieldIndexItemTime) {
		dst.ItemTime = src.ItemTime
	}

	return
}

// BytesToPersistSync 反序列化sync
func (m *ItemLocalManager) BytesToPersistSync(data []byte) (persistSync *ItemLocalSync) {
	var err error
	if data == nil {
		return nil
	}
	defer func() {
		if r := recover(); r != nil {
			log.Println("recovered in ", r)
			log.Println("stack: ", string(debug.Stack()))
		}
		if err != nil {
			log.Println("BytesToPersistSync Error", err.Error())
		}
	}()
	i := 0

	const bitSetSize = (int)((EItemLocalFiledIndexLength>>EItemLocalLog2WordSize)+1) * 8

	persistSync = &ItemLocalSync{}
	lenPersistData := len(data) - bitSetSize - 1

	persistSync.Data = m.BytesToPersist(data[:lenPersistData])

	i += lenPersistData
	persistSync.Op = int8(data[i])
	i += 1
	for j := 0; j < bitSetSize/8; j++ {
		persistSync.BitSet.set[j] = binary.LittleEndian.Uint64(data[i:])
		i += 8
	}

	return
}

// PersistSyncToBytes 序列化sync
func (m *ItemLocalManager) PersistSyncToBytes(persistSync *ItemLocalSync) (data []byte) {
	var err error
	if persistSync == nil {
		return nil
	}
	defer func() {
		if r := recover(); r != nil {
			log.Println("recovered in ", r)
			log.Println("stack: ", string(debug.Stack()))
		}
		if err != nil {
			log.Println("PersistSyncToBytes Error", err.Error())
		}
	}()
	size := 0

	const bitSetSize = (int)((EItemLocalFiledIndexLength>>EItemLocalLog2WordSize)+1) * 8

	pData := m.PersistToBytes(persistSync.Data, persistSync.BitSet)
	size += len(pData) + 1 + bitSetSize

	data = make([]byte, size)

	i := 0

	copy(data[i:], pData)
	i += len(pData)
	data[i] = uint8(persistSync.Op)
	i += 1
	for _, setItem := range persistSync.BitSet.set {
		binary.LittleEndian.PutUint64(data[i:], setItem)
		i += 8
	}

	return
}

// StringToPersistSyncInterface 反序列化2syncInterface
func (m *ItemLocalManager) StringToPersistSyncInterface(data string) interface{} {
	return m.StringToPersistSync(data)
}

// StringToPersistSync 反序列化2sync
func (m *ItemLocalManager) StringToPersistSync(data string) (persistSync *ItemLocalSync) {
	if data == "" {
		return nil
	}
	buf, err := base64.StdEncoding.DecodeString(data)
	if err != nil {
		return nil
	}
	return m.BytesToPersistSync(buf)
}

// PersistSyncToString 序列化2sync
func (m *ItemLocalManager) PersistSyncToString(persistSync *ItemLocalSync) (data string) {
	buf := m.PersistSyncToBytes(persistSync)
	if buf == nil {
		return ""
	}
	data = base64.StdEncoding.EncodeToString(buf)
	return
}

// UnmarshalFailQueue 失败队列反序列化
func (m *ItemLocalManager) UnmarshalFailQueue(data []byte, failQueue *[]*ItemLocalSync) (err error) {
	if data == nil || failQueue == nil {
		return nil
	}
	defer func() {
		if r := recover(); r != nil {
			log.Println("recovered in ", r)
			log.Println("stack: ", string(debug.Stack()))
		}
		if err != nil {
			log.Println("UnmarshalFailQueue Error", err.Error())
		}
	}()
	i := 0
	lenFailQueue := binary.LittleEndian.Uint32(data[i:])
	i += 4
	*failQueue = make([]*ItemLocalSync, lenFailQueue)
	for idx := 0; idx < int(lenFailQueue); idx++ {
		lenPersistSyncData := int(binary.LittleEndian.Uint32(data[i:]))
		i += 4
		persistSync := m.BytesToPersistSync(data[i : i+lenPersistSyncData])
		i += lenPersistSyncData
		(*failQueue)[idx] = persistSync
	}
	return nil
}

// MarshalFailQueue 失败队列序列化
func (m *ItemLocalManager) MarshalFailQueue(failQueue []*ItemLocalSync) (data []byte, err error) {
	var idx int
	var size int
	var persistSync *ItemLocalSync
	defer func() {
		if r := recover(); r != nil {
			log.Println("recovered in ", r)
			log.Println("stack: ", string(debug.Stack()))
		}
		if err != nil {
			log.Println("MarshalFailQueue Error", err.Error())
		}
	}()
	persistSyncDataList := make([][]byte, len(failQueue))
	size += 4
	for idx = range failQueue {
		persistSync = failQueue[idx]
		pData := m.PersistSyncToBytes(persistSync)
		persistSyncDataList[idx] = pData
		size += 4 + len(pData)
	}

	data = make([]byte, size)
	i := 0
	binary.LittleEndian.PutUint32(data[i:], uint32(len(failQueue)))
	i += 4
	for idx = range failQueue {
		binary.LittleEndian.PutUint32(data[i:], uint32(len(persistSyncDataList[idx])))
		i += 4
		copy(data[i:], persistSyncDataList[idx])
		i += len(persistSyncDataList[idx])
	}
	return
}

// acquireDeepCopyObject 拷贝一个新对象用于写回
func (m *ItemLocalManager) acquireDeepCopyObject(cls *protocol.ItemLocal) (ret *protocol.ItemLocal) {
	if v, ok := ((interface{})(cls)).(ItemLocalDeepCopy); ok {
		//ret = m.pool.Get().(*protocol.ItemLocal)
		ret = &protocol.ItemLocal{}
		v.CopyTo(ret)
	} else {
		ret = m.BytesToPersist(m.PersistToBytes(cls, m.bitSetAll))
	}
	return
}

// releaseDeepCopyObject 释放对象
func (m *ItemLocalManager) releaseDeepCopyObject(cls *protocol.ItemLocal) {
	//if _, ok := ((interface{})(cls)).(*ItemLocalDeepCopy); ok {
	//	m.pool.Put(cls)
	//}
	return
}

// CheckOverload 检查负载
func (m *ItemLocalManager) CheckOverload() {
	// queueLength 不是精确值,  cacheQueue, FailQueue 一写多读
	queueLength := len(*m.cacheQueue) + len(m.FailQueue)
	if queueLength > 10000 {
		if v, ok := ((interface{})(gItemLocalNil)).(ItemLocalOverload); ok {
			go util.RecoverWrapFunc(func() { v.Overload(queueLength, m.lastWriteBackTime) })
		} else {
		}
	} else {
	}
}

// addItemLocal添加一个对象
func (m *ItemLocalManager) addItemLocal(cls *protocol.ItemLocal) (*protocol.ItemLocal, bool) {

	actual, loaded := m.hashUidItemId.LoadOrStore(ItemLocalKeyTypeHashUidItemId{cls.Uid, cls.ItemId}, cls)
	if !loaded {
		actual = cls

		if v, ok := m.hashUid.LoadOrStore(ItemLocalKeyTypeHashUid{cls.Uid}, &ItemLocalSet{}); !ok {
			v.Store(cls, true)
		} else {
			v.Store(cls, true)
		}

	}
	return actual, !loaded
}

// removeItemLocal 删除一个对象
func (m *ItemLocalManager) removeItemLocal(cls *protocol.ItemLocal) {
	// m.hashUidItemIdMark.Delete(ItemLocalKeyTypeHashUidItemId{ cls.Uid,cls.ItemId, })

	if v, ok := m.hashUid.Load(ItemLocalKeyTypeHashUid{cls.Uid}); ok {
		v.Delete(cls)
	}
	if v, ok := m.hashUid.Load(ItemLocalKeyTypeHashUid{cls.Uid}); ok {
		has := false
		v.Range(func(key *protocol.ItemLocal, value bool) bool {
			has = true
			return false
		})
		if !has {
			m.hashUid.Delete(ItemLocalKeyTypeHashUid{cls.Uid})
		}
	}

	m.hashUidItemId.Delete(ItemLocalKeyTypeHashUidItemId{cls.Uid, cls.ItemId})

	return
}

// InitDS ds并发map初始化
func (m *ItemLocalManager) InitDS(cls *protocol.ItemLocal) {
	// todo
	// cls.MyMap = ds.RWMapInt32Int32{}

	//Uid	int32

	//ItemId	int32

	//ItemNum	int64

	//ItemTime	int64

}

// NewItemLocal 添加对象并异步写回数据库, (1 数据没有导入或已经导出, 2 数据已存在, 3 对象为空) 会返回失败
func (m *ItemLocalManager) NewItemLocal(cls *protocol.ItemLocal) (*protocol.ItemLocal, error) {

	if cls == nil {
		return nil, persistCore.EPersistErrorNil
	}

	if m.LoadState(cls.Uid) != EItemLocalLoadStateMemory {
		return nil, persistCore.EPersistErrorNotInMemory
	}

	actual, success := m.addItemLocal(cls)

	if success {
		m.InitDS(cls)
		bitSet := ItemLocalBitSet{}
		bitSet.SetAll()
		newCls := m.acquireDeepCopyObject(cls)

		persistSync := &ItemLocalSync{Data: newCls, Op: EItemLocalOpInsert, BitSet: bitSet}

		log.Println("[sql trace ItemLocal]", m.PersistSyncToString(persistSync))

		m.syncChan <- persistSync

	} else {
		return actual, persistCore.EPersistErrorAlreadyExist
	}

	return actual, nil
}

// DeleteItemLocal 删除对象并异步写回数据库 (1 数据没有导入或已经导出, 2 数据已经重新导入, 3 对象为空) 会返回失败
func (m *ItemLocalManager) DeleteItemLocal(cls *protocol.ItemLocal) error {
	if cls == nil {
		return persistCore.EPersistErrorNil
	}

	if m.LoadState(cls.Uid) != EItemLocalLoadStateMemory {
		return persistCore.EPersistErrorNotInMemory
	}

	p := m.GetItemLocalByUidItemId(cls.Uid, cls.ItemId)
	if p == nil || p != cls {
		return persistCore.EPersistErrorOutOfDate
	}

	m.removeItemLocal(cls)

	// 主键不能修改
	bitSet := ItemLocalBitSet{}
	bitSet.SetAll()
	newCls := m.acquireDeepCopyObject(cls)

	persistSync := &ItemLocalSync{Data: newCls, Op: EItemLocalOpDelete, BitSet: bitSet}

	log.Println("[sql trace ItemLocal]", m.PersistSyncToString(persistSync))

	m.syncChan <- persistSync

	return nil
}

// DeleteAll 删除所有对象并异步写回数据库
func (m *ItemLocalManager) DeleteAll() {

	var tmpItemLocalList []*protocol.ItemLocal
	m.hashUidItemId.Range(func(k ItemLocalKeyTypeHashUidItemId, v *protocol.ItemLocal) bool {
		tmpItemLocalList = append(tmpItemLocalList, v)
		return true
	})
	for _, cls := range tmpItemLocalList {
		if cls == nil {
			continue
		}
		m.removeItemLocal(cls)

		// 主键不能修改
		bitSet := ItemLocalBitSet{}
		bitSet.SetAll()
		newCls := m.acquireDeepCopyObject(cls)

		persistSync := &ItemLocalSync{Data: newCls, Op: EItemLocalOpDelete, BitSet: bitSet}

		log.Println("[sql trace ItemLocal]", m.PersistSyncToString(persistSync))

		m.syncChan <- persistSync

	}
}

// EOptimizeFlagUsePoolAndDisableDeleteUnload 优化下不支持修改索引

// 不建议修改索引列

// MarkUpdate 标记脏对象并异步写回数据库, (1 数据没有导入或已经导出, 2 数据已经重新导入, 3 对象为空) 会返回失败
func (m *ItemLocalManager) MarkUpdate(cls *protocol.ItemLocal) error {
	if cls == nil {
		return persistCore.EPersistErrorNil
	}

	if m.LoadState(cls.Uid) != EItemLocalLoadStateMemory {
		return persistCore.EPersistErrorNotInMemory
	}

	p := m.GetItemLocalByUidItemId(cls.Uid, cls.ItemId)
	if p == nil || p != cls {
		return persistCore.EPersistErrorOutOfDate
	}

	m.InitDS(cls)
	bitSet := ItemLocalBitSet{}
	bitSet.SetAll()
	newCls := m.acquireDeepCopyObject(cls)

	persistSync := &ItemLocalSync{Data: newCls, Op: EItemLocalOpUpdate, BitSet: bitSet}

	log.Println("[sql trace ItemLocal]", m.PersistSyncToString(persistSync))

	m.syncChan <- persistSync

	return nil
}

// MarkUpdateByBitSet 标记脏对象并异步写回数据库, (1 数据没有导入或已经导出, 2 数据已经重新导入, 3 对象为空) 会返回失败
func (m *ItemLocalManager) MarkUpdateByBitSet(cls *protocol.ItemLocal, bitSet ItemLocalBitSet) error {
	if cls == nil {
		return persistCore.EPersistErrorNil
	}

	if m.LoadState(cls.Uid) != EItemLocalLoadStateMemory {
		return persistCore.EPersistErrorNotInMemory
	}

	p := m.GetItemLocalByUidItemId(cls.Uid, cls.ItemId)
	if p == nil || p != cls {
		return persistCore.EPersistErrorOutOfDate
	}

	m.InitDS(cls)

	newCls := m.acquireDeepCopyObject(cls)

	persistSync := &ItemLocalSync{Data: newCls, Op: EItemLocalOpUpdate, BitSet: bitSet}

	log.Println("[sql trace ItemLocal]", m.PersistSyncToString(persistSync))

	m.syncChan <- persistSync

	return nil
}

// MarkUpdateByFieldIndex 标记脏对象并异步写回数据库, (1 数据没有导入或已经导出, 2 数据已经重新导入, 3 对象为空) 会返回失败
func (m *ItemLocalManager) MarkUpdateByFieldIndex(cls *protocol.ItemLocal, fieldIndex ItemLocalFieldIndex) error {
	return m.MarkUpdateByBitSet(cls, *((&ItemLocalBitSet{}).Set(fieldIndex)))
}

// GetItemLocalByUidItemId 通过索引查找对象
func (m *ItemLocalManager) GetItemLocalByUidItemId(Uid int32, ItemId int32) *protocol.ItemLocal {

	if data, ok := m.hashUidItemId.Load(ItemLocalKeyTypeHashUidItemId{Uid, ItemId}); ok {
		return data
	}
	return nil
}

// GetItemLocalsByUid 通过索引查找对象
func (m *ItemLocalManager) GetItemLocalsByUid(Uid int32) (ret []*protocol.ItemLocal) {

	if data, ok := m.hashUid.Load(ItemLocalKeyTypeHashUid{Uid}); ok {
		data.Range(func(k *protocol.ItemLocal, v bool) bool {
			ret = append(ret, k)
			return true
		})
	}
	return
}

// GetAll 通过主键查找所有对象
func (m *ItemLocalManager) GetAll() (ret []*protocol.ItemLocal) {

	m.hashUidItemId.Range(func(k ItemLocalKeyTypeHashUidItemId, v *protocol.ItemLocal) bool {
		ret = append(ret, v)
		return true
	})
	return
}

// LoadAllState 所有数据导入状态
func (m *ItemLocalManager) LoadAllState() int32 {
	return atomic.LoadInt32(&m.loadAll)
}

// LoadAll (非线程安全) 导入所有数据, 全导入后只能全导出, 不能再按照key导入导出
func (m *ItemLocalManager) LoadAll() (err error) {
	log.Println("ItemLocalManager LoadAll begin")
	// 未全导入状态切换到全导入
	if atomic.CompareAndSwapInt32(&m.loadAll, EItemLocalTableStateDisk, EItemLocalTableStateLoading) {
		rows := make([]*protocol.ItemLocal, 0)
		err = m.engine.Find(&rows, gItemLocalNil)
		if err != nil {
			atomic.StoreInt32(&m.loadAll, EItemLocalTableStateDisk)
			return err
		} else {

			for _, row := range rows {
				m.addItemLocal(row)
			}
			atomic.StoreInt32(&m.loadAll, EItemLocalTableStateMemory)
		}
	} else {
		return persistCore.EPersistErrorIncorrectState
	}
	log.Println("ItemLocalManager LoadAll end")
	return
}

// LoadState 查询包含该key的数据导入状态
func (m *ItemLocalManager) LoadState(Uid int32) int32 {
	if atomic.LoadInt32(&m.loadAll) == EItemLocalTableStateDisk {
		if value, ok := m.loadUidMap.Load(Uid); ok {
			state := value
			return atomic.LoadInt32(state)
		} else {
			return EItemLocalLoadStateDisk
		}
	} else {
		return EItemLocalLoadStateMemory
	}
}

// SetLoadState2Memory 没有数据时, 标记数据在内存中. 仅用于第一次数据库导入空数据, 错误使用会导致未定义的行为
func (m *ItemLocalManager) SetLoadState2Memory(Uid int32) {
	if atomic.LoadInt32(&m.loadAll) == EItemLocalTableStateDisk {
		p := int32(EItemLocalLoadStateMemory)
		m.loadUidMap.Store(Uid, &p)
	} else {
	}
}

// Load 按照key导入数据, 必须存在unload key的索引
func (m *ItemLocalManager) Load(Uid int32) (err error) {
	// LoadAll后不能再次Load
	if atomic.LoadInt32(&m.loadAll) == EItemLocalTableStateDisk {
		p := int32(0)
		value, _ := m.loadUidMap.LoadOrStore(Uid, &p)
		state := value
		// 检查导入状态
		switch atomic.LoadInt32(state) {
		// 未导入状态切换到导入
		case EItemLocalLoadStateDisk:
			if atomic.CompareAndSwapInt32(state, EItemLocalLoadStateDisk, EItemLocalLoadStateLoading) {
				rows := make([]*protocol.ItemLocal, 0)
				err = m.engine.Find(&rows, &protocol.ItemLocal{Uid: Uid})

				if err != nil { // 导入失败, 状态回到导出
					atomic.StoreInt32(state, EItemLocalLoadStateDisk)
				} else {

					for _, row := range rows {
						m.addItemLocal(row)
					}
					atomic.StoreInt32(state, EItemLocalLoadStateMemory)
				}
				return
			} else { // 期间状态变化,不确定操作是否成功
				return persistCore.EPersistErrorUnknownError
			}

		case EItemLocalLoadStateLoading: // 正在导入
			// 并发导入暂时轮询等待
			bTime := time.Now().Unix()
			for {
				if atomic.LoadInt32(state) != EItemLocalLoadStateLoading {
					break
				}
				if time.Now().Unix() > bTime+persistCore.ELoadPollingTimeOut {
					break
				}
				time.Sleep(time.Millisecond * 100)
			}
			if atomic.LoadInt32(state) == EItemLocalLoadStateMemory {
				return
			} else {
				return persistCore.EPersistErrorUnknownError
			}

		case EItemLocalLoadStateMemory: // 导入完成
			return

		case EItemLocalLoadStatePrepareUnloading: // 准备导出,立即取消导出
			if atomic.CompareAndSwapInt32(state, EItemLocalLoadStatePrepareUnloading, EItemLocalLoadStateMemory) {
				return
			} else { // 期间状态变化,不确定操作是否成功
				return persistCore.EPersistErrorUnknownError
			}

		case EItemLocalLoadStateUnloading: // 正在导出
			return persistCore.EPersistErrorUnloading
		default: // ???
			return persistCore.EPersistErrorUnknownError
		}
	} else {
		return
	}
}

// UnloadAll (非线程安全) 导出所有数据, 调用UnloadAll后,不允许再修改相关的数据(必须先导入才能修改数据)
func (m *ItemLocalManager) UnloadAll() (err error) {
	var clsList []*protocol.ItemLocal
	// 未导入状态切换到导入
	if atomic.CompareAndSwapInt32(&m.loadAll, EItemLocalTableStateMemory, EItemLocalTableStateUnloading) {

		m.hashUidItemId.Range(func(k ItemLocalKeyTypeHashUidItemId, v *protocol.ItemLocal) bool {
			clsList = append(clsList, v)
			return true
		})
		for _, cls := range clsList {
			m.removeItemLocal(cls)
		}
		atomic.StoreInt32(&m.loadAll, EItemLocalTableStateDisk)
	} else {
		return persistCore.EPersistErrorIncorrectState
	}
	return
}

// Unload 按照key导出数据, 必须存在unload key的索引. 调用Unload后,不允许再修改相关的数据(必须先导入才能修改数据).
func (m *ItemLocalManager) Unload(Uid int32) (err error) {

	// LoadAll后不能unload
	if atomic.LoadInt32(&m.loadAll) == EItemLocalTableStateDisk {
		if value, ok := m.loadUidMap.Load(Uid); ok {
			state := value

			switch atomic.LoadInt32(state) {
			case EItemLocalLoadStateDisk: // 未导入
				return //persistCore.EPersistErrorNotInMemory
			case EItemLocalLoadStateLoading: // 正在导入
				return persistCore.EPersistErrorLoading
			case EItemLocalLoadStateMemory: // 导入完成, 开始导出吧
				if atomic.CompareAndSwapInt32(state, EItemLocalLoadStateMemory, EItemLocalLoadStatePrepareUnloading) {
					m.syncChan <- &ItemLocalSync{Data: &protocol.ItemLocal{Uid: Uid}, Op: EItemLocalOpUnload}
					return
				} else { // 期间状态变化,不确定操作是否成功
					return persistCore.EPersistErrorUnknownError
				}
			case EItemLocalLoadStatePrepareUnloading: // 准备导出, 立即取消导出
				return //persistCore.EPersistErrorAlreadyUnload
			case EItemLocalLoadStateUnloading: // 正在导出, 导入失败
				return //persistCore.EPersistErrorUnloading
			default:
				return persistCore.EPersistErrorUnknownError
			}
		} else {
			return //persistCore.EPersistErrorNotInMemory
		}
	} else {
		return persistCore.EPersistErrorAlreadyLoadAll
	}

}

// unload (非线程安全) 按照key导出数据, 必须存在unload key的索引. 调用Unload后,不允许再修改相关的数据(必须先导入才能修改数据).
func (m *ItemLocalManager) unload(Uid int32) {

	for _, cls := range m.GetItemLocalsByUid(Uid) {
		m.removeItemLocal(cls)
	}

}

var GItemLocalManager *ItemLocalManager

// init 注册管理类
func init() {

	if GetDB == nil {
		log.Println(persistCore.EPersistErrorEngineNil)
		persistCore.RegisterPersistLazy("ItemLocal", GItemLocalManager)
		return
	}
	engine := GetDB()
	if engine == nil {
		log.Println(persistCore.EPersistErrorEngineNil)
		return
	}
	GItemLocalManager = NewItemLocalManager(engine)
	Register("ItemLocal", GItemLocalManager)
	// go GItemLocalManager.Collect()

	//for idx, name := range ItemLocalStructFiledMap {
	//	ItemLocalDBFiledMap[idx] = engine.GetColumnMapper().Obj2Table(name)
	//}

}

// LazyInit 惰性创建注册初始化
func (m *ItemLocalManager) LazyInit() (err error) {

	if GetDB == nil {
		err = errors.New("GetDB is nil")
		return
	}
	engine := GetDB()
	if engine == nil {
		err = errors.New("engine is nil")
		return
	}
	GItemLocalManager = NewItemLocalManager(engine)
	Register("ItemLocal", GItemLocalManager)

	return
}

// noneFunc 惰性创建注册初始化
func (m *ItemLocalManager) noneFunc() {
	math.Abs(1.0)
	_ = jsoniter.ConfigCompatibleWithStandardLibrary
	_ = json.Marshal
	_ = sync.Mutex{}
	_ = reflect.Value{}
	_ = time.Now()
	_ = sentry.Client{}
	_ = strings.Builder{}
	log.Println("none")
}

// SaveDB xorm写数据库
func (m *ItemLocalManager) SaveDB(session *xorm.Session, persistSync *ItemLocalSync) (err error) {
	defer func() {
		if r := recover(); r != nil {
			log.Println("recovered in ", r)
			log.Println("stack: ", string(debug.Stack()))
			if err == nil {
				err = errors.New("unknown error")
			}
		}
	}()
	switch persistSync.Op {
	case EItemLocalOpInsert:

		_, err = session.Insert(persistSync.Data)

		if err != nil {
			log.Println("insert error ", err, "[sql error ItemLocal]", m.PersistSyncToString(persistSync))
			return
		}

	case EItemLocalOpUpdate:
		cls := persistSync.Data
		bitSet := persistSync.BitSet
		if bitSet.IsSetAll() {
			_, err = session.ID(core.NewPK(cls.Uid, cls.ItemId)).AllCols().Update(cls)
			if err != nil {
				log.Println("update error ", err, "[sql error ItemLocal]", m.PersistSyncToString(persistSync))
				return
			}
		} else {
			var nameList []string
			for idx, name := range ItemLocalDBFiledMap {
				if bitSet.Get(ItemLocalFieldIndex(idx)) {
					nameList = append(nameList, name)
				}
			}
			if nameList != nil {
				_, err = session.ID(core.NewPK(cls.Uid, cls.ItemId)).Cols(nameList...).Update(cls)
				if err != nil {
					log.Println("update error ", err, "[sql error ItemLocal]", m.PersistSyncToString(persistSync))
					return
				}
			} else {
				_, err = session.ID(core.NewPK(cls.Uid, cls.ItemId)).AllCols().Update(cls)
				if err != nil {
					log.Println("update error ", err, "[sql error ItemLocal]", m.PersistSyncToString(persistSync))
					return
				}
			}
		}

	case EItemLocalOpDelete:
		cls := persistSync.Data
		_, err = session.ID(core.NewPK(cls.Uid, cls.ItemId)).Delete(gItemLocalNil)
		if err != nil {
			log.Println("delete error ", err, "[sql error ItemLocal]", m.PersistSyncToString(persistSync))
			return
		}

	case EItemLocalOpUnload:
		cls := persistSync.Data
		Uid := cls.Uid
		if value, ok := m.loadUidMap.Load(Uid); ok {
			state := value
			// 准备导出,  不中断的清理玩家数据
			// warning 导出后又修改, 不保证数据一致性
			if atomic.CompareAndSwapInt32(state, EItemLocalLoadStatePrepareUnloading, EItemLocalLoadStateUnloading) {
				m.unload(Uid)
				m.loadUidMap.Delete(Uid)
				atomic.StoreInt32(state, EItemLocalLoadStateDisk)
			} else {
				// 0:导出  1:导入开始  2:导入完成  4:正在导出  不确定状态
				// 以上状态跳过吧
			}
		} else {
			// 不存在的玩家,跳过吧
		}

	}
	return
}

// DataToFailQueue 未写入成功数据, 添加到失败队列
func (m *ItemLocalManager) DataToFailQueue() {
	var persistSync *ItemLocalSync

	// 一旦失败标记所有的数据都是失败, 不允许导出

	m.FailQueue = append(m.FailQueue, m.InsertQueue...)
	m.InsertQueue = m.InsertQueue[0:0]

	for i := 0; i < len(*m.syncQueue); i++ {
		persistSync = (*m.syncQueue)[i]
		switch persistSync.Op {
		case EItemLocalOpInsert, EItemLocalOpUpdate, EItemLocalOpDelete:
			m.FailQueue = append(m.FailQueue, persistSync)

		case EItemLocalOpUnload:
			// 导出状态还原
			cls := persistSync.Data
			Uid := cls.Uid
			if value, ok := m.loadUidMap.Load(Uid); ok {
				state := value
				// 导出失败状态回退
				if atomic.CompareAndSwapInt32(state, EItemLocalLoadStatePrepareUnloading, EItemLocalLoadStateMemory) {
				} else {
				}
			}

		default:
		}
	}
	*m.syncQueue = (*m.syncQueue)[0:0]
}

// LoadFile 文件读取写回失败数据
func (m *ItemLocalManager) LoadFile() error {
	bombExist := util.Exists("_./_Users_anniext_project_persist_data/ItemLocal.bomb")
	tmpExist := util.Exists("_./_Users_anniext_project_persist_data/ItemLocal.tmp")

	if tmpExist {
		return persistCore.EPersistErrorTempFileExist
	}

	if bombExist {
		data, err := ioutil.ReadFile("_./_Users_anniext_project_persist_data/ItemLocal.bomb")
		if err != nil {
			return err
		}
		pos := bytes.IndexByte(data, byte(' '))
		if pos == -1 {
			return persistCore.EPersistErrorInvalidBombFile
		}
		persistData := data[pos+1:]
		err = m.UnmarshalFailQueue(persistData, &m.FailQueue)
		if err != nil {
			return err
		}

		session := m.engine.NewSession()
		defer session.Close()

		var persistSync *ItemLocalSync

		for i := range m.FailQueue {
			persistSync = m.FailQueue[i]
			err = m.SaveDB(session, persistSync)
			if err != nil {
				m.FailQueue = m.FailQueue[i:]
				m.SaveFile()
				return err
			}
		}
		m.FailQueue = m.FailQueue[0:0]
		m.RemoveFile()

	}
	return nil
}

// SaveFile 写回失败,记录数据,写文件,等待下次写回
func (m *ItemLocalManager) SaveFile() {

	m.DataToFailQueue()

	data, err := m.MarshalFailQueue(m.FailQueue)
	if err != nil {
		log.Println("SaveFile marshal error ", err)
	}
	_ = os.Mkdir("_./_Users_anniext_project_persist_data", 0770)
	err = ioutil.WriteFile("_./_Users_anniext_project_persist_data/ItemLocal.tmp", append([]byte("ItemLocal "), data...), 0660)
	if err != nil {
		log.Println("SaveFile write temp file error ", err)
	}
	err = ioutil.WriteFile("_./_Users_anniext_project_persist_data/ItemLocal.bomb", append([]byte("ItemLocal "), data...), 0660)
	if err != nil {
		log.Println("SaveFile write bomb file error ", err)
	}
	_ = os.Remove("_./_Users_anniext_project_persist_data/ItemLocal.tmp")
}

// RemoveFile 删除写回失败文件
func (m *ItemLocalManager) RemoveFile() {
	_ = os.Remove("_./_Users_anniext_project_persist_data/ItemLocal.tmp")
	_ = os.Remove("_./_Users_anniext_project_persist_data/ItemLocal.bomb")
	_ = os.Remove("_./_Users_anniext_project_persist_data")
}

// RecoverBomb bomb数据写入数据库
func (m *ItemLocalManager) RecoverBomb(bomb []byte) (err error) {
	var persistSync *ItemLocalSync
	var failQueue []*ItemLocalSync
	session := m.engine.NewSession()
	defer session.Close()
	err = m.UnmarshalFailQueue(bomb, &failQueue)
	if err != nil {
		return
	}
	var i int
	for i = range failQueue {
		persistSync = failQueue[i]
		err = m.SaveDB(session, persistSync)
		if err != nil {
			break
		}
	}
	if len(failQueue)-1 > i {
		data, _ := m.MarshalFailQueue(failQueue[i:])
		_, _ = os.Stdout.Write([]byte("ItemLocal "))
		_, _ = os.Stdout.Write(data)
	}
	return
}

// RecoverTrace trace数据写入数据库
func (m *ItemLocalManager) RecoverTrace(trace [][]byte) (err error) {
	var persistSync *ItemLocalSync
	var traceQueue []*ItemLocalSync
	var insertQueue []*ItemLocalSync

	for i := 0; i < len(trace); i++ {
		persistSync = m.StringToPersistSync(string(trace[i]))
		if persistSync.Op == EItemLocalOpInsert {
			insertQueue = append(insertQueue, persistSync)
		} else {
			traceQueue = append(traceQueue, persistSync)
		}
	}

	insertQueue2, otherQueue := m.MergeQueue(traceQueue, false)
	for _, insertItem := range insertQueue2 {
		insertQueue = append(insertQueue, insertItem)
	}

	session := m.engine.NewSession()
	defer session.Close()

	var i int
	for i = range insertQueue {
		persistSync = insertQueue[i]
		_ = m.SaveDB(session, persistSync)
	}
	for i = range otherQueue {
		persistSync = otherQueue[i]
		_ = m.SaveDB(session, persistSync)
	}
	return
}

// MergeQueue 内存中合并操作
func (m *ItemLocalManager) MergeQueue(q []*ItemLocalSync, copyAll bool) (insertQueue, otherQueue []*ItemLocalSync) {

	var currentPersistSync *ItemLocalSync
	var oldPersistSync *ItemLocalSync
	var ok bool

	var unloadList []*ItemLocalSync

	// 合并可能失败, persistSyncMap必须创建副本
	persistSyncMap := map[ItemLocalUidItemId]*ItemLocalSync{}

	//unload 按照顺序强制移到最后
	//insert update delete 按照主键合并
	lenSyncQueue := len(q)
	fail := false

LabelForSyncQueue:
	for i := 0; i < lenSyncQueue; i++ {
		currentPersistSync = q[i]
		pk := ItemLocalUidItemId{

			Uid: currentPersistSync.Data.Uid,

			ItemId: currentPersistSync.Data.ItemId,
		}
		// 导出特殊处理
		if currentPersistSync.Op == EItemLocalOpUnload {
			unloadList = append(unloadList, currentPersistSync)
			continue
		}
		// 第一次出现直接拷贝
		if oldPersistSync, ok = persistSyncMap[pk]; !ok {
			persistSyncMap[pk] = &ItemLocalSync{Data: currentPersistSync.Data, Op: currentPersistSync.Op, BitSet: currentPersistSync.BitSet}
			continue
		}

		switch oldPersistSync.Op {
		case EItemLocalOpInsert:
			switch currentPersistSync.Op {
			case EItemLocalOpInsert:
				fail = true
				break LabelForSyncQueue
			case EItemLocalOpUpdate:
				oldPersistSync.Op = EItemLocalOpInsert
				if copyAll {
					oldPersistSync.Data = currentPersistSync.Data
				} else {
					m.PersistToPersistByBitSet(oldPersistSync.Data, currentPersistSync.Data, currentPersistSync.BitSet)
				}
				oldPersistSync.BitSet.SetAll()
			case EItemLocalOpDelete:
				delete(persistSyncMap, pk)
			}
		case EItemLocalOpUpdate:
			switch currentPersistSync.Op {
			case EItemLocalOpInsert:
				fail = true
				break LabelForSyncQueue
			case EItemLocalOpUpdate:
				oldPersistSync.Op = EItemLocalOpUpdate
				if copyAll {
					oldPersistSync.Data = currentPersistSync.Data
				} else {
					m.PersistToPersistByBitSet(oldPersistSync.Data, currentPersistSync.Data, currentPersistSync.BitSet)
				}
				oldPersistSync.BitSet.Merge(currentPersistSync.BitSet)
			case EItemLocalOpDelete:
				oldPersistSync.Op = EItemLocalOpDelete
				oldPersistSync.Data = currentPersistSync.Data
				oldPersistSync.BitSet.ClearAll()
			}
		case EItemLocalOpDelete:
			switch currentPersistSync.Op {
			case EItemLocalOpInsert:
				oldPersistSync.Op = EItemLocalOpUpdate
				oldPersistSync.Data = currentPersistSync.Data
				oldPersistSync.BitSet.SetAll()
			case EItemLocalOpUpdate:
				fail = true
				break LabelForSyncQueue
			case EItemLocalOpDelete:
				fail = true
				break LabelForSyncQueue
			}
		}
	}
	// 遇到错误取消合并
	if fail {
		otherQueue = q
		return
	}

	// 清空队列 该函数无副作用，需要外部自行清理

	// 按照合并内容重建队列, 插入特殊处理
	for _, persistSync := range persistSyncMap {
		if persistSync.Op == EItemLocalOpInsert {
			insertQueue = append(insertQueue, persistSync)
		} else {
			otherQueue = append(otherQueue, persistSync)
		}
	}

	for _, persistSync := range unloadList {
		otherQueue = append(otherQueue, persistSync)
	}

	return
}

// Save 异步写回
func (m *ItemLocalManager) Save() {
	var exit bool
	for {
		// 正常退出
		exit = m.AsyncSave()
		if exit {
			break
		}
	}
}

// AsyncSave 异步写回
func (m *ItemLocalManager) AsyncSave() (exit bool) {
	var persistSync *ItemLocalSync
	var err error
	var queueEmpty bool
	bTime := time.Now().UnixNano()
	defer func() {
		if r := recover(); r != nil {
			log.Println("recovered in ", r)
			log.Println("stack: ", string(debug.Stack()))
			if !queueEmpty {
				log.Println("save failed: incrementalSave")
			}
		} else {
			if !queueEmpty {
				if err == nil {
					log.Println("save success: incrementalSave")
				} else {
					log.Println("save failed: incrementalSave")
				}
			}
		}
		m.DataToFailQueue()
		m.lastWriteBackTime = time.Duration(time.Now().UnixNano() - bTime)
		m.syncEnd <- true
	}()

	needCollect := <-m.syncBegin
	if len(*m.syncQueue) == 0 {
		queueEmpty = true
		if needCollect {
			time.Sleep(time.Millisecond * 100)
		} else {
			exit = true
		}
		return
	}
	session := m.engine.NewSession()
	defer session.Close()

	log.Println("begin incrementalSave", bTime)

	if len(m.FailQueue) > 0 {
		tmpQueue := make([]*ItemLocalSync, len(m.FailQueue)+len(*m.syncQueue))
		copy(tmpQueue, m.FailQueue)
		copy(tmpQueue[len(m.FailQueue):], *m.syncQueue)
		insertQueue, otherQueue := m.MergeQueue(tmpQueue, true)
		m.syncQueue = &otherQueue
		m.InsertQueue = insertQueue
		m.FailQueue = m.FailQueue[0:0]
	} else {
		insertQueue, otherQueue := m.MergeQueue(*m.syncQueue, true)
		m.syncQueue = &otherQueue
		m.InsertQueue = insertQueue
	}

	multiInsertFn := func() bool {
		var err error
		defer func() {
			if r := recover(); r != nil {
				_ = session.Rollback()
			} else {
				if err == nil {
					m.InsertQueue = m.InsertQueue[0:0]
				} else {
					_ = session.Rollback()
				}
			}
		}()

		if len(m.InsertQueue) <= 0 {
			return true
		}
		err = session.Begin()
		if err != nil {
			return false
		}

		const num = 100
		var insertArray [num]*protocol.ItemLocal
		length := len(m.InsertQueue)
		quotient := length / num
		remainder := length % num
		for i := 0; i < quotient; i++ {
			//fmt.Println("queue->(", i*num, "-", (i+1)*num, "): ", m.InsertQueue[i*num:(i+1)*num])
			for j := 0; j < num; j++ {
				insertArray[j] = m.InsertQueue[i*num+j].Data
			}

			_, err = session.InsertMulti(insertArray[:])

			if err != nil {
				log.Println("InsertMulti error ", err)
				return false
			}
		}
		if remainder != 0 {
			//fmt.Println("queue->(", quotient*num, "-", length, "): ", m.InsertQueue[quotient*num:length])

			insertArray = [num]*protocol.ItemLocal{}
			for j := 0; j < remainder; j++ {
				insertArray[j] = m.InsertQueue[quotient*num+j].Data
			}

			_, err = session.InsertMulti(insertArray[:remainder])

			if err != nil {
				log.Println("InsertMulti error ", err)
				return false
			}
		}
		err = session.Commit()
		if err != nil {
			return false
		}
		return true
	}

	multiInsertSuccess := multiInsertFn()

	// 批量插入失败, 改为单条插入
	if !multiInsertSuccess {
		for idx, persistSync := range m.InsertQueue {
			err = m.SaveDB(session, persistSync)
			if err != nil {
				m.InsertQueue = m.InsertQueue[idx:]
				m.SaveFile()
				return
			}
		}
		m.InsertQueue = m.InsertQueue[0:0]
	}

	for i := 0; i < len(*m.syncQueue); i++ {
		persistSync = (*m.syncQueue)[i]
		err = m.SaveDB(session, persistSync)
		if err != nil {
			*m.syncQueue = (*m.syncQueue)[i:]
			m.SaveFile()
			return
		}
	}
	*m.syncQueue = (*m.syncQueue)[0:0]
	m.RemoveFile()
	return
}

// Collect 收集数据
func (m *ItemLocalManager) Collect() {
	var persistSync *ItemLocalSync
	var ok bool
	// 0:normal  1:exit begin, save sync  2:save cache  3:save done
	var state int8
	go m.Save()
	m.syncBegin <- true
	for {
		select {
		case persistSync, ok = <-m.syncChan:
			if ok {
				*m.cacheQueue = append(*m.cacheQueue, persistSync)
			}
		case _, ok = <-m.syncEnd:
			if ok {
				m.CheckOverload()
				m.cacheQueue, m.syncQueue = m.syncQueue, m.cacheQueue
				switch state {
				case EItemLocalCollectStateNormal:
					//go m.AsyncSave()
					m.syncBegin <- true
				case EItemLocalCollectStateSaveSync:
					//go m.AsyncSave()
					m.syncBegin <- true
					state = EItemLocalCollectStateSaveCache
				case EItemLocalCollectStateSaveCache:
					//go m.AsyncSave()
					m.syncBegin <- true
					state = EItemLocalCollectStateSaveDone
				case EItemLocalCollectStateSaveDone:
					m.syncBegin <- false
					<-m.syncEnd
					m.exitEnd <- true
					return
				}
			}
		case _, ok = <-m.exitBegin:
			if ok {
				state = EItemLocalCollectStateSaveSync
			}
			//default:
			//	time.Sleep(time.Second/10)
		}
	}
}

// Exit 管理类退出
func (m *ItemLocalManager) Exit(wg *sync.WaitGroup) {
	defer wg.Done()

	if atomic.LoadInt32(&m.managerState) != EItemLocalManagerStateNormal {
		return
	}

	m.exitBegin <- true
	<-m.exitEnd
	atomic.StoreInt32(&m.managerState, EItemLocalManagerStateIdle)
	return
}

// Sync 数据库表结构同步
func (m *ItemLocalManager) Sync(wg *sync.WaitGroup) (err error) {
	defer wg.Done()

	err = m.engine.Sync2(gItemLocalNil)

	return
}

// Segmentation 检查是否需要换表 如果需要换表 则根据时间 和切换间隔计算是否需要换表 否则为不处理
func (m *ItemLocalManager) Segmentation(wg *sync.WaitGroup) (err error) {
	defer wg.Done()
	return
}

// compareAndUpdate 比较数据库，不相同则更新
func (m *ItemLocalManager) compareAndUpdate(session *xorm.Session, cls *protocol.ItemLocal, sentryDebug bool) (err error) {
	update := func(session *xorm.Session, cls *protocol.ItemLocal, memData, dbData string) {
		log.Println("SyncData error. missing mark Mem. [sql error ItemLocal]", memData)
		log.Println("SyncData error. missing mark  Db. [sql error ItemLocal]", dbData)
		_, err = session.ID(core.NewPK(cls.Uid, cls.ItemId)).AllCols().Update(cls)
		if err != nil {
			log.Println("SyncData update error.", err, "[sql error ItemLocal]", m.PersistSyncToString(&ItemLocalSync{
				Data:   cls,
				Op:     EItemLocalOpUpdate,
				BitSet: m.bitSetAll,
			}))
			return
		}
	}
	resetTimeNSec := func(clsMem, clsDb *protocol.ItemLocal) {
		defer func() {
			if r := recover(); r != nil {
				log.Println("recovered in ", r)
				log.Println("stack: ", string(debug.Stack()))
			}
		}()
		typeF := reflect.TypeOf(*clsMem)
		valueMemF := reflect.ValueOf(clsMem).Elem()
		valueDbF := reflect.ValueOf(clsDb).Elem()
		for i := 0; i < typeF.NumField(); i++ {
			if typeF.Field(i).Type.Name() == "Time" {
				f := valueMemF.Field(i)
				if f.CanInterface() {
					v := time.Unix(f.Interface().(time.Time).Unix(), 0)
					f.Set(reflect.ValueOf(v))
				}
				vMem := valueMemF.Field(i).Interface().(time.Time)
				vDb := valueDbF.Field(i).Interface().(time.Time)
				if vMem.Equal(vDb) {
					f.Set(reflect.ValueOf(vDb))
				}
			}
		}
	}

	dbCls := &protocol.ItemLocal{

		Uid: cls.Uid,

		ItemId: cls.ItemId,
	}
	var has bool
	has, err = session.Get(dbCls)
	if err != nil || !has {
		log.Println("SyncData query error.", err, "[sql error ItemLocal]", m.PersistSyncToString(&ItemLocalSync{
			Data:   cls,
			Op:     0,
			BitSet: m.bitSetAll,
		}))
		return
	}
	memCls := m.GetItemLocalByUidItemId(cls.Uid, cls.ItemId)
	if memCls != nil {
		resetTimeNSec(memCls, dbCls)
		memData := m.PersistSyncToString(&ItemLocalSync{
			Data:   memCls,
			Op:     0,
			BitSet: m.bitSetAll,
		})
		dbData := m.PersistSyncToString(&ItemLocalSync{
			Data:   dbCls,
			Op:     0,
			BitSet: m.bitSetAll,
		})
		// 数据库内存不一致
		if strings.Compare(memData, dbData) != 0 {
			if sentryDebug {
				func() {
					defer func() {
						memClsJson, _ := json.Marshal(&ItemLocalSync{
							Data:   memCls,
							Op:     0,
							BitSet: m.bitSetAll,
						})
						dbClsJson, _ := json.Marshal(&ItemLocalSync{
							Data:   dbCls,
							Op:     0,
							BitSet: m.bitSetAll,
						})
						sentry.WithScope(func(scope *sentry.Scope) {
							tag := "CompareError" + "ItemLocal"
							scope.SetTag(tag, "ItemLocal")
							scope.SetTag("transaction", "ItemLocal")
							scope.SetExtra("memClsJson", string(memClsJson))
							scope.SetExtra("dbClsJson", string(dbClsJson))
							sentry.CaptureMessage(tag)
						})
					}()
				}()
			}
			update(session, memCls, memData, dbData)
		}
	}
	return
}

// SyncData 全部内存数据写入数据库, 本接口耗时长,仅用于停服后.  补救没有标记写回数据(只处理未标记数据,New Delete不存在漏写)
func (m *ItemLocalManager) SyncData(wg *sync.WaitGroup, sentryDebug bool) (err error) {
	defer wg.Done()

	session := m.engine.NewSession()
	defer session.Close()

	if sentryDebug {
		func() {
			defer func() {
				for _, cls := range m.GetAll() {
					updateErr := m.compareAndUpdate(session, cls, sentryDebug)
					if updateErr != nil {
						err = updateErr
					}
				}
				if err != nil {
					sentry.WithScope(func(scope *sentry.Scope) {
						tagtag := "SyncDataError" + "ItemLocal"
						scope.SetTag("SyncDataError", "ItemLocal")
						scope.SetTag("transaction", "ItemLocal")
						scope.SetExtra(err.Error(), 1)
						sentry.CaptureMessage(tagtag)
					})
				}
			}()
		}()
	} else {
		for _, cls := range m.GetAll() {
			updateErr := m.compareAndUpdate(session, cls, sentryDebug)
			if updateErr != nil {
				err = updateErr
			}
		}
	}
	return

}

// SyncUserData 用户内存和数据库数据比较并更新, 不允许并发， 用于数据导出时，补救没有标记写回数据(只处理未标记数据,New Delete不存在漏写)
// sentryDebug debug模式下启用sentry
func (m *ItemLocalManager) SyncUserData(Uid int32, sentryDebug bool) (err error) {
	session := m.engine.NewSession()
	defer session.Close()
	var clsList []*protocol.ItemLocal

	// 业务代码必须保证，不使用正在导出的数据， 否则可能引发崩溃
	func() {
		defer func() {
			if r := recover(); r != nil {
				log.Println("recovered in ", r)
				log.Println("stack: ", string(debug.Stack()))
				err = errors.New("SyncUserData error")
			}
		}()

		for _, cls := range m.GetItemLocalsByUid(Uid) {
			clsList = append(clsList, m.acquireDeepCopyObject(cls))
		}

	}()

	if err != nil {
		return
	}

	for _, cls := range clsList {
		err = m.compareAndUpdate(session, cls, sentryDebug)
		if sentryDebug {
			func() {
				defer func() {
					if err != nil {
						sentry.WithScope(func(scope *sentry.Scope) {
							tagtag := "SyncDataError" + "ItemLocal"
							scope.SetTag("SyncDataError", "ItemLocal")
							scope.SetTag("transaction", "ItemLocal")
							scope.SetExtra(err.Error(), 1)
							sentry.CaptureMessage(tagtag)
						})
					}
				}()
			}()
		}
		if err != nil {
			return
		}
	}

	return

}

// object pool
