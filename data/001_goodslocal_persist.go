// Code generated by persist. DO NOT EDIT.
// source: bag.go

package data

import (
	"encoding/base64"
	"encoding/binary"
	"encoding/json"
	"math"
	"runtime/debug"

	"anniext.asia/xt/utils/log"
	jsoniter "github.com/json-iterator/go"
	"xorm.io/xorm"

	"reflect"
	"strings"
	"sync"
	"time"

	"github.com/getsentry/sentry-go"

	"bytes"
	"errors"

	"xorm.io/core"

	"io/ioutil"
	"os"
	"runtime"
	"sync/atomic"

	"anniext.asia/xt/utils/dir"
	"anniext.asia/xt/utils/recoverutils"

	persistCore "anniext.asia/xt/persist/core"

	"anniext.asia/xt/persist/protocol"
)

// 警告:
// 内部接口禁止调用(仅供内部 和 测试代码使用)
// SaveDB, DataToFailQueue, LoadFile, SaveFile, RemoveFile
// RecoverBomb, MergeQueue, AsyncSave, Collect, CheckOverload

// 工具接口, 无副作用, 按需使用
// BytesToPersist, PersistToBytes, PersistToPersistByBitSet, BytesToPersistSync, PersistSyncToBytes,
// StringToPersistSync, PersistSyncToString, UnmarshalFailQueue, MarshalFailQueue

// 需要先导入数据再使用
// 除以下接口不需要先导入, 其他接口必须 先导入! 先导入! 先导入!
// Run, Dead, Load LoadAll, Exit, Sync, SyncData(补救没有标记写回数据, 代码正确不需要使用)

// 其他接口
// New Delete 接口按需使用
// 尽量使用MarkUpdateByBitSet 多个修改一起提交
// 只修改单条数据使用MarkUpdateByFieldIndex
// 少用或者不用MarkUpdate 全标记开销太大, 除非业务太复杂想不清楚

// 支持 hash index:[group,unique], 不支持 tree index
// op 1:insert 2:update 3:delete 4:unload

// 对象序列化接口 string, slice, array, map json序列化,
// 第一版二进制结构：
// 		指针结构：含1字节标识位(0000 0001 是否nil) + 其他
// 		string, slice, map, 复杂结构， 结构体等： 4字节长度 + ToDB|json.Marshal长度
// 		其他简单基础结构：按照最大字节存储
// 		core.Conversion 只会检查指针 例如:
// 			(m *Persist) FromDB(data []byte) error
// 			(m *Persist) ToDB(data []byte, err error)
// 自定义解析字段， 暂时不允许是其他包的结构，分析引入关系比较复杂

// 待优化功能:
// 1: LoadMany方法, 一次导入多个玩家数据
// 2: 优化对象序列化大小，添加tag 一定程度兼容新旧结构, 支持更多的类型优化

const (
	EGoodsLocalManagerStateIdle   = 0 // 初始化
	EGoodsLocalManagerStateNormal = 1 // 正常运行
	EGoodsLocalManagerStatePanic  = 2 // 非法停止

	EGoodsLocalTableStateDisk      = 0 // 导出
	EGoodsLocalTableStateLoading   = 1 // 全导入开始
	EGoodsLocalTableStateMemory    = 2 // 全导入完成
	EGoodsLocalTableStateUnloading = 3 // 正在全导出

	EGoodsLocalLoadStateDisk             = 0 // 不存在 or 导出
	EGoodsLocalLoadStateLoading          = 1 // 导入开始
	EGoodsLocalLoadStateMemory           = 2 // 导入完成
	EGoodsLocalLoadStatePrepareUnloading = 3 // 准备导出
	EGoodsLocalLoadStateUnloading        = 4 // 正在导出

	EGoodsLocalOpInsert = 1 // 新建
	EGoodsLocalOpUpdate = 2 // 修改
	EGoodsLocalOpDelete = 3 // 删除
	EGoodsLocalOpUnload = 4 // 导出

	EGoodsLocalCollectStateNormal    = 0 // 正常
	EGoodsLocalCollectStateSaveSync  = 1 // 开始退出, 清理同步队列
	EGoodsLocalCollectStateSaveCache = 2 // 开始退出,清理缓存队列
	EGoodsLocalCollectStateSaveDone  = 3 // 写回完成

)

type GoodsLocal = protocol.GoodsLocal

// GoodsLocalDeepCopy persist对象必须支持并发访问, 不实现该接口默认深拷贝对象 (1 建议实现该接口,反射效率较低  2 map 建议生成syncmap  3 slice 建议深拷贝)
type GoodsLocalDeepCopy interface {
	CopyTo(t *protocol.GoodsLocal)
}

// GoodsLocalOverload 未落地数据超过阈值时调用
type GoodsLocalOverload interface {
	Overload(queueSize int, lastWriteBackTime time.Duration)
}

type GoodsLocalUid struct {
	Uid int32
}

type GoodsLocalKeyTypeHashUid = GoodsLocalUid

// GoodsLocalManager 索引类型定义

// only define type GoodsLocalHashUidMark map[GoodsLocalKeyTypeHashUid]bool

// only define type GoodsLocalHashUid map[GoodsLocalKeyTypeHashUid]*protocol.GoodsLocal

// GoodsLocalFieldIndex 所有列index枚举
// GoodsLocalBitSet begin
// 读ast计算FieldLength 生成所有字段常量 0~length
type GoodsLocalFieldIndex = uint

const EGoodsLocalFieldIndexZero GoodsLocalFieldIndex = 0

const EGoodsLocalFieldIndexUid GoodsLocalFieldIndex = 0

const EGoodsLocalFieldIndexTime GoodsLocalFieldIndex = 1

const EGoodsLocalFieldIndexName GoodsLocalFieldIndex = 2

const EGoodsLocalFiledIndexLength GoodsLocalFieldIndex = 3

var GoodsLocalStructFiledMap = [EGoodsLocalFiledIndexLength]string{
	"Uid",
	"Time",
	"Name",
}

var GoodsLocalDBFiledMap [EGoodsLocalFiledIndexLength]string

// EGoodsLocalWordSize the EGoodsLocalWordSize of a bit set
const EGoodsLocalWordSize = GoodsLocalFieldIndex(64)

// EGoodsLocalLog2WordSize is lg(EGoodsLocalWordSize)
const EGoodsLocalLog2WordSize = GoodsLocalFieldIndex(6)

// EGoodsLocalAllBits has every bit set
const EGoodsLocalAllBits uint64 = 0xffffffffffffffff

type GoodsLocalBitSet struct {
	set [(EGoodsLocalFiledIndexLength >> EGoodsLocalLog2WordSize) + 1]uint64
}

// Get whether bit i is set.
func (b *GoodsLocalBitSet) Get(i GoodsLocalFieldIndex) bool {
	if i >= EGoodsLocalFiledIndexLength {
		return false
	}
	return b.set[i>>EGoodsLocalLog2WordSize]&(1<<(i&(EGoodsLocalWordSize-1))) != 0
}

// Set bit i to 1
func (b *GoodsLocalBitSet) Set(i GoodsLocalFieldIndex) *GoodsLocalBitSet {
	if i >= EGoodsLocalFiledIndexLength {
		return nil
	}
	b.set[i>>EGoodsLocalLog2WordSize] |= 1 << (i & (EGoodsLocalWordSize - 1))
	return b
}

func (b *GoodsLocalBitSet) Clear(i GoodsLocalFieldIndex) *GoodsLocalBitSet {
	if i >= EGoodsLocalFiledIndexLength {
		return b
	}
	b.set[i>>EGoodsLocalLog2WordSize] &^= 1 << (i & (EGoodsLocalWordSize - 1))
	return b
}

// Merge compare to b
func (b *GoodsLocalBitSet) Merge(compare GoodsLocalBitSet) *GoodsLocalBitSet {
	for i, word := range b.set {
		b.set[i] = word | compare.set[i]
	}
	return b
}

func (b *GoodsLocalBitSet) ClearAll() *GoodsLocalBitSet {
	if b != nil {
		for i := range b.set {
			b.set[i] = 0
		}
	}
	return b
}

func (b *GoodsLocalBitSet) SetAll() *GoodsLocalBitSet {
	if b != nil {
		for i := range b.set {
			b.set[i] = EGoodsLocalAllBits
		}
	}
	return b
}

func (b *GoodsLocalBitSet) IsSetAll() bool {
	if b != nil {
		for i := range b.set {
			if b.set[i] != EGoodsLocalAllBits {
				return false
			}
		}
	}
	return true
}

// GoodsLocalBitSet end

// GoodsLocalSync 结构定义

type GoodsLocalSync struct {
	Data   *protocol.GoodsLocal
	Op     int8
	BitSet GoodsLocalBitSet
}

// GoodsLocalManager 结构定义

type GoodsLocalManager struct {

	// 0:初始化  1:正常运行  2:非法停止
	managerState int32
	// 0:导出  1:全导入开始  2:全导入完成  3:正在全导出
	loadAll int32

	// 不存在 or 0:导出  1:导入开始  2:导入完成  3:准备导出  4:正在导出
	loadUidMap GoodsLocalMapUnload // map[Uid]state(atom)

	pool              *sync.Pool
	syncChan          chan *GoodsLocalSync
	syncQueue         *[]*GoodsLocalSync
	cacheQueue        *[]*GoodsLocalSync
	FailQueue         []*GoodsLocalSync
	lastWriteBackTime time.Duration

	InsertQueue []*GoodsLocalSync

	syncBegin chan bool
	syncEnd   chan bool
	exitBegin chan bool
	exitEnd   chan bool

	engine *xorm.Engine

	hashUid GoodsLocalHashUid

	// hashUidMark GoodsLocalHashUidMark

	bitSetAll GoodsLocalBitSet
}

var gGoodsLocalNil = &protocol.GoodsLocal{}

func NewGoodsLocalManager(engine *xorm.Engine) (m *GoodsLocalManager) {
	m = &GoodsLocalManager{engine: engine}

	m.syncChan = make(chan *GoodsLocalSync, runtime.NumCPU()*2)
	tmpSyncQueue := make([]*GoodsLocalSync, 0)
	m.syncQueue = &tmpSyncQueue
	m.syncEnd = make(chan bool)
	m.syncBegin = make(chan bool)
	m.exitBegin = make(chan bool)
	m.exitEnd = make(chan bool)
	tmpCacheQueue := make([]*GoodsLocalSync, 0)
	m.cacheQueue = &tmpCacheQueue
	m.lastWriteBackTime = 1 * time.Millisecond
	m.pool = &sync.Pool{New: func() interface{} { return &protocol.GoodsLocal{} }}

	m.bitSetAll.SetAll()

	if engine != nil {
		for idx, name := range GoodsLocalStructFiledMap {
			GoodsLocalDBFiledMap[idx] = engine.GetColumnMapper().Obj2Table(name)
		}
	}

	return
}

// NewGoodsLocal 通过主键创建对象, 已经存在直接返回. (1 数据没有导入或已经导出) 会返回nil. (2 数据已存在) 返回已存在的值
func NewGoodsLocal(Uid int32) (ormCls *protocol.GoodsLocal) {

	if GGoodsLocalManager.LoadState(Uid) != EGoodsLocalLoadStateMemory {
		ormCls = nil
		return
	}

	ormCls = GGoodsLocalManager.GetGoodsLocalByUid(Uid)
	if ormCls != nil {
		return
	}
	ormCls, _ = GGoodsLocalManager.NewGoodsLocal(&protocol.GoodsLocal{Uid: Uid})
	return
}

// PersistName 返回persist类名
func (m *GoodsLocalManager) PersistName() string {
	return reflect.TypeOf(*gGoodsLocalNil).Name()
}

// PersistObj 返回persist interface{}
func (m *GoodsLocalManager) PersistUserNilObjInterface() interface{} {
	return &protocol.GoodsLocal{}
}

// PersistObj 返回persist interface{} list
func (m *GoodsLocalManager) PersistUserNilObjInterfaceList() interface{} {
	plist := make([]*protocol.GoodsLocal, 0, 0)
	return &plist
}

// Run 运行并导入上次失败数据
func (m *GoodsLocalManager) Run() error {
	if atomic.CompareAndSwapInt32(&m.managerState, EGoodsLocalManagerStateIdle, EGoodsLocalManagerStateNormal) {
		if err := m.LoadFile(); err != nil {
			return err
		}
		go m.Collect()
	} else if atomic.CompareAndSwapInt32(&m.managerState, EGoodsLocalManagerStatePanic, EGoodsLocalManagerStateNormal) {
		if err := m.LoadFile(); err != nil {
			return err
		}
		go m.Collect()
	} else {
	}
	return nil
}

// Dead 管理类是否出错
func (m *GoodsLocalManager) Dead() bool {
	return atomic.LoadInt32(&m.managerState) != EGoodsLocalManagerStateNormal
}

func (m *GoodsLocalManager) BytesToPersistInterface(data []byte) (cls interface{}) {
	return m.BytesToPersist(data)
}

// BytesToPersist反序列化
func (m *GoodsLocalManager) BytesToPersist(data []byte) (cls *protocol.GoodsLocal) {
	var err error
	if data == nil {
		return nil
	}
	defer func() {
		if r := recover(); r != nil {
			log.Infoln("recovered in ", r)
			log.Infoln("stack: ", string(debug.Stack()))
		}
		if err != nil {
			log.Infoln("BytesToPersist Error", err.Error())
		}
	}()
	i := 0
	cls = &protocol.GoodsLocal{}

	//Uid	int32

	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1

		cls.Uid = int32(binary.LittleEndian.Uint32(data[i:]))
		i += 32 / 8
	} else {
		i += 1
	}

	//Time	int64

	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1

		cls.Time = int64(binary.LittleEndian.Uint64(data[i:]))
		i += 64 / 8
	} else {
		i += 1
	}

	//Name	string

	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1

		lenFieldDataName := int(binary.LittleEndian.Uint32(data[i:]))
		i += 4
		cls.Name = string(data[i : i+lenFieldDataName])
		i += lenFieldDataName
	} else {
		i += 1
	}

	return
}

//

func (m *GoodsLocalManager) PersistInterfaceToBytes(i interface{}) (data []byte) {
	return m.PersistToBytes(i.(*protocol.GoodsLocal), m.bitSetAll)
}

func (m *GoodsLocalManager) PersistInterfaceToPkStruct(i interface{}) interface{} {
	cls, ok := i.(*protocol.GoodsLocal)
	_ = cls
	if !ok {
		return nil
	}

	pk := GoodsLocalUid{

		Uid: cls.Uid,
	}
	return pk

}

// PersistToBytes 序列化
func (m *GoodsLocalManager) PersistToBytes(cls *protocol.GoodsLocal, bitSet GoodsLocalBitSet) (data []byte) {
	var err error
	if cls == nil {
		return nil
	}
	defer func() {
		if r := recover(); r != nil {
			log.Infoln("recovered in ", r)
			log.Infoln("stack: ", string(debug.Stack()))
		}
		if err != nil {
			log.Infoln("PersistToBytes Error", err.Error())
		}
	}()
	size := 0

	//Uid	int32

	if true || bitSet.Get(EGoodsLocalFieldIndexUid) {
		size += 1 + 32/8
	} else {
		size += 1
	}

	//Time	int64

	if bitSet.Get(EGoodsLocalFieldIndexTime) {
		size += 1 + 64/8
	} else {
		size += 1
	}

	//Name	string

	if bitSet.Get(EGoodsLocalFieldIndexName) {
		size += 1 + 4 + len(cls.Name)
	} else {
		size += 1
	}

	// ************************************ marshal ************************************
	data = make([]byte, size)
	i := 0

	//Uid	int32

	if true || bitSet.Get(EGoodsLocalFieldIndexUid) {
		data[i] |= persistCore.EMarshalFlagBitSet
		i += 1

		binary.LittleEndian.PutUint32(data[i:], uint32(cls.Uid))
		i += 32 / 8
	} else {
		i += 1
	}

	//Time	int64

	if bitSet.Get(EGoodsLocalFieldIndexTime) {
		data[i] |= persistCore.EMarshalFlagBitSet
		i += 1

		binary.LittleEndian.PutUint64(data[i:], uint64(cls.Time))
		i += 64 / 8
	} else {
		i += 1
	}

	//Name	string

	if bitSet.Get(EGoodsLocalFieldIndexName) {
		data[i] |= persistCore.EMarshalFlagBitSet
		i += 1

		binary.LittleEndian.PutUint32(data[i:], uint32(len(cls.Name)))
		i += 4
		copy(data[i:], cls.Name)
		i += len(cls.Name)
	} else {
		i += 1
	}

	return
}

// PersistToPersistByBitSet 按位图复制数据
func (m *GoodsLocalManager) PersistToPersistByBitSet(dst, src *protocol.GoodsLocal, bitSet GoodsLocalBitSet) {
	var err error
	if dst == nil || src == nil {
		log.Infoln("PersistToPersistByBitSet Error, dst or src is nil")
		return
	}
	defer func() {
		if r := recover(); r != nil {
			log.Infoln("recovered in ", r)
			log.Infoln("stack: ", string(debug.Stack()))
		}
		if err != nil {
			log.Infoln("PersistToPersistByBitSet Error", err.Error())
		}
	}()

	//Uid	int32
	if bitSet.Get(EGoodsLocalFieldIndexUid) {
		dst.Uid = src.Uid
	}

	//Time	int64
	if bitSet.Get(EGoodsLocalFieldIndexTime) {
		dst.Time = src.Time
	}

	//Name	string
	if bitSet.Get(EGoodsLocalFieldIndexName) {
		dst.Name = src.Name
	}

	return
}

// BytesToPersistSync 反序列化sync
func (m *GoodsLocalManager) BytesToPersistSync(data []byte) (persistSync *GoodsLocalSync) {
	var err error
	if data == nil {
		return nil
	}
	defer func() {
		if r := recover(); r != nil {
			log.Infoln("recovered in ", r)
			log.Infoln("stack: ", string(debug.Stack()))
		}
		if err != nil {
			log.Infoln("BytesToPersistSync Error", err.Error())
		}
	}()
	i := 0

	const bitSetSize = (int)((EGoodsLocalFiledIndexLength>>EGoodsLocalLog2WordSize)+1) * 8

	persistSync = &GoodsLocalSync{}
	lenPersistData := len(data) - bitSetSize - 1

	persistSync.Data = m.BytesToPersist(data[:lenPersistData])

	i += lenPersistData
	persistSync.Op = int8(data[i])
	i += 1
	for j := 0; j < bitSetSize/8; j++ {
		persistSync.BitSet.set[j] = binary.LittleEndian.Uint64(data[i:])
		i += 8
	}

	return
}

// PersistSyncToBytes 序列化sync
func (m *GoodsLocalManager) PersistSyncToBytes(persistSync *GoodsLocalSync) (data []byte) {
	var err error
	if persistSync == nil {
		return nil
	}
	defer func() {
		if r := recover(); r != nil {
			log.Infoln("recovered in ", r)
			log.Infoln("stack: ", string(debug.Stack()))
		}
		if err != nil {
			log.Infoln("PersistSyncToBytes Error", err.Error())
		}
	}()
	size := 0

	const bitSetSize = (int)((EGoodsLocalFiledIndexLength>>EGoodsLocalLog2WordSize)+1) * 8

	pData := m.PersistToBytes(persistSync.Data, persistSync.BitSet)
	size += len(pData) + 1 + bitSetSize

	data = make([]byte, size)

	i := 0

	copy(data[i:], pData)
	i += len(pData)
	data[i] = uint8(persistSync.Op)
	i += 1
	for _, setItem := range persistSync.BitSet.set {
		binary.LittleEndian.PutUint64(data[i:], setItem)
		i += 8
	}

	return
}

// StringToPersistSyncInterface 反序列化2syncInterface
func (m *GoodsLocalManager) StringToPersistSyncInterface(data string) interface{} {
	return m.StringToPersistSync(data)
}

// StringToPersistSync 反序列化2sync
func (m *GoodsLocalManager) StringToPersistSync(data string) (persistSync *GoodsLocalSync) {
	if data == "" {
		return nil
	}
	buf, err := base64.StdEncoding.DecodeString(data)
	if err != nil {
		return nil
	}
	return m.BytesToPersistSync(buf)
}

// PersistSyncToString 序列化2sync
func (m *GoodsLocalManager) PersistSyncToString(persistSync *GoodsLocalSync) (data string) {
	buf := m.PersistSyncToBytes(persistSync)
	if buf == nil {
		return ""
	}
	data = base64.StdEncoding.EncodeToString(buf)
	return
}

// UnmarshalFailQueue 失败队列反序列化
func (m *GoodsLocalManager) UnmarshalFailQueue(data []byte, failQueue *[]*GoodsLocalSync) (err error) {
	if data == nil || failQueue == nil {
		return nil
	}
	defer func() {
		if r := recover(); r != nil {
			log.Infoln("recovered in ", r)
			log.Infoln("stack: ", string(debug.Stack()))
		}
		if err != nil {
			log.Infoln("UnmarshalFailQueue Error", err.Error())
		}
	}()
	i := 0
	lenFailQueue := binary.LittleEndian.Uint32(data[i:])
	i += 4
	*failQueue = make([]*GoodsLocalSync, lenFailQueue)
	for idx := 0; idx < int(lenFailQueue); idx++ {
		lenPersistSyncData := int(binary.LittleEndian.Uint32(data[i:]))
		i += 4
		persistSync := m.BytesToPersistSync(data[i : i+lenPersistSyncData])
		i += lenPersistSyncData
		(*failQueue)[idx] = persistSync
	}
	return nil
}

// MarshalFailQueue 失败队列序列化
func (m *GoodsLocalManager) MarshalFailQueue(failQueue []*GoodsLocalSync) (data []byte, err error) {
	var idx int
	var size int
	var persistSync *GoodsLocalSync
	defer func() {
		if r := recover(); r != nil {
			log.Infoln("recovered in ", r)
			log.Infoln("stack: ", string(debug.Stack()))
		}
		if err != nil {
			log.Infoln("MarshalFailQueue Error", err.Error())
		}
	}()
	persistSyncDataList := make([][]byte, len(failQueue))
	size += 4
	for idx = range failQueue {
		persistSync = failQueue[idx]
		pData := m.PersistSyncToBytes(persistSync)
		persistSyncDataList[idx] = pData
		size += 4 + len(pData)
	}

	data = make([]byte, size)
	i := 0
	binary.LittleEndian.PutUint32(data[i:], uint32(len(failQueue)))
	i += 4
	for idx = range failQueue {
		binary.LittleEndian.PutUint32(data[i:], uint32(len(persistSyncDataList[idx])))
		i += 4
		copy(data[i:], persistSyncDataList[idx])
		i += len(persistSyncDataList[idx])
	}
	return
}

// acquireDeepCopyObject 拷贝一个新对象用于写回
func (m *GoodsLocalManager) acquireDeepCopyObject(cls *protocol.GoodsLocal) (ret *protocol.GoodsLocal) {
	if v, ok := ((interface{})(cls)).(GoodsLocalDeepCopy); ok {
		//ret = m.pool.Get().(*protocol.GoodsLocal)
		ret = &protocol.GoodsLocal{}
		v.CopyTo(ret)
	} else {
		ret = m.BytesToPersist(m.PersistToBytes(cls, m.bitSetAll))
	}
	return
}

// releaseDeepCopyObject 释放对象
func (m *GoodsLocalManager) releaseDeepCopyObject(cls *protocol.GoodsLocal) {
	//if _, ok := ((interface{})(cls)).(*GoodsLocalDeepCopy); ok {
	//	m.pool.Put(cls)
	//}
	return
}

// CheckOverload 检查负载
func (m *GoodsLocalManager) CheckOverload() {
	// queueLength 不是精确值,  cacheQueue, FailQueue 一写多读
	queueLength := len(*m.cacheQueue) + len(m.FailQueue)
	if queueLength > 10000 {
		if v, ok := ((interface{})(gGoodsLocalNil)).(GoodsLocalOverload); ok {
			go recoverutils.RecoverWrapFunc(func() { v.Overload(queueLength, m.lastWriteBackTime) })
		} else {
		}
	} else {
	}
}

// addGoodsLocal添加一个对象
func (m *GoodsLocalManager) addGoodsLocal(cls *protocol.GoodsLocal) (*protocol.GoodsLocal, bool) {

	actual, loaded := m.hashUid.LoadOrStore(GoodsLocalKeyTypeHashUid{cls.Uid}, cls)
	if !loaded {
		actual = cls

	}
	return actual, !loaded
}

// removeGoodsLocal 删除一个对象
func (m *GoodsLocalManager) removeGoodsLocal(cls *protocol.GoodsLocal) {
	// m.hashUidMark.Delete(GoodsLocalKeyTypeHashUid{ cls.Uid, })

	m.hashUid.Delete(GoodsLocalKeyTypeHashUid{cls.Uid})

	return
}

// InitDS ds并发map初始化
func (m *GoodsLocalManager) InitDS(cls *protocol.GoodsLocal) {
	// todo
	// cls.MyMap = ds.RWMapInt32Int32{}

	//Uid	int32

	//Time	int64

	//Name	string

}

// NewGoodsLocal 添加对象并异步写回数据库, (1 数据没有导入或已经导出, 2 数据已存在, 3 对象为空) 会返回失败
func (m *GoodsLocalManager) NewGoodsLocal(cls *protocol.GoodsLocal) (*protocol.GoodsLocal, error) {

	if cls == nil {
		return nil, persistCore.EPersistErrorNil
	}

	if m.LoadState(cls.Uid) != EGoodsLocalLoadStateMemory {
		return nil, persistCore.EPersistErrorNotInMemory
	}

	actual, success := m.addGoodsLocal(cls)

	if success {
		m.InitDS(cls)
		bitSet := GoodsLocalBitSet{}
		bitSet.SetAll()
		newCls := m.acquireDeepCopyObject(cls)

		persistSync := &GoodsLocalSync{Data: newCls, Op: EGoodsLocalOpInsert, BitSet: bitSet}

		log.Infoln("[sql trace GoodsLocal]", m.PersistSyncToString(persistSync))

		m.syncChan <- persistSync

	} else {
		return actual, persistCore.EPersistErrorAlreadyExist
	}

	return actual, nil
}

// DeleteGoodsLocal 删除对象并异步写回数据库 (1 数据没有导入或已经导出, 2 数据已经重新导入, 3 对象为空) 会返回失败
func (m *GoodsLocalManager) DeleteGoodsLocal(cls *protocol.GoodsLocal) error {
	if cls == nil {
		return persistCore.EPersistErrorNil
	}

	if m.LoadState(cls.Uid) != EGoodsLocalLoadStateMemory {
		return persistCore.EPersistErrorNotInMemory
	}

	p := m.GetGoodsLocalByUid(cls.Uid)
	if p == nil || p != cls {
		return persistCore.EPersistErrorOutOfDate
	}

	m.removeGoodsLocal(cls)

	// 主键不能修改
	bitSet := GoodsLocalBitSet{}
	bitSet.SetAll()
	newCls := m.acquireDeepCopyObject(cls)

	persistSync := &GoodsLocalSync{Data: newCls, Op: EGoodsLocalOpDelete, BitSet: bitSet}

	log.Infoln("[sql trace GoodsLocal]", m.PersistSyncToString(persistSync))

	m.syncChan <- persistSync

	return nil
}

// DeleteAll 删除所有对象并异步写回数据库
func (m *GoodsLocalManager) DeleteAll() {

	var tmpGoodsLocalList []*protocol.GoodsLocal
	m.hashUid.Range(func(k GoodsLocalKeyTypeHashUid, v *protocol.GoodsLocal) bool {
		tmpGoodsLocalList = append(tmpGoodsLocalList, v)
		return true
	})
	for _, cls := range tmpGoodsLocalList {
		if cls == nil {
			continue
		}
		m.removeGoodsLocal(cls)

		// 主键不能修改
		bitSet := GoodsLocalBitSet{}
		bitSet.SetAll()
		newCls := m.acquireDeepCopyObject(cls)

		persistSync := &GoodsLocalSync{Data: newCls, Op: EGoodsLocalOpDelete, BitSet: bitSet}

		log.Infoln("[sql trace GoodsLocal]", m.PersistSyncToString(persistSync))

		m.syncChan <- persistSync

	}
}

// EOptimizeFlagUsePoolAndDisableDeleteUnload 优化下不支持修改索引

// 不建议修改索引列

// MarkUpdate 标记脏对象并异步写回数据库, (1 数据没有导入或已经导出, 2 数据已经重新导入, 3 对象为空) 会返回失败
func (m *GoodsLocalManager) MarkUpdate(cls *protocol.GoodsLocal) error {
	if cls == nil {
		return persistCore.EPersistErrorNil
	}

	if m.LoadState(cls.Uid) != EGoodsLocalLoadStateMemory {
		return persistCore.EPersistErrorNotInMemory
	}

	p := m.GetGoodsLocalByUid(cls.Uid)
	if p == nil || p != cls {
		return persistCore.EPersistErrorOutOfDate
	}

	m.InitDS(cls)
	bitSet := GoodsLocalBitSet{}
	bitSet.SetAll()
	newCls := m.acquireDeepCopyObject(cls)

	persistSync := &GoodsLocalSync{Data: newCls, Op: EGoodsLocalOpUpdate, BitSet: bitSet}

	log.Infoln("[sql trace GoodsLocal]", m.PersistSyncToString(persistSync))

	m.syncChan <- persistSync

	return nil
}

// MarkUpdateByBitSet 标记脏对象并异步写回数据库, (1 数据没有导入或已经导出, 2 数据已经重新导入, 3 对象为空) 会返回失败
func (m *GoodsLocalManager) MarkUpdateByBitSet(cls *protocol.GoodsLocal, bitSet GoodsLocalBitSet) error {
	if cls == nil {
		return persistCore.EPersistErrorNil
	}

	if m.LoadState(cls.Uid) != EGoodsLocalLoadStateMemory {
		return persistCore.EPersistErrorNotInMemory
	}

	p := m.GetGoodsLocalByUid(cls.Uid)
	if p == nil || p != cls {
		return persistCore.EPersistErrorOutOfDate
	}

	m.InitDS(cls)

	newCls := m.acquireDeepCopyObject(cls)

	persistSync := &GoodsLocalSync{Data: newCls, Op: EGoodsLocalOpUpdate, BitSet: bitSet}

	log.Infoln("[sql trace GoodsLocal]", m.PersistSyncToString(persistSync))

	m.syncChan <- persistSync

	return nil
}

// MarkUpdateByFieldIndex 标记脏对象并异步写回数据库, (1 数据没有导入或已经导出, 2 数据已经重新导入, 3 对象为空) 会返回失败
func (m *GoodsLocalManager) MarkUpdateByFieldIndex(cls *protocol.GoodsLocal, fieldIndex GoodsLocalFieldIndex) error {
	return m.MarkUpdateByBitSet(cls, *((&GoodsLocalBitSet{}).Set(fieldIndex)))
}

// GetGoodsLocalByUid 通过索引查找对象
func (m *GoodsLocalManager) GetGoodsLocalByUid(Uid int32) *protocol.GoodsLocal {

	if data, ok := m.hashUid.Load(GoodsLocalKeyTypeHashUid{Uid}); ok {
		return data
	}
	return nil
}

// GetAll 通过主键查找所有对象
func (m *GoodsLocalManager) GetAll() (ret []*protocol.GoodsLocal) {

	m.hashUid.Range(func(k GoodsLocalKeyTypeHashUid, v *protocol.GoodsLocal) bool {
		ret = append(ret, v)
		return true
	})
	return
}

// LoadAllState 所有数据导入状态
func (m *GoodsLocalManager) LoadAllState() int32 {
	return atomic.LoadInt32(&m.loadAll)
}

// LoadAll (非线程安全) 导入所有数据, 全导入后只能全导出, 不能再按照key导入导出
func (m *GoodsLocalManager) LoadAll() (err error) {
	log.Infoln("GoodsLocalManager LoadAll begin")
	// 未全导入状态切换到全导入
	if atomic.CompareAndSwapInt32(&m.loadAll, EGoodsLocalTableStateDisk, EGoodsLocalTableStateLoading) {
		rows := make([]*protocol.GoodsLocal, 0)
		err = m.engine.Find(&rows, gGoodsLocalNil)
		if err != nil {
			atomic.StoreInt32(&m.loadAll, EGoodsLocalTableStateDisk)
			return err
		} else {

			for _, row := range rows {
				m.addGoodsLocal(row)
			}
			atomic.StoreInt32(&m.loadAll, EGoodsLocalTableStateMemory)
		}
	} else {
		return persistCore.EPersistErrorIncorrectState
	}
	log.Infoln("GoodsLocalManager LoadAll end")
	return
}

// LoadState 查询包含该key的数据导入状态
func (m *GoodsLocalManager) LoadState(Uid int32) int32 {
	if atomic.LoadInt32(&m.loadAll) == EGoodsLocalTableStateDisk {
		if value, ok := m.loadUidMap.Load(Uid); ok {
			state := value
			return atomic.LoadInt32(state)
		} else {
			return EGoodsLocalLoadStateDisk
		}
	} else {
		return EGoodsLocalLoadStateMemory
	}
}

// SetLoadState2Memory 没有数据时, 标记数据在内存中. 仅用于第一次数据库导入空数据, 错误使用会导致未定义的行为
func (m *GoodsLocalManager) SetLoadState2Memory(Uid int32) {
	if atomic.LoadInt32(&m.loadAll) == EGoodsLocalTableStateDisk {
		p := int32(EGoodsLocalLoadStateMemory)
		m.loadUidMap.Store(Uid, &p)
	} else {
	}
}

// Load 按照key导入数据, 必须存在unload key的索引
func (m *GoodsLocalManager) Load(Uid int32) (err error) {
	// LoadAll后不能再次Load
	if atomic.LoadInt32(&m.loadAll) == EGoodsLocalTableStateDisk {
		p := int32(0)
		value, _ := m.loadUidMap.LoadOrStore(Uid, &p)
		state := value
		// 检查导入状态
		switch atomic.LoadInt32(state) {
		// 未导入状态切换到导入
		case EGoodsLocalLoadStateDisk:
			if atomic.CompareAndSwapInt32(state, EGoodsLocalLoadStateDisk, EGoodsLocalLoadStateLoading) {
				rows := make([]*protocol.GoodsLocal, 0)
				err = m.engine.Find(&rows, &protocol.GoodsLocal{Uid: Uid})

				if err != nil { // 导入失败, 状态回到导出
					atomic.StoreInt32(state, EGoodsLocalLoadStateDisk)
				} else {

					for _, row := range rows {
						m.addGoodsLocal(row)
					}
					atomic.StoreInt32(state, EGoodsLocalLoadStateMemory)
				}
				return
			} else { // 期间状态变化,不确定操作是否成功
				return persistCore.EPersistErrorUnknownError
			}

		case EGoodsLocalLoadStateLoading: // 正在导入
			// 并发导入暂时轮询等待
			bTime := time.Now().Unix()
			for {
				if atomic.LoadInt32(state) != EGoodsLocalLoadStateLoading {
					break
				}
				if time.Now().Unix() > bTime+persistCore.ELoadPollingTimeOut {
					break
				}
				time.Sleep(time.Millisecond * 100)
			}
			if atomic.LoadInt32(state) == EGoodsLocalLoadStateMemory {
				return
			} else {
				return persistCore.EPersistErrorUnknownError
			}

		case EGoodsLocalLoadStateMemory: // 导入完成
			return

		case EGoodsLocalLoadStatePrepareUnloading: // 准备导出,立即取消导出
			if atomic.CompareAndSwapInt32(state, EGoodsLocalLoadStatePrepareUnloading, EGoodsLocalLoadStateMemory) {
				return
			} else { // 期间状态变化,不确定操作是否成功
				return persistCore.EPersistErrorUnknownError
			}

		case EGoodsLocalLoadStateUnloading: // 正在导出
			return persistCore.EPersistErrorUnloading
		default: // ???
			return persistCore.EPersistErrorUnknownError
		}
	} else {
		return
	}
}

// UnloadAll (非线程安全) 导出所有数据, 调用UnloadAll后,不允许再修改相关的数据(必须先导入才能修改数据)
func (m *GoodsLocalManager) UnloadAll() (err error) {
	var clsList []*protocol.GoodsLocal
	// 未导入状态切换到导入
	if atomic.CompareAndSwapInt32(&m.loadAll, EGoodsLocalTableStateMemory, EGoodsLocalTableStateUnloading) {

		m.hashUid.Range(func(k GoodsLocalKeyTypeHashUid, v *protocol.GoodsLocal) bool {
			clsList = append(clsList, v)
			return true
		})
		for _, cls := range clsList {
			m.removeGoodsLocal(cls)
		}
		atomic.StoreInt32(&m.loadAll, EGoodsLocalTableStateDisk)
	} else {
		return persistCore.EPersistErrorIncorrectState
	}
	return
}

// Unload 按照key导出数据, 必须存在unload key的索引. 调用Unload后,不允许再修改相关的数据(必须先导入才能修改数据).
func (m *GoodsLocalManager) Unload(Uid int32) (err error) {

	// LoadAll后不能unload
	if atomic.LoadInt32(&m.loadAll) == EGoodsLocalTableStateDisk {
		if value, ok := m.loadUidMap.Load(Uid); ok {
			state := value

			switch atomic.LoadInt32(state) {
			case EGoodsLocalLoadStateDisk: // 未导入
				return //persistCore.EPersistErrorNotInMemory
			case EGoodsLocalLoadStateLoading: // 正在导入
				return persistCore.EPersistErrorLoading
			case EGoodsLocalLoadStateMemory: // 导入完成, 开始导出吧
				if atomic.CompareAndSwapInt32(state, EGoodsLocalLoadStateMemory, EGoodsLocalLoadStatePrepareUnloading) {
					m.syncChan <- &GoodsLocalSync{Data: &protocol.GoodsLocal{Uid: Uid}, Op: EGoodsLocalOpUnload}
					return
				} else { // 期间状态变化,不确定操作是否成功
					return persistCore.EPersistErrorUnknownError
				}
			case EGoodsLocalLoadStatePrepareUnloading: // 准备导出, 立即取消导出
				return //persistCore.EPersistErrorAlreadyUnload
			case EGoodsLocalLoadStateUnloading: // 正在导出, 导入失败
				return //persistCore.EPersistErrorUnloading
			default:
				return persistCore.EPersistErrorUnknownError
			}
		} else {
			return //persistCore.EPersistErrorNotInMemory
		}
	} else {
		return persistCore.EPersistErrorAlreadyLoadAll
	}

}

// unload (非线程安全) 按照key导出数据, 必须存在unload key的索引. 调用Unload后,不允许再修改相关的数据(必须先导入才能修改数据).
func (m *GoodsLocalManager) unload(Uid int32) {

	cls := m.GetGoodsLocalByUid(Uid)
	if cls != nil {
		m.removeGoodsLocal(cls)
	}

}

var GGoodsLocalManager *GoodsLocalManager

// init 注册管理类
func init() {

	if GetDB == nil {
		log.Infoln(persistCore.EPersistErrorEngineNil)
		persistCore.RegisterPersistLazy("GoodsLocal", GGoodsLocalManager)
		return
	}
	engine := GetDB()
	if engine == nil {
		log.Infoln(persistCore.EPersistErrorEngineNil)
		return
	}
	GGoodsLocalManager = NewGoodsLocalManager(engine)
	Register("GoodsLocal", GGoodsLocalManager)
	// go GGoodsLocalManager.Collect()

	//for idx, name := range GoodsLocalStructFiledMap {
	//	GoodsLocalDBFiledMap[idx] = engine.GetColumnMapper().Obj2Table(name)
	//}

}

// LazyInit 惰性创建注册初始化
func (m *GoodsLocalManager) LazyInit() (err error) {

	if GetDB == nil {
		err = errors.New("GetDB is nil")
		return
	}
	engine := GetDB()
	if engine == nil {
		err = errors.New("engine is nil")
		return
	}
	GGoodsLocalManager = NewGoodsLocalManager(engine)
	Register("GoodsLocal", GGoodsLocalManager)

	return
}

// noneFunc 惰性创建注册初始化
func (m *GoodsLocalManager) noneFunc() {
	math.Abs(1.0)
	_ = jsoniter.ConfigCompatibleWithStandardLibrary
	_ = json.Marshal
	_ = sync.Mutex{}
	_ = reflect.Value{}
	_ = time.Now()
	_ = sentry.Client{}
	_ = strings.Builder{}
	log.Infoln("none")
}

// SaveDB xorm写数据库
func (m *GoodsLocalManager) SaveDB(session *xorm.Session, persistSync *GoodsLocalSync) (err error) {
	defer func() {
		if r := recover(); r != nil {
			log.Infoln("recovered in ", r)
			log.Infoln("stack: ", string(debug.Stack()))
			if err == nil {
				err = errors.New("unknown error")
			}
		}
	}()
	switch persistSync.Op {
	case EGoodsLocalOpInsert:

		_, err = session.Insert(persistSync.Data)

		if err != nil {
			log.Infoln("insert error ", err, "[sql error GoodsLocal]", m.PersistSyncToString(persistSync))
			return
		}

	case EGoodsLocalOpUpdate:
		cls := persistSync.Data
		bitSet := persistSync.BitSet
		if bitSet.IsSetAll() {
			_, err = session.ID(core.NewPK(cls.Uid)).AllCols().Update(cls)
			if err != nil {
				log.Infoln("update error ", err, "[sql error GoodsLocal]", m.PersistSyncToString(persistSync))
				return
			}
		} else {
			var nameList []string
			for idx, name := range GoodsLocalDBFiledMap {
				if bitSet.Get(GoodsLocalFieldIndex(idx)) {
					nameList = append(nameList, name)
				}
			}
			if nameList != nil {
				_, err = session.ID(core.NewPK(cls.Uid)).Cols(nameList...).Update(cls)
				if err != nil {
					log.Infoln("update error ", err, "[sql error GoodsLocal]", m.PersistSyncToString(persistSync))
					return
				}
			} else {
				_, err = session.ID(core.NewPK(cls.Uid)).AllCols().Update(cls)
				if err != nil {
					log.Infoln("update error ", err, "[sql error GoodsLocal]", m.PersistSyncToString(persistSync))
					return
				}
			}
		}

	case EGoodsLocalOpDelete:
		cls := persistSync.Data
		_, err = session.ID(core.NewPK(cls.Uid)).Delete(gGoodsLocalNil)
		if err != nil {
			log.Infoln("delete error ", err, "[sql error GoodsLocal]", m.PersistSyncToString(persistSync))
			return
		}

	case EGoodsLocalOpUnload:
		cls := persistSync.Data
		Uid := cls.Uid
		if value, ok := m.loadUidMap.Load(Uid); ok {
			state := value
			// 准备导出,  不中断的清理玩家数据
			// warning 导出后又修改, 不保证数据一致性
			if atomic.CompareAndSwapInt32(state, EGoodsLocalLoadStatePrepareUnloading, EGoodsLocalLoadStateUnloading) {
				m.unload(Uid)
				m.loadUidMap.Delete(Uid)
				atomic.StoreInt32(state, EGoodsLocalLoadStateDisk)
			} else {
				// 0:导出  1:导入开始  2:导入完成  4:正在导出  不确定状态
				// 以上状态跳过吧
			}
		} else {
			// 不存在的玩家,跳过吧
		}

	}
	return
}

// DataToFailQueue 未写入成功数据, 添加到失败队列
func (m *GoodsLocalManager) DataToFailQueue() {
	var persistSync *GoodsLocalSync

	// 一旦失败标记所有的数据都是失败, 不允许导出

	m.FailQueue = append(m.FailQueue, m.InsertQueue...)
	m.InsertQueue = m.InsertQueue[0:0]

	for i := 0; i < len(*m.syncQueue); i++ {
		persistSync = (*m.syncQueue)[i]
		switch persistSync.Op {
		case EGoodsLocalOpInsert, EGoodsLocalOpUpdate, EGoodsLocalOpDelete:
			m.FailQueue = append(m.FailQueue, persistSync)

		case EGoodsLocalOpUnload:
			// 导出状态还原
			cls := persistSync.Data
			Uid := cls.Uid
			if value, ok := m.loadUidMap.Load(Uid); ok {
				state := value
				// 导出失败状态回退
				if atomic.CompareAndSwapInt32(state, EGoodsLocalLoadStatePrepareUnloading, EGoodsLocalLoadStateMemory) {
				} else {
				}
			}

		default:
		}
	}
	*m.syncQueue = (*m.syncQueue)[0:0]
}

// LoadFile 文件读取写回失败数据
func (m *GoodsLocalManager) LoadFile() error {
	bombExist := dir.Exists("_./_Users_anniext_project_persist_data/GoodsLocal.bomb")
	tmpExist := dir.Exists("_./_Users_anniext_project_persist_data/GoodsLocal.tmp")

	if tmpExist {
		return persistCore.EPersistErrorTempFileExist
	}

	if bombExist {
		data, err := ioutil.ReadFile("_./_Users_anniext_project_persist_data/GoodsLocal.bomb")
		if err != nil {
			return err
		}
		pos := bytes.IndexByte(data, byte(' '))
		if pos == -1 {
			return persistCore.EPersistErrorInvalidBombFile
		}
		persistData := data[pos+1:]
		err = m.UnmarshalFailQueue(persistData, &m.FailQueue)
		if err != nil {
			return err
		}

		session := m.engine.NewSession()
		defer session.Close()

		var persistSync *GoodsLocalSync

		for i := range m.FailQueue {
			persistSync = m.FailQueue[i]
			err = m.SaveDB(session, persistSync)
			if err != nil {
				m.FailQueue = m.FailQueue[i:]
				m.SaveFile()
				return err
			}
		}
		m.FailQueue = m.FailQueue[0:0]
		m.RemoveFile()

	}
	return nil
}

// SaveFile 写回失败,记录数据,写文件,等待下次写回
func (m *GoodsLocalManager) SaveFile() {

	m.DataToFailQueue()

	data, err := m.MarshalFailQueue(m.FailQueue)
	if err != nil {
		log.Infoln("SaveFile marshal error ", err)
	}
	_ = os.Mkdir("_./_Users_anniext_project_persist_data", 0770)
	err = ioutil.WriteFile("_./_Users_anniext_project_persist_data/GoodsLocal.tmp", append([]byte("GoodsLocal "), data...), 0660)
	if err != nil {
		log.Infoln("SaveFile write temp file error ", err)
	}
	err = ioutil.WriteFile("_./_Users_anniext_project_persist_data/GoodsLocal.bomb", append([]byte("GoodsLocal "), data...), 0660)
	if err != nil {
		log.Infoln("SaveFile write bomb file error ", err)
	}
	_ = os.Remove("_./_Users_anniext_project_persist_data/GoodsLocal.tmp")
}

// RemoveFile 删除写回失败文件
func (m *GoodsLocalManager) RemoveFile() {
	_ = os.Remove("_./_Users_anniext_project_persist_data/GoodsLocal.tmp")
	_ = os.Remove("_./_Users_anniext_project_persist_data/GoodsLocal.bomb")
	_ = os.Remove("_./_Users_anniext_project_persist_data")
}

// RecoverBomb bomb数据写入数据库
func (m *GoodsLocalManager) RecoverBomb(bomb []byte) (err error) {
	var persistSync *GoodsLocalSync
	var failQueue []*GoodsLocalSync
	session := m.engine.NewSession()
	defer session.Close()
	err = m.UnmarshalFailQueue(bomb, &failQueue)
	if err != nil {
		return
	}
	var i int
	for i = range failQueue {
		persistSync = failQueue[i]
		err = m.SaveDB(session, persistSync)
		if err != nil {
			break
		}
	}
	if len(failQueue)-1 > i {
		data, _ := m.MarshalFailQueue(failQueue[i:])
		_, _ = os.Stdout.Write([]byte("GoodsLocal "))
		_, _ = os.Stdout.Write(data)
	}
	return
}

// RecoverTrace trace数据写入数据库
func (m *GoodsLocalManager) RecoverTrace(trace [][]byte) (err error) {
	var persistSync *GoodsLocalSync
	var traceQueue []*GoodsLocalSync
	var insertQueue []*GoodsLocalSync

	for i := 0; i < len(trace); i++ {
		persistSync = m.StringToPersistSync(string(trace[i]))
		if persistSync.Op == EGoodsLocalOpInsert {
			insertQueue = append(insertQueue, persistSync)
		} else {
			traceQueue = append(traceQueue, persistSync)
		}
	}

	insertQueue2, otherQueue := m.MergeQueue(traceQueue, false)
	for _, insertItem := range insertQueue2 {
		insertQueue = append(insertQueue, insertItem)
	}

	session := m.engine.NewSession()
	defer session.Close()

	var i int
	for i = range insertQueue {
		persistSync = insertQueue[i]
		_ = m.SaveDB(session, persistSync)
	}
	for i = range otherQueue {
		persistSync = otherQueue[i]
		_ = m.SaveDB(session, persistSync)
	}
	return
}

// MergeQueue 内存中合并操作
func (m *GoodsLocalManager) MergeQueue(q []*GoodsLocalSync, copyAll bool) (insertQueue, otherQueue []*GoodsLocalSync) {

	var currentPersistSync *GoodsLocalSync
	var oldPersistSync *GoodsLocalSync
	var ok bool

	var unloadList []*GoodsLocalSync

	// 合并可能失败, persistSyncMap必须创建副本
	persistSyncMap := map[GoodsLocalUid]*GoodsLocalSync{}

	//unload 按照顺序强制移到最后
	//insert update delete 按照主键合并
	lenSyncQueue := len(q)
	fail := false

LabelForSyncQueue:
	for i := 0; i < lenSyncQueue; i++ {
		currentPersistSync = q[i]
		pk := GoodsLocalUid{

			Uid: currentPersistSync.Data.Uid,
		}
		// 导出特殊处理
		if currentPersistSync.Op == EGoodsLocalOpUnload {
			unloadList = append(unloadList, currentPersistSync)
			continue
		}
		// 第一次出现直接拷贝
		if oldPersistSync, ok = persistSyncMap[pk]; !ok {
			persistSyncMap[pk] = &GoodsLocalSync{Data: currentPersistSync.Data, Op: currentPersistSync.Op, BitSet: currentPersistSync.BitSet}
			continue
		}

		switch oldPersistSync.Op {
		case EGoodsLocalOpInsert:
			switch currentPersistSync.Op {
			case EGoodsLocalOpInsert:
				fail = true
				break LabelForSyncQueue
			case EGoodsLocalOpUpdate:
				oldPersistSync.Op = EGoodsLocalOpInsert
				if copyAll {
					oldPersistSync.Data = currentPersistSync.Data
				} else {
					m.PersistToPersistByBitSet(oldPersistSync.Data, currentPersistSync.Data, currentPersistSync.BitSet)
				}
				oldPersistSync.BitSet.SetAll()
			case EGoodsLocalOpDelete:
				delete(persistSyncMap, pk)
			}
		case EGoodsLocalOpUpdate:
			switch currentPersistSync.Op {
			case EGoodsLocalOpInsert:
				fail = true
				break LabelForSyncQueue
			case EGoodsLocalOpUpdate:
				oldPersistSync.Op = EGoodsLocalOpUpdate
				if copyAll {
					oldPersistSync.Data = currentPersistSync.Data
				} else {
					m.PersistToPersistByBitSet(oldPersistSync.Data, currentPersistSync.Data, currentPersistSync.BitSet)
				}
				oldPersistSync.BitSet.Merge(currentPersistSync.BitSet)
			case EGoodsLocalOpDelete:
				oldPersistSync.Op = EGoodsLocalOpDelete
				oldPersistSync.Data = currentPersistSync.Data
				oldPersistSync.BitSet.ClearAll()
			}
		case EGoodsLocalOpDelete:
			switch currentPersistSync.Op {
			case EGoodsLocalOpInsert:
				oldPersistSync.Op = EGoodsLocalOpUpdate
				oldPersistSync.Data = currentPersistSync.Data
				oldPersistSync.BitSet.SetAll()
			case EGoodsLocalOpUpdate:
				fail = true
				break LabelForSyncQueue
			case EGoodsLocalOpDelete:
				fail = true
				break LabelForSyncQueue
			}
		}
	}
	// 遇到错误取消合并
	if fail {
		otherQueue = q
		return
	}

	// 清空队列 该函数无副作用，需要外部自行清理

	// 按照合并内容重建队列, 插入特殊处理
	for _, persistSync := range persistSyncMap {
		if persistSync.Op == EGoodsLocalOpInsert {
			insertQueue = append(insertQueue, persistSync)
		} else {
			otherQueue = append(otherQueue, persistSync)
		}
	}

	for _, persistSync := range unloadList {
		otherQueue = append(otherQueue, persistSync)
	}

	return
}

// Save 异步写回
func (m *GoodsLocalManager) Save() {
	var exit bool
	for {
		// 正常退出
		exit = m.AsyncSave()
		if exit {
			break
		}
	}
}

// AsyncSave 异步写回
func (m *GoodsLocalManager) AsyncSave() (exit bool) {
	var persistSync *GoodsLocalSync
	var err error
	var queueEmpty bool
	bTime := time.Now().UnixNano()
	defer func() {
		if r := recover(); r != nil {
			log.Infoln("recovered in ", r)
			log.Infoln("stack: ", string(debug.Stack()))
			if !queueEmpty {
				log.Infoln("save failed: incrementalSave")
			}
		} else {
			if !queueEmpty {
				if err == nil {
					log.Infoln("save success: incrementalSave")
				} else {
					log.Infoln("save failed: incrementalSave")
				}
			}
		}
		m.DataToFailQueue()
		m.lastWriteBackTime = time.Duration(time.Now().UnixNano() - bTime)
		m.syncEnd <- true
	}()

	needCollect := <-m.syncBegin
	if len(*m.syncQueue) == 0 {
		queueEmpty = true
		if needCollect {
			time.Sleep(time.Millisecond * 100)
		} else {
			exit = true
		}
		return
	}
	session := m.engine.NewSession()
	defer session.Close()

	log.Infoln("begin incrementalSave", bTime)

	if len(m.FailQueue) > 0 {
		tmpQueue := make([]*GoodsLocalSync, len(m.FailQueue)+len(*m.syncQueue))
		copy(tmpQueue, m.FailQueue)
		copy(tmpQueue[len(m.FailQueue):], *m.syncQueue)
		insertQueue, otherQueue := m.MergeQueue(tmpQueue, true)
		m.syncQueue = &otherQueue
		m.InsertQueue = insertQueue
		m.FailQueue = m.FailQueue[0:0]
	} else {
		insertQueue, otherQueue := m.MergeQueue(*m.syncQueue, true)
		m.syncQueue = &otherQueue
		m.InsertQueue = insertQueue
	}

	multiInsertFn := func() bool {
		var err error
		defer func() {
			if r := recover(); r != nil {
				_ = session.Rollback()
			} else {
				if err == nil {
					m.InsertQueue = m.InsertQueue[0:0]
				} else {
					_ = session.Rollback()
				}
			}
		}()

		if len(m.InsertQueue) <= 0 {
			return true
		}
		err = session.Begin()
		if err != nil {
			return false
		}

		const num = 100
		var insertArray [num]*protocol.GoodsLocal
		length := len(m.InsertQueue)
		quotient := length / num
		remainder := length % num
		for i := 0; i < quotient; i++ {
			//fmt.Println("queue->(", i*num, "-", (i+1)*num, "): ", m.InsertQueue[i*num:(i+1)*num])
			for j := 0; j < num; j++ {
				insertArray[j] = m.InsertQueue[i*num+j].Data
			}

			_, err = session.InsertMulti(insertArray[:])

			if err != nil {
				log.Infoln("InsertMulti error ", err)
				return false
			}
		}
		if remainder != 0 {
			//fmt.Println("queue->(", quotient*num, "-", length, "): ", m.InsertQueue[quotient*num:length])

			insertArray = [num]*protocol.GoodsLocal{}
			for j := 0; j < remainder; j++ {
				insertArray[j] = m.InsertQueue[quotient*num+j].Data
			}

			_, err = session.InsertMulti(insertArray[:remainder])

			if err != nil {
				log.Infoln("InsertMulti error ", err)
				return false
			}
		}
		err = session.Commit()
		if err != nil {
			return false
		}
		return true
	}

	multiInsertSuccess := multiInsertFn()

	// 批量插入失败, 改为单条插入
	if !multiInsertSuccess {
		for idx, persistSync := range m.InsertQueue {
			err = m.SaveDB(session, persistSync)
			if err != nil {
				m.InsertQueue = m.InsertQueue[idx:]
				m.SaveFile()
				return
			}
		}
		m.InsertQueue = m.InsertQueue[0:0]
	}

	for i := 0; i < len(*m.syncQueue); i++ {
		persistSync = (*m.syncQueue)[i]
		err = m.SaveDB(session, persistSync)
		if err != nil {
			*m.syncQueue = (*m.syncQueue)[i:]
			m.SaveFile()
			return
		}
	}
	*m.syncQueue = (*m.syncQueue)[0:0]
	m.RemoveFile()
	return
}

// Collect 收集数据
func (m *GoodsLocalManager) Collect() {
	var persistSync *GoodsLocalSync
	var ok bool
	// 0:normal  1:exit begin, save sync  2:save cache  3:save done
	var state int8
	go m.Save()
	m.syncBegin <- true
	for {
		select {
		case persistSync, ok = <-m.syncChan:
			if ok {
				*m.cacheQueue = append(*m.cacheQueue, persistSync)
			}
		case _, ok = <-m.syncEnd:
			if ok {
				m.CheckOverload()
				m.cacheQueue, m.syncQueue = m.syncQueue, m.cacheQueue
				switch state {
				case EGoodsLocalCollectStateNormal:
					//go m.AsyncSave()
					m.syncBegin <- true
				case EGoodsLocalCollectStateSaveSync:
					//go m.AsyncSave()
					m.syncBegin <- true
					state = EGoodsLocalCollectStateSaveCache
				case EGoodsLocalCollectStateSaveCache:
					//go m.AsyncSave()
					m.syncBegin <- true
					state = EGoodsLocalCollectStateSaveDone
				case EGoodsLocalCollectStateSaveDone:
					m.syncBegin <- false
					<-m.syncEnd
					m.exitEnd <- true
					return
				}
			}
		case _, ok = <-m.exitBegin:
			if ok {
				state = EGoodsLocalCollectStateSaveSync
			}
			//default:
			//	time.Sleep(time.Second/10)
		}
	}
}

// Exit 管理类退出
func (m *GoodsLocalManager) Exit(wg *sync.WaitGroup) {
	defer wg.Done()

	if atomic.LoadInt32(&m.managerState) != EGoodsLocalManagerStateNormal {
		return
	}

	m.exitBegin <- true
	<-m.exitEnd
	atomic.StoreInt32(&m.managerState, EGoodsLocalManagerStateIdle)
	return
}

// Sync 数据库表结构同步
func (m *GoodsLocalManager) Sync(wg *sync.WaitGroup) (err error) {
	defer wg.Done()

	err = m.engine.Sync2(gGoodsLocalNil)

	return
}

// Segmentation 检查是否需要换表 如果需要换表 则根据时间 和切换间隔计算是否需要换表 否则为不处理
func (m *GoodsLocalManager) Segmentation(wg *sync.WaitGroup) (err error) {
	defer wg.Done()
	return
}

// compareAndUpdate 比较数据库，不相同则更新
func (m *GoodsLocalManager) compareAndUpdate(session *xorm.Session, cls *protocol.GoodsLocal, sentryDebug bool) (err error) {
	update := func(session *xorm.Session, cls *protocol.GoodsLocal, memData, dbData string) {
		log.Infoln("SyncData error. missing mark Mem. [sql error GoodsLocal]", memData)
		log.Infoln("SyncData error. missing mark  Db. [sql error GoodsLocal]", dbData)
		_, err = session.ID(core.NewPK(cls.Uid)).AllCols().Update(cls)
		if err != nil {
			log.Infoln("SyncData update error.", err, "[sql error GoodsLocal]", m.PersistSyncToString(&GoodsLocalSync{
				Data:   cls,
				Op:     EGoodsLocalOpUpdate,
				BitSet: m.bitSetAll,
			}))
			return
		}
	}
	resetTimeNSec := func(clsMem, clsDb *protocol.GoodsLocal) {
		defer func() {
			if r := recover(); r != nil {
				log.Infoln("recovered in ", r)
				log.Infoln("stack: ", string(debug.Stack()))
			}
		}()
		typeF := reflect.TypeOf(*clsMem)
		valueMemF := reflect.ValueOf(clsMem).Elem()
		valueDbF := reflect.ValueOf(clsDb).Elem()
		for i := 0; i < typeF.NumField(); i++ {
			if typeF.Field(i).Type.Name() == "Time" {
				f := valueMemF.Field(i)
				if f.CanInterface() {
					v := time.Unix(f.Interface().(time.Time).Unix(), 0)
					f.Set(reflect.ValueOf(v))
				}
				vMem := valueMemF.Field(i).Interface().(time.Time)
				vDb := valueDbF.Field(i).Interface().(time.Time)
				if vMem.Equal(vDb) {
					f.Set(reflect.ValueOf(vDb))
				}
			}
		}
	}

	dbCls := &protocol.GoodsLocal{

		Uid: cls.Uid,
	}
	var has bool
	has, err = session.Get(dbCls)
	if err != nil || !has {
		log.Infoln("SyncData query error.", err, "[sql error GoodsLocal]", m.PersistSyncToString(&GoodsLocalSync{
			Data:   cls,
			Op:     0,
			BitSet: m.bitSetAll,
		}))
		return
	}
	memCls := m.GetGoodsLocalByUid(cls.Uid)
	if memCls != nil {
		resetTimeNSec(memCls, dbCls)
		memData := m.PersistSyncToString(&GoodsLocalSync{
			Data:   memCls,
			Op:     0,
			BitSet: m.bitSetAll,
		})
		dbData := m.PersistSyncToString(&GoodsLocalSync{
			Data:   dbCls,
			Op:     0,
			BitSet: m.bitSetAll,
		})
		// 数据库内存不一致
		if strings.Compare(memData, dbData) != 0 {
			if sentryDebug {
				func() {
					defer func() {
						memClsJson, _ := json.Marshal(&GoodsLocalSync{
							Data:   memCls,
							Op:     0,
							BitSet: m.bitSetAll,
						})
						dbClsJson, _ := json.Marshal(&GoodsLocalSync{
							Data:   dbCls,
							Op:     0,
							BitSet: m.bitSetAll,
						})
						sentry.WithScope(func(scope *sentry.Scope) {
							tag := "CompareError" + "GoodsLocal"
							scope.SetTag(tag, "GoodsLocal")
							scope.SetTag("transaction", "GoodsLocal")
							scope.SetExtra("memClsJson", string(memClsJson))
							scope.SetExtra("dbClsJson", string(dbClsJson))
							sentry.CaptureMessage(tag)
						})
					}()
				}()
			}
			update(session, memCls, memData, dbData)
		}
	}
	return
}

// SyncData 全部内存数据写入数据库, 本接口耗时长,仅用于停服后.  补救没有标记写回数据(只处理未标记数据,New Delete不存在漏写)
func (m *GoodsLocalManager) SyncData(wg *sync.WaitGroup, sentryDebug bool) (err error) {
	defer wg.Done()

	session := m.engine.NewSession()
	defer session.Close()

	if sentryDebug {
		func() {
			defer func() {
				for _, cls := range m.GetAll() {
					updateErr := m.compareAndUpdate(session, cls, sentryDebug)
					if updateErr != nil {
						err = updateErr
					}
				}
				if err != nil {
					sentry.WithScope(func(scope *sentry.Scope) {
						tagtag := "SyncDataError" + "GoodsLocal"
						scope.SetTag("SyncDataError", "GoodsLocal")
						scope.SetTag("transaction", "GoodsLocal")
						scope.SetExtra(err.Error(), 1)
						sentry.CaptureMessage(tagtag)
					})
				}
			}()
		}()
	} else {
		for _, cls := range m.GetAll() {
			updateErr := m.compareAndUpdate(session, cls, sentryDebug)
			if updateErr != nil {
				err = updateErr
			}
		}
	}
	return

}

// SyncUserData 用户内存和数据库数据比较并更新, 不允许并发， 用于数据导出时，补救没有标记写回数据(只处理未标记数据,New Delete不存在漏写)
// sentryDebug debug模式下启用sentry
func (m *GoodsLocalManager) SyncUserData(Uid int32, sentryDebug bool) (err error) {
	session := m.engine.NewSession()
	defer session.Close()
	var clsList []*protocol.GoodsLocal

	// 业务代码必须保证，不使用正在导出的数据， 否则可能引发崩溃
	func() {
		defer func() {
			if r := recover(); r != nil {
				log.Infoln("recovered in ", r)
				log.Infoln("stack: ", string(debug.Stack()))
				err = errors.New("SyncUserData error")
			}
		}()

		cls := m.GetGoodsLocalByUid(Uid)
		if cls != nil {
			clsList = append(clsList, m.acquireDeepCopyObject(cls))
		}

	}()

	if err != nil {
		return
	}

	for _, cls := range clsList {
		err = m.compareAndUpdate(session, cls, sentryDebug)
		if sentryDebug {
			func() {
				defer func() {
					if err != nil {
						sentry.WithScope(func(scope *sentry.Scope) {
							tagtag := "SyncDataError" + "GoodsLocal"
							scope.SetTag("SyncDataError", "GoodsLocal")
							scope.SetTag("transaction", "GoodsLocal")
							scope.SetExtra(err.Error(), 1)
							sentry.CaptureMessage(tagtag)
						})
					}
				}()
			}()
		}
		if err != nil {
			return
		}
	}

	return

}

// object pool
