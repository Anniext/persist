package template

var indexAddItem = `
	{{if $.ArgsInfo.OptimizeFlagUsePoolAndDisableDeleteUnload}}
			{{if $indexItem.Unique}}    
				{{if $indexItem.Pk}}    
					actual, loaded := m.hash{{$indexItem.Keys}}.LoadOrStore({{$.DataName}}KeyTypeHash{{$indexItem.Keys}}{ {{$indexItem.ClsPointKeys}} }, -1)
					if !loaded {
						idx := m.objectPool.Put(cls)
						actual = idx
						m.hash{{$indexItem.Keys}}.Store({{$.DataName}}KeyTypeHash{{$indexItem.Keys}}{ {{$indexItem.ClsPointKeys}} }, idx)
				{{else}}
					m.hash{{$indexItem.Keys}}.Store({{$.DataName}}KeyTypeHash{{$indexItem.Keys}}{ {{$indexItem.ClsPointKeys}} }, idx)
				{{end}}
			{{else}}
				if v, ok := m.hash{{$indexItem.Keys}}.LoadOrStore({{$.DataName}}KeyTypeHash{{$indexItem.Keys}}{ {{$indexItem.ClsPointKeys}} }, -1); !ok {
					idxMap := m.objectMapPool.New(idx)
					m.hash{{$indexItem.Keys}}.Store({{$.DataName}}KeyTypeHash{{$indexItem.Keys}}{ {{$indexItem.ClsPointKeys}} }, idxMap)
				} else {
					m.objectMapPool.Put(v, idx)
				}
				
			{{end}}
	{{else}}
			{{if $indexItem.Unique}}    
				{{if $indexItem.Pk}}    
					actual, loaded := m.hash{{$indexItem.Keys}}.LoadOrStore({{$.DataName}}KeyTypeHash{{$indexItem.Keys}}{ {{$indexItem.ClsPointKeys}} }, cls)
					if !loaded {
						actual = cls
				{{else}}
					m.hash{{$indexItem.Keys}}.Store({{$.DataName}}KeyTypeHash{{$indexItem.Keys}}{ {{$indexItem.ClsPointKeys}} }, cls)
				{{end}}
			{{else}}
				if v, ok := m.hash{{$indexItem.Keys}}.LoadOrStore({{$.DataName}}KeyTypeHash{{$indexItem.Keys}}{ {{$indexItem.ClsPointKeys}} }, &{{$.DataName}}Set{}); !ok {
					v.Store(cls, true)
				} else {
					v.Store(cls, true)
				}
			{{end}}
	{{end}}
`

var indexRemoveItem = `
	{{if $.ArgsInfo.OptimizeFlagUsePoolAndDisableDeleteUnload}}
			{{if $indexItem.Unique}}    
			//	m.hash{{$indexItem.Keys}}.Delete({{$.DataName}}KeyTypeHash{{$indexItem.Keys}}{ {{$indexItem.ClsPointKeys}} })
			{{else}}
			//	if v, ok := m.hash{{$indexItem.Keys}}.Load({{$.DataName}}KeyTypeHash{{$indexItem.Keys}}{ {{$indexItem.ClsPointKeys}} }); ok {
			//		v.Delete(cls)
			//	}
			//	if v, ok := m.hash{{$indexItem.Keys}}.Load({{$.DataName}}KeyTypeHash{{$indexItem.Keys}}{ {{$indexItem.ClsPointKeys}} }); ok {
			//		has := false
			//		v.Range(func(key *{{$.ArgsInfo.PersistPkgName}}.{{$.DataName}}, value bool) bool {
			//			has = true
			//			return false
			//		})
			//		if !has {
			//			m.hash{{$indexItem.Keys}}.Delete({{$.DataName}}KeyTypeHash{{$indexItem.Keys}}{ {{$indexItem.ClsPointKeys}} })
			//		}
			//	}
			{{end}}
	{{else}}
			{{if $indexItem.Unique}}    
				m.hash{{$indexItem.Keys}}.Delete({{$.DataName}}KeyTypeHash{{$indexItem.Keys}}{ {{$indexItem.ClsPointKeys}} })
			{{else}}
				if v, ok := m.hash{{$indexItem.Keys}}.Load({{$.DataName}}KeyTypeHash{{$indexItem.Keys}}{ {{$indexItem.ClsPointKeys}} }); ok {
					v.Delete(cls)
				}
				if v, ok := m.hash{{$indexItem.Keys}}.Load({{$.DataName}}KeyTypeHash{{$indexItem.Keys}}{ {{$indexItem.ClsPointKeys}} }); ok {
					has := false
					v.Range(func(key *{{$.ArgsInfo.PersistPkgName}}.{{$.DataName}}, value bool) bool {
						has = true
						return false
					})
					if !has {
						m.hash{{$indexItem.Keys}}.Delete({{$.DataName}}KeyTypeHash{{$indexItem.Keys}}{ {{$indexItem.ClsPointKeys}} })
					}
				}
			{{end}}
	{{end}}
`

var Main = `// Code generated by persist. DO NOT EDIT.
// source: {{.ArgsInfo.FileName}}

package {{.PackageName}}

import (
	"xorm.io/xorm"
	"encoding/base64"
	"encoding/binary"
	"math"
	"encoding/json"
	jsoniter "github.com/json-iterator/go"
	"runtime/debug"
	"menet/log"
	{{if $.HaveRBTree}}
	rbtree "menet/stl/rbtree"
	{{end}}
	"sync"
	"reflect"
	"time"
	"github.com/getsentry/sentry-go"
	"strings"
{{if $.ArgsInfo.Save}}
	"errors"
	"bytes"
	{{if .HashIndexPk}}    
		"xorm.io/core"
	{{else}}
	{{end}}
	"menet/util"
	"os"
	"sync/atomic"
	"runtime"
	"io/ioutil"
	{{.DSImport}}
{{end}}
	persistCore "menet/persist/core"
{{if ne .ArgsInfo.PersistPkgPath ""}}
	"{{.ArgsInfo.PersistPkgPath}}"
{{end}}
)

// 警告:
// 内部接口禁止调用(仅供内部 和 测试代码使用)
// SaveDB, DataToFailQueue, LoadFile, SaveFile, RemoveFile
// RecoverBomb, MergeQueue, AsyncSave, Collect, CheckOverload

// 工具接口, 无副作用, 按需使用
// BytesToPersist, PersistToBytes, PersistToPersistByBitSet, BytesToPersistSync, PersistSyncToBytes,
// StringToPersistSync, PersistSyncToString, UnmarshalFailQueue, MarshalFailQueue

// 需要先导入数据再使用
// 除以下接口不需要先导入, 其他接口必须 先导入! 先导入! 先导入!
// Run, Dead, Load LoadAll, Exit, Sync, SyncData(补救没有标记写回数据, 代码正确不需要使用)

// 其他接口
// New Delete 接口按需使用
// 尽量使用MarkUpdateByBitSet 多个修改一起提交
// 只修改单条数据使用MarkUpdateByFieldIndex 
// 少用或者不用MarkUpdate 全标记开销太大, 除非业务太复杂想不清楚

// 支持 hash index:[group,unique], 不支持 tree index
// op 1:insert 2:update 3:delete 4:unload

// 对象序列化接口 string, slice, array, map json序列化,
// 第一版二进制结构：
// 		指针结构：含1字节标识位(0000 0001 是否nil) + 其他
// 		string, slice, map, 复杂结构， 结构体等： 4字节长度 + ToDB|json.Marshal长度
// 		其他简单基础结构：按照最大字节存储
// 		core.Conversion 只会检查指针 例如:
// 			(m *Persist) FromDB(data []byte) error
// 			(m *Persist) ToDB(data []byte, err error)
// 自定义解析字段， 暂时不允许是其他包的结构，分析引入关系比较复杂

// 待优化功能: 
// 1: LoadMany方法, 一次导入多个玩家数据
// 2: 优化对象序列化大小，添加tag 一定程度兼容新旧结构, 支持更多的类型优化

{{/* 定义常量 }}
const (

	EPersistManagerStateIdle   = 0 // 初始化 
	EPersistManagerStateNormal = 1 // 正常运行
	EPersistManagerStatePanic  = 2 // 非法停止 

	EPersistTableStateDisk      = 0 // 导出
	EPersistTableStateLoading   = 1 // 全导入开始
	EPersistTableStateMemory    = 2 // 全导入完成
	EPersistTableStateUnloading = 3 // 正在全导出

	EPersistLoadStateDisk             = 0 // 不存在 or 导出
	EPersistLoadStateLoading          = 1 // 导入开始
	EPersistLoadStateMemory           = 2 // 导入完成
	EPersistLoadStatePrepareUnloading = 3 // 准备导出
	EPersistLoadStateUnloading        = 4 // 正在导出

	EPersistOpInsert = 1 // 新建
	EPersistOpUpdate = 2 // 修改
	EPersistOpDelete = 3 // 删除
	EPersistOpUnload = 4 // 导出

	EPersistCollectStateNormal    = 0 // 正常
	EPersistCollectStateSaveSync  = 1 // 开始退出, 清理同步队列
	EPersistCollectStateSaveCache = 2 // 开始退出,清理缓存队列
	EPersistCollectStateSaveDone  = 3 // 写回完成

)
{{*/}}
const (

	E{{.DataName}}ManagerStateIdle   = 0 // 初始化
	E{{.DataName}}ManagerStateNormal = 1 // 正常运行
	E{{.DataName}}ManagerStatePanic  = 2 // 非法停止

	E{{.DataName}}TableStateDisk      = 0 // 导出
	E{{.DataName}}TableStateLoading   = 1 // 全导入开始
	E{{.DataName}}TableStateMemory    = 2 // 全导入完成
	E{{.DataName}}TableStateUnloading = 3 // 正在全导出

	E{{.DataName}}LoadStateDisk             = 0 // 不存在 or 导出
	E{{.DataName}}LoadStateLoading          = 1 // 导入开始
	E{{.DataName}}LoadStateMemory           = 2 // 导入完成
	E{{.DataName}}LoadStatePrepareUnloading = 3 // 准备导出
	E{{.DataName}}LoadStateUnloading        = 4 // 正在导出

	E{{.DataName}}OpInsert = 1 // 新建
	E{{.DataName}}OpUpdate = 2 // 修改
	E{{.DataName}}OpDelete = 3 // 删除
	E{{.DataName}}OpUnload = 4 // 导出

	E{{.DataName}}CollectStateNormal    = 0 // 正常
	E{{.DataName}}CollectStateSaveSync  = 1 // 开始退出, 清理同步队列
	E{{.DataName}}CollectStateSaveCache = 2 // 开始退出,清理缓存队列
	E{{.DataName}}CollectStateSaveDone  = 3 // 写回完成

)

{{/* 切表}}
{{*/}}
{{if ne $.ArgsInfo.SwitchTable ""}}
{{/* reflect struct }}
var PersistTableName string = ""// 记录表名 缓存
const PersistSwitchDay string = "{{$.ArgsInfo.SwitchTable}}" // 切表间隔 天数

func GetPersistTableName() string {
	var unsafePData = (*unsafe.Pointer)(unsafe.Pointer(&PersistTableName))
	dataPoint := (*string)(atomic.LoadPointer(unsafePData))
	if dataPoint == nil {
		return "PersistTableName"
	}
	return *dataPoint
}

func ChangePersistTableName(name string) {
	var unsafePData = (*unsafe.Pointer)(unsafe.Pointer(&PersistTableName))
	atomic.StorePointer(unsafePData, unsafe.Pointer(&name))
}
{{*/}}

var {{.DataName}}TableName string = "" // 记录表名 缓存
const {{.DataName}}SwitchDay string = "{{$.ArgsInfo.SwitchTable}}" // 切表间隔 天数

func Get{{.DataName}}TableName() string {
	var unsafePData = (*unsafe.Pointer)(unsafe.Pointer(&{{.DataName}}TableName))
	dataPoint := (*string)(atomic.LoadPointer(unsafePData))
	if dataPoint == nil {
		return "{{.DataName}}"
	}
	return *dataPoint
}

func Change{{.DataName}}TableName(name string) {
	var unsafePData = (*unsafe.Pointer)(unsafe.Pointer(&{{.DataName}}TableName))
	atomic.StorePointer(unsafePData, unsafe.Pointer(&name))
}
{{end}}

{{/* 定义在其他包, 需要冲定义类型 }}
type Server = center_data.Server
{{*/}}
{{if ne .ArgsInfo.PersistPkgPath ""}}
type {{.DataName}} = {{.ArgsInfo.PersistPkgName}}.{{.DataName}}
{{end}}

{{/* 接口 DeepCopy Overload }}
{{if $.ArgsInfo.Save}}
	// PersistDeepCopy persist对象必须支持并发访问, 不实现该接口默认深拷贝对象 (1 建议实现该接口,反射效率较低  2 map 建议生成syncmap  3 slice 建议深拷贝)
	type PersistDeepCopy interface {
		CopyTo(t *Persist)
	}
	// PersistOverload 未落地数据超过阈值时调用
	type PersistOverload interface {
		Overload(queueSize int, lastWriteBackTime time.Duration)
	}
{{end}}
{{*/}}
{{if $.ArgsInfo.Save}}
	// {{.DataName}}DeepCopy persist对象必须支持并发访问, 不实现该接口默认深拷贝对象 (1 建议实现该接口,反射效率较低  2 map 建议生成syncmap  3 slice 建议深拷贝)
	type {{.DataName}}DeepCopy interface {
		CopyTo(t *{{.ArgsInfo.PersistPkgName}}.{{.DataName}})
	}
	// {{.DataName}}Overload 未落地数据超过阈值时调用
	type {{.DataName}}Overload interface {
		Overload(queueSize int, lastWriteBackTime time.Duration)
	}
{{end}}



{{/* 生成联合索引Key结构体 }}
type PersistUidId struct {
	Uid int32
	Id  int32
}
type PersistUid struct {
	Uid int32
}
{{*/}}
{{range $i, $v := .HashIndexList}}
	type {{$.DataName}}{{$v.Keys}} struct {
		{{range $ii, $vv := $v.Cols }}    {{index $v.Cols $ii}} {{index $v.Types $ii}}
		{{end}}
	}
{{end}}

{{/* 生成联合索引Key类型定义 }}
type PersistKeyTypeHashUidId = PersistUidId
//type PersistKeyTypeHashUid = PersistUid
{{*/}}
{{range $i, $v := .HashIndexList}}
	type {{$.DataName}}KeyTypeHash{{$v.Keys}} = {{$.DataName}}{{$v.Keys}}
{{end}}

// {{$.DataName}}Manager 索引类型定义

{{/* 生成索引类型定义 }}
// only define type PersistHashUidId map[PersistKeyTypeHashUidId]*Persist
// only define type PersistHashUid map[PersistKeyTypeHashUid]*Persist
// only define type PersistHashUidIdMark map[PersistKeyTypeHashUidId]bool
// only define type PersistHashUid map[int32]map[*Persist]bool
{{*/}}

{{if .HashIndexPk}}    
	// only define type {{$.DataName}}Hash{{.HashIndexPk.Keys}}Mark map[{{$.DataName}}KeyTypeHash{{.HashIndexPk.Keys}}]bool
{{else}}

{{end}}

{{range $i, $v := .HashIndexList}}
	{{if $v.Unique}}    
		// only define type {{$.DataName}}Hash{{$v.Keys}} map[{{$.DataName}}KeyTypeHash{{$v.Keys}}]*{{$.ArgsInfo.PersistPkgName}}.{{$.DataName}}
	{{else}}
		// only define type {{$.DataName}}Hash{{$v.Keys}} map[{{$.DataName}}KeyTypeHash{{$v.Keys}}]map[*{{$.ArgsInfo.PersistPkgName}}.{{$.DataName}}]bool
	{{end}}
{{end}}


{{/* BitSet }}
// PersistFieldIndex 所有列index枚举
// PersistBitSet begin
// 读ast计算FieldLength 生成所有字段常量 0~length
type PersistFieldIndex uint

const EPersistFieldIndexZero PersistFieldIndex = 0
const EPersistFieldIndexUid PersistFieldIndex = 0
const EPersistFieldIndexId PersistFieldIndex = 1
const EPersistFieldIndexValue PersistFieldIndex = 5
const EPersistFieldIndexValueMap PersistFieldIndex = 7
const EPersistFiledIndexLength PersistFieldIndex = 70

var PersistStructFiledMap = [EPersistFiledIndexLength]string{"Uid", "Id", "Stage", "State1", "Time", "Value", "String", "ValueMap"}
var PersistDBFiledMap [EPersistFiledIndexLength]string

// EPersistWordSize the EPersistWordSize of a bit set
const EPersistWordSize = PersistFieldIndex(64)

// EPersistLog2WordSize is lg(EPersistWordSize)
const EPersistLog2WordSize = PersistFieldIndex(6)

// EPersistAllBits has every bit set
const EPersistAllBits uint64 = 0xffffffffffffffff

type PersistBitSet struct {
	set [(EPersistFiledIndexLength >> EPersistLog2WordSize) + 1]uint64
}

// Get whether bit i is set.
func (b *PersistBitSet) Get(i PersistFieldIndex) bool {
	if i >= EPersistFiledIndexLength {
		return false
	}
	return b.set[i>>EPersistLog2WordSize]&(1<<(i&(EPersistWordSize-1))) != 0
}

// Set bit i to 1
func (b *PersistBitSet) Set(i PersistFieldIndex) *PersistBitSet {
	if i >= EPersistFiledIndexLength {
		return nil
	}
	b.set[i>>EPersistLog2WordSize] |= 1 << (i & (EPersistWordSize - 1))
	return b
}

func (b *PersistBitSet) Clear(i PersistFieldIndex) *PersistBitSet {
	if i >= EPersistFiledIndexLength {
		return b
	}
	b.set[i>>EPersistLog2WordSize] &^= 1 << (i & (EPersistWordSize - 1))
	return b
}

// Merge compare to b
func (b *PersistBitSet) Merge(compare PersistBitSet) *PersistBitSet {
	for i, word := range b.set {
		b.set[i] = word | compare.set[i]
	}
	return b
}

func (b *PersistBitSet) ClearAll() *PersistBitSet {
	if b != nil {
		for i := range b.set {
			b.set[i] = 0
		}
	}
	return b
}

func (b *PersistBitSet) SetAll() *PersistBitSet {
	if b != nil {
		for i := range b.set {
			b.set[i] = EPersistAllBits
		}
	}
	return b
}

func (b *PersistBitSet) IsSetAll() bool {
	if b != nil {
		for i := range b.set {
			if b.set[i] != EPersistAllBits {
				return false
			}
		}
	}
	return true
}

// PersistBitSet end
{{*/}}

// {{$.DataName}}FieldIndex 所有列index枚举
// {{$.DataName}}BitSet begin
// 读ast计算FieldLength 生成所有字段常量 0~length
type {{$.DataName}}FieldIndex = uint

const E{{$.DataName}}FieldIndexZero {{$.DataName}}FieldIndex = 0
{{range $i, $v := .FieldNameList}}
	const E{{$.DataName}}FieldIndex{{$v}} {{$.DataName}}FieldIndex = {{$i}}
{{end}}
const E{{$.DataName}}FiledIndexLength {{$.DataName}}FieldIndex = {{len .FieldNameList}}

var {{$.DataName}}StructFiledMap = [E{{$.DataName}}FiledIndexLength]string{
{{range $i, $v := .FieldNameList}}    "{{$v}}",
{{end}}
}

var {{$.DataName}}DBFiledMap [E{{$.DataName}}FiledIndexLength]string




// E{{$.DataName}}WordSize the E{{$.DataName}}WordSize of a bit set
const E{{$.DataName}}WordSize = {{$.DataName}}FieldIndex(64)

// E{{$.DataName}}Log2WordSize is lg(E{{$.DataName}}WordSize)
const E{{$.DataName}}Log2WordSize = {{$.DataName}}FieldIndex(6)

// E{{$.DataName}}AllBits has every bit set
const E{{$.DataName}}AllBits uint64 = 0xffffffffffffffff

type {{$.DataName}}BitSet struct {
	set [(E{{$.DataName}}FiledIndexLength >> E{{$.DataName}}Log2WordSize) + 1]uint64
}

// Get whether bit i is set.
func (b *{{$.DataName}}BitSet) Get(i {{$.DataName}}FieldIndex) bool {
	if i >= E{{$.DataName}}FiledIndexLength {
		return false
	}
	return b.set[i>>E{{$.DataName}}Log2WordSize]&(1<<(i&(E{{$.DataName}}WordSize-1))) != 0
}

// Set bit i to 1
func (b *{{$.DataName}}BitSet) Set(i {{$.DataName}}FieldIndex) *{{$.DataName}}BitSet {
	if i >= E{{$.DataName}}FiledIndexLength {
		return nil
	}
	b.set[i>>E{{$.DataName}}Log2WordSize] |= 1 << (i & (E{{$.DataName}}WordSize - 1))
	return b
}

func (b *{{$.DataName}}BitSet) Clear(i {{$.DataName}}FieldIndex) *{{$.DataName}}BitSet {
	if i >= E{{$.DataName}}FiledIndexLength {
		return b
	}
	b.set[i>>E{{$.DataName}}Log2WordSize] &^= 1 << (i & (E{{$.DataName}}WordSize - 1))
	return b
}

// Merge compare to b
func (b *{{$.DataName}}BitSet) Merge(compare {{$.DataName}}BitSet) *{{$.DataName}}BitSet {
	for i, word := range b.set {
		b.set[i] = word | compare.set[i]
	}
	return b
}

func (b *{{$.DataName}}BitSet) ClearAll() *{{$.DataName}}BitSet {
	if b != nil {
		for i := range b.set {
			b.set[i] = 0
		}
	}
	return b
}

func (b *{{$.DataName}}BitSet) SetAll() *{{$.DataName}}BitSet {
	if b != nil {
		for i := range b.set {
			b.set[i] = E{{$.DataName}}AllBits
		}
	}
	return b
}

func (b *{{$.DataName}}BitSet) IsSetAll() bool {
	if b != nil {
		for i := range b.set {
			if b.set[i] != E{{$.DataName}}AllBits {
				return false
			}
		}
	}
	return true
}

// {{$.DataName}}BitSet end



// {{.DataName}}Sync 结构定义
{{/* 同步结构类型定义 }}
type PersistSync struct {
	Data   *Persist
	Op     int8
	BitSet PersistBitSet

}
{{*/}}
type {{.DataName}}Sync struct {
	Data   *{{.ArgsInfo.PersistPkgName}}.{{.DataName}}
	Op     int8
	BitSet {{.DataName}}BitSet
}




// {{.DataName}}Manager 结构定义

{{/* 生成索引类型定义 }}
type PersistManager struct {
{{if $.ArgsInfo.Save}}    
	// 0:初始化  1:正常运行  2:非法停止
	managerState  int32
	// 0:导出  1:全导入开始  2:全导入完成  3:正在全导出
	loadAll	      int32
	// 不存在 or 0:导出  1:导入开始  2:导入完成  3:准备导出  4:正在导出
	loadUnloadKeyMap    PersistMapUnload // map[UnloadKey]state 
	pool          *sync.Pool
	syncChan      chan *PersistSync
	syncQueue 	  *[]*PersistSync
	cacheQueue 	  *[]*PersistSync
	FailQueue     []*PersistSync
	lastWriteBackTime time.Duration
{{if .ArgsInfo.OptimizeFlagSQLInsertMerge}}
	InsertQueue   []*PersistSync
{{end}}
	syncBegin     chan bool
	syncEnd       chan bool
	exitBegin     chan bool
	exitEnd       chan bool
{{end}}
	engine        *xorm.Engine
	hashUidId     PersistHashUidId 
	hashUid       PersistHashUid 
	// hashUidIdMark PersistHashUidIdMark

	{{if .ArgsInfo.OptimizeFlagIndexMutex}}
		hashStateMutex sync.RWMutex // PersistHashStateMutex
	{{end}}

	{{if .ArgsInfo.OptimizeFlagUsePoolAndDisableDeleteUnload}}
		objectPool    AccountGlobalObjectPool
		objectMapPool AccountGlobalObjectMapPool
	{{end}}

	bitSetAll PersistBitSet
}
{{*/}}
type {{.DataName}}Manager struct {
{{if $.ArgsInfo.Save}}    
	// 0:初始化  1:正常运行  2:非法停止
	managerState  int32
	// 0:导出  1:全导入开始  2:全导入完成  3:正在全导出
    loadAll       int32

	{{if .HashIndexUnload}}
		// 不存在 or 0:导出  1:导入开始  2:导入完成  3:准备导出  4:正在导出
		load{{index .HashIndexUnload.Cols 0}}Map    {{.DataName}}MapUnload // map[{{index .HashIndexUnload.Cols 0}}]state(atom) 
	{{end}}
	pool          *sync.Pool
	syncChan      chan *{{.DataName}}Sync
	syncQueue 	  *[]*{{.DataName}}Sync
	cacheQueue 	  *[]*{{.DataName}}Sync
	FailQueue     []*{{.DataName}}Sync
	lastWriteBackTime time.Duration
	{{if .ArgsInfo.OptimizeFlagSQLInsertMerge}}
		InsertQueue   []*{{.DataName}}Sync
	{{end}}
	syncBegin     chan bool
	syncEnd       chan bool
	exitBegin     chan bool
	exitEnd       chan bool
{{end}}
	engine        *xorm.Engine
{{range $i, $v := .HashIndexList}}
	hash{{$v.Keys}} {{$.DataName}}Hash{{$v.Keys}}
{{end}}

{{if .ArgsInfo.OptimizeFlagUsePoolAndDisableDeleteUnload}}
	objectPool    {{$.DataName}}ObjectPool
	objectMapPool {{$.DataName}}ObjectMapPool
{{end}}

{{if .HashIndexPk}}    
	// hash{{.HashIndexPk.Keys}}Mark {{$.DataName}}Hash{{.HashIndexPk.Keys}}Mark 
{{else}}

{{end}}
{{if .ArgsInfo.OptimizeFlagIndexMutex}}
	{{range $i, $v := .HashIndexList}}
		hash{{$v.Keys}}Mutex sync.RWMutex // {{$.DataName}}Hash{{$v.Keys}}Mutex
	{{end}}
{{end}}
	bitSetAll {{$.DataName}}BitSet

	{{if $.HaveRBTree}}
	RBTree *rbtree.RBTree[{{$.DataName}}RBTreeKey]
	{{end}}
}

{{/* reflect struct }}
var gPersistNil = &Persist{}
{{*/}}
var g{{.DataName}}Nil = &{{.ArgsInfo.PersistPkgName}}.{{.DataName}}{}


{{/* new manage }}
func NewPersistManager(engine *xorm.Engine) (m *PersistManager) {
	m = &PersistManager{engine:engine}
{{if $.ArgsInfo.Save}}    
	m.syncChan = make(chan *PersistSync, runtime.NumCPU()*2)
	tmpSyncQueue := make([]*PersistSync, 0)
	m.syncQueue = &tmpSyncQueue
	m.syncEnd = make(chan bool)
	m.syncBegin = make(chan bool)
	m.exitBegin = make(chan bool)
	m.exitEnd = make(chan bool)
	tmpCacheQueue := make([]*PersistSync, 0)
	m.cacheQueue = &tmpCacheQueue
	m.lastWriteBackTime = 1 * time.Millisecond
	m.pool = &sync.Pool{New: func() interface{} { return &Persist{} }}
{{end}}

{{if .ArgsInfo.OptimizeFlagUsePoolAndDisableDeleteUnload}}
	m.hashUid.Init()
	m.hashAccountName.Init()
{{end}}
	m.bitSetAll.SetAll()

	if engine != nil {
		for idx, name := range {{.DataName}}StructFiledMap {
			{{.DataName}}DBFiledMap[idx] = engine.GetColumnMapper().Obj2Table(name)
		}
	}
	return
}
{{*/}}
func New{{.DataName}}Manager(engine *xorm.Engine) (m *{{.DataName}}Manager) {
	m = &{{.DataName}}Manager{engine:engine}
{{if $.ArgsInfo.Save}}    
	m.syncChan = make(chan *{{.DataName}}Sync, runtime.NumCPU()*2)
	tmpSyncQueue := make([]*{{.DataName}}Sync, 0)
	m.syncQueue = &tmpSyncQueue
	m.syncEnd = make(chan bool)
	m.syncBegin = make(chan bool)
	m.exitBegin = make(chan bool)
	m.exitEnd = make(chan bool)
	tmpCacheQueue := make([]*{{.DataName}}Sync, 0)
	m.cacheQueue = &tmpCacheQueue
	m.lastWriteBackTime = 1 * time.Millisecond
	m.pool = &sync.Pool{New: func() interface{} { return &{{.ArgsInfo.PersistPkgName}}.{{.DataName}}{} }}
{{end}}

{{if .ArgsInfo.OptimizeFlagUsePoolAndDisableDeleteUnload}}
	{{range $i, $v := .HashIndexList}}
		m.hash{{$v.Keys}}.Init()
	{{end}}
{{end}}
	m.bitSetAll.SetAll()

	if engine != nil {
		for idx, name := range {{.DataName}}StructFiledMap {
			{{.DataName}}DBFiledMap[idx] = engine.GetColumnMapper().Obj2Table(name)
		}
	}
	{{if $.HaveRBTree}}
	// 在data包中实现这个 
	// 实现示例如下:
	//func InitDescGlobalLess() {
	//LessDescGlobal = func(a, b DescGlobalRBTreeKey) bool {
	//	if a.Value.Lv <b.Value.Lv {
	//		return true
	//	} else if a.Value.Lv > b.Value.Lv {
	//		return false
	//	} else {
	//		// 如果存在第二参数 就比较第二个参数,不存在就去比较主键
	//		if a.Key.Uid < b.Key.Uid {
	//			return true
	//		} else if a.Key.Uid > b.Key.Uid {
	//			return false
	//		} else{
	//			return a.Key.Uuid < b.Key.Uuid	
	//		}
	//	}
	//}

	Init{{.DataName}}Less()
	if Less{{$.DataName}} == nil {
		panic("not fount less")
	}
	m.CreateRBTree({{$.ArgsInfo.RBTreeCap}},Less{{.DataName}})
	{{end}}
	return
}

{{/* new object }}
// NewPersist 通过主键创建对象, 已经存在直接返回. (1 数据没有导入或已经导出) 会返回nil. (2 数据已存在) 返回已存在的值
func NewPersist(Uid int32, Id int32) (ormCls *Persist) {
	{{if $.ArgsInfo.Save}}
		{{if .HashIndexUnload}}
			if GPersistManager.LoadState(Uid) != EPersistLoadStateMemory {
				ormCls = nil
				return
			}
		{{end}}
	{{end}}

	ormCls = GPersistManager.GetPersistByUidId(Uid, Id)
	if ormCls != nil {
		return
	}

	ormCls, _ = GPersistManager.NewPersist(&Persist{Uid: Uid, Id: Id})
	return
}
{{*/}}
{{if .HasGlobalFuncNewPersist}}
	{{if .HashIndexPk}}
		// New{{.DataName}} 通过主键创建对象, 已经存在直接返回. (1 数据没有导入或已经导出) 会返回nil. (2 数据已存在) 返回已存在的值
		func New{{.DataName}}({{.HashIndexPk.KeyTypes}}) (ormCls *{{.ArgsInfo.PersistPkgName}}.{{.DataName}}) {
			{{if $.ArgsInfo.Save}}
				{{if .HashIndexUnload}}
					if G{{.DataName}}Manager.LoadState({{index .HashIndexUnload.Cols 0}}) != E{{.DataName}}LoadStateMemory {
						ormCls = nil
						return
					}
				{{end}}
			{{end}}

			ormCls = G{{.DataName}}Manager.Get{{.DataName}}By{{.HashIndexPk.Keys}}( {{.HashIndexPk.CommaKeys}} )
			if ormCls != nil {
				return
			}
			ormCls, _ = G{{.DataName}}Manager.New{{.DataName}}(&{{.ArgsInfo.PersistPkgName}}.{{.DataName}}{ {{.HashIndexPk.CommaKeyKeys}} })
			return
		}
	{{else}}
	{{end}}
{{else}}
{{end}}

{{/* PersistName }}
// PersistName 返回persist类名
func (m *PersistManager) PersistName() string {
	return reflect.TypeOf(*gPersistNil).Name()
}
{{*/}}
// PersistName 返回persist类名
func (m *{{.DataName}}Manager) PersistName() string {
	return reflect.TypeOf(*g{{.DataName}}Nil).Name()
}

{{/* PersistName }}
// PersistObj 返回persist interface{}
func (m *PersistManager) PersistUserNilObjInterface() interface{} {
	return Persist{}
}

// PersistObj 返回persist interface{} list
func (m *{{.DataName}}Manager) PersistUserNilObjInterfaceList() interface{} {
	plist := make([]*{{.ArgsInfo.PersistPkgName}}.{{.DataName}},0,0)
	return &plist
}
{{*/}}

// PersistObj 返回persist interface{}
func (m *{{.DataName}}Manager) PersistUserNilObjInterface() interface{} {
	return &{{.ArgsInfo.PersistPkgName}}.{{.DataName}}{}
}
// PersistObj 返回persist interface{} list
func (m *{{.DataName}}Manager) PersistUserNilObjInterfaceList() interface{} {
	plist := make([]*{{.ArgsInfo.PersistPkgName}}.{{.DataName}},0,0)
	return &plist
}

{{/* Run }}
{{if $.ArgsInfo.Save}}    
// Run 运行并导入上次失败数据
func (m *PersistManager) Run() error {
	if atomic.CompareAndSwapInt32(&m.managerState, EPersistManagerStateIdle, EPersistManagerStateNormal) {
		if err := m.LoadFile(); err != nil {
			return err
		}
		go m.Collect()
	} else if atomic.CompareAndSwapInt32(&m.managerState, EPersistManagerStatePanic, EPersistManagerStateNormal) {
		if err := m.LoadFile(); err != nil {
			return err
		}
		go m.Collect()
	} else {
	}
	return nil
}
{{end}}
{{*/}}
{{if $.ArgsInfo.Save}}    
	// Run 运行并导入上次失败数据
	func (m *{{.DataName}}Manager) Run() error {
		if atomic.CompareAndSwapInt32(&m.managerState, E{{.DataName}}ManagerStateIdle, E{{.DataName}}ManagerStateNormal) {
			if err := m.LoadFile(); err != nil {
				return err
			}
			go m.Collect()
		} else if atomic.CompareAndSwapInt32(&m.managerState, E{{.DataName}}ManagerStatePanic, E{{.DataName}}ManagerStateNormal) {
			if err := m.LoadFile(); err != nil {
				return err
			}
			go m.Collect()
		} else {
		}
		return nil
	}
{{else}}
	// Run 运行并导入上次失败数据
	func (m *{{.DataName}}Manager) Run() {
	}
{{end}}


{{/* Dead }}
{{if $.ArgsInfo.Save}}    
// Dead 管理类是否出错
func (m *PersistManager) Dead() bool {
	return atomic.LoadInt32(&m.managerState) != EPersistManagerStateNormal
}
{{end}}
{{*/}}
{{if $.ArgsInfo.Save}}    
	// Dead 管理类是否出错
	func (m *{{.DataName}}Manager) Dead() bool {
		return atomic.LoadInt32(&m.managerState) != E{{.DataName}}ManagerStateNormal
	}
{{else}}
	// Dead 管理类是否出错
	func (m *{{.DataName}}Manager) Dead() bool {
		return true
	}
{{end}}


{{/* BytesToPersist }}
// BytesToPersist 反序列化
func (m *PersistManager) BytesToPersist(data []byte) (cls *Persist) {
	var err error
	if data == nil {
		return nil
	}
	defer func() {
		if r := recover(); r != nil {
			log.Println("recovered in ", r)
			log.Println("stack: ", string(debug.Stack()))
		}
		if err != nil {
			log.Println("BytesToPersist Error", err.Error())
		}
	}()
	i := 0
	cls = &Persist{}
	//Uid			int32
	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1
		cls.Uid = int32(binary.LittleEndian.Uint32(data[i:]))
		i += 32 / 8
	} else {
		i += 1
	}

	//Id			int32
	cls.Id = int32(binary.LittleEndian.Uint32(data[i:]))
	i += 4
	//Time			int64
	cls.Time = int64(binary.LittleEndian.Uint64(data[i:]))
	i += 8

	//String		string
	lenFieldDataString := int(binary.LittleEndian.Uint32(data[i:]))
	i += 4
	cls.String = string(data[i : i+lenFieldDataString])
	i += lenFieldDataString

	//ValueMap		map[int32]bool
	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		i += 1

		lenFieldDataValueMap := int(binary.LittleEndian.Uint32(data[i:]))
		i += 4
		err = jsoniter.ConfigCompatibleWithStandardLibrary.Unmarshal(data[i:i+lenFieldDataValueMap], &cls.ValueMap)
		if err != nil {
			log.Println("BytesToPersist ValueMap error ", err)
		}
		i += lenFieldDataValueMap
	} else {
		i += 1
	}

	//StructSyncMap  InnerSyncMap
	lenFieldDataStructSyncMap := int(binary.LittleEndian.Uint32(data[i:]))
	i += 4
	if v, ok := ((interface{})(&cls.StructSyncMap)).(core.Conversion); ok {
		err = v.FromDB(data[i : i+lenFieldDataStructSyncMap])
	} else {
		err = jsoniter.ConfigCompatibleWithStandardLibrary.Unmarshal(data[i:i+lenFieldDataStructSyncMap], &cls.StructSyncMap)
	}
	if err != nil {
		log.Println("BytesToPersist StructSyncMap error ", err)
	}
	i += lenFieldDataStructSyncMap

	//StringP        *string
	if data[i]&persistCore.EMarshalFlagPoint >= 1 {
		i += 1
		lenFieldDataStringP := int(binary.LittleEndian.Uint32(data[i:]))
		i += 4
		tmpFieldDataStringP := string(data[i : i+lenFieldDataStringP])
		cls.StringP = &tmpFieldDataStringP
		i += lenFieldDataStringP
	} else {
		i += 1
	}

	//StructSyncMapP *InnerSyncMap
	if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
		if data[i]&persistCore.EMarshalFlagPoint >= 1 {
			i += 1
			lenFieldDataStructSyncMapP := int(binary.LittleEndian.Uint32(data[i:]))
			i += 4
			// 自定义解析字段， 暂时不允许是其他包的结构，分析引入关系比较复杂
			cls.StructSyncMapP = &protocol.InnerSyncMap{}

			if v, ok := ((interface{})(cls.StructSyncMapP)).(core.Conversion); ok {
				err = v.FromDB(data[i : i+lenFieldDataStructSyncMapP])
			} else {
				err = jsoniter.ConfigCompatibleWithStandardLibrary.Unmarshal(data[i:i+lenFieldDataStructSyncMapP], &cls.StructSyncMapP)
			}
			if err != nil {
				log.Println("BytesToPersist StructSyncMapP error ", err)
			}
			i += lenFieldDataStructSyncMapP
		} else {
			i += 1
		}
	} else {
		i += 1
	}

	//SListMap []map[int32]bool
	lenFieldDataSListMap := int(binary.LittleEndian.Uint32(data[i:]))
	i += 4
	err = jsoniter.ConfigCompatibleWithStandardLibrary.Unmarshal(data[i:i+lenFieldDataSListMap], &cls.SListMap)
	if err != nil {
		log.Println("BytesToPersist SListMap error ", err)
	}
	i += lenFieldDataSListMap

	//Int32P 	*int32
	if data[i]&persistCore.EMarshalFlagPoint >= 1 {
		i += 1
		tmpFieldDataInt32P := int32(binary.LittleEndian.Uint32(data[i:]))
		cls.Int32P = &tmpFieldDataInt32P
		i += 4
	} else {
		i += 1
	}

	//Float32P		*float32
	if data[i]&persistCore.EMarshalFlagPoint >= 1 {
		i += 1
		tmpFieldDataFloat32P := math.Float32frombits(binary.LittleEndian.Uint32(data[i:]))
		cls.Float32P = &tmpFieldDataFloat32P
		i += 4
	} else {
		i += 1
	}

	//Int8		int8
	cls.Int8 = int8(data[i])
	i += 1

	//Bool		bool
	cls.Bool = data[i] != 0
	i += 1

	return
}
{{*/}}

func (m *{{.DataName}}Manager) BytesToPersistInterface(data []byte) (cls interface{}) {
	return m.BytesToPersist(data)
}

// BytesToPersist反序列化
func (m *{{.DataName}}Manager) BytesToPersist(data []byte) (cls *{{.ArgsInfo.PersistPkgName}}.{{.DataName}}) {
	var err error
	if data == nil {
		return nil
	}
	defer func() {
		if r := recover(); r != nil {
			log.Println("recovered in ", r)
			log.Println("stack: ", string(debug.Stack()))
		}
		if err != nil {
			log.Println("BytesToPersist Error", err.Error())
		}
	}()
	i := 0
	cls = &{{.ArgsInfo.PersistPkgName}}.{{.DataName}}{}

	{{range $i, $typeInfo := .FieldTypeList}}
		{{ $fieldName := index $.FieldNameList $i }}
		//{{ $fieldName }}	{{ $typeInfo.Name }}
		{{ if $typeInfo.IsBool }}

			{{ if $typeInfo.IsPoint }}
				if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
					if data[i]&persistCore.EMarshalFlagPoint >= 1 {
						i += 1
						tmpFieldData{{ $fieldName }} := data[i] != 0
						cls.{{ $fieldName }} = &tmpFieldData{{ $fieldName }}
						i += 1
					} else {
						i += 1
					}
				} else {
					i += 1
				}
			{{ else }}
				if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
					i += 1

					cls.{{ $fieldName }} = data[i] != 0
					i += 1
				} else {
					i += 1
				}
			{{ end }}

		{{ else if $typeInfo.IsInt8 }}

			{{ if $typeInfo.IsPoint }}
				if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
					if data[i]&persistCore.EMarshalFlagPoint >= 1 {
						i += 1
						tmpFieldData{{ $fieldName }} := {{ $typeInfo.Name }}(data[i])
						cls.{{ $fieldName }} = &tmpFieldData{{ $fieldName }}
						i += 1
					} else {
						i += 1
					}
				} else {
					i += 1
				}
			{{ else }}
				if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
					i += 1

					cls.{{ $fieldName }} = {{ $typeInfo.Name }}(data[i])
					i += 1
				} else {
					i += 1
				}
			{{ end }}

		{{ else if $typeInfo.IsInt }}

			{{ if $typeInfo.IsPoint }}
				if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
					if data[i]&persistCore.EMarshalFlagPoint >= 1 {
						i += 1
						tmpFieldData{{ $fieldName }} := {{ trimPrefix "*" $typeInfo.Name }}(binary.LittleEndian.Uint{{ $typeInfo.Bit }}(data[i:]))
						cls.{{ $fieldName }} = &tmpFieldData{{ $fieldName }}
						i += {{ $typeInfo.Bit }}/8
					} else {
						i += 1
					}
				} else {
					i += 1
				}
			{{ else }}
				if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
					i += 1

					cls.{{ $fieldName }} = {{ $typeInfo.Name }}(binary.LittleEndian.Uint{{ $typeInfo.Bit }}(data[i:]))
					i += {{ $typeInfo.Bit }}/8
				} else {
					i += 1
				}
			{{ end }}

		{{ else if $typeInfo.IsFloat }}

			{{ if $typeInfo.IsPoint }}
				if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
					if data[i]&persistCore.EMarshalFlagPoint >= 1 {
						i += 1
						tmpFieldData{{ $fieldName }} := math.Float{{ $typeInfo.Bit }}frombits(binary.LittleEndian.Uint{{ $typeInfo.Bit }}(data[i:]))
						cls.{{ $fieldName }} = &tmpFieldData{{ $fieldName }}
						i += {{ $typeInfo.Bit }}/8
					} else {
						i += 1
					}
				} else {
					i += 1
				}
			{{ else }}
				if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
					i += 1

					cls.{{ $fieldName }} = math.Float{{ $typeInfo.Bit }}frombits(binary.LittleEndian.Uint{{ $typeInfo.Bit }}(data[i:]))
					i += {{ $typeInfo.Bit }}/8
				} else {
					i += 1
				}
			{{ end }}

		{{ else if $typeInfo.IsString }}

			{{ if $typeInfo.IsPoint }}
				if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
					if data[i]&persistCore.EMarshalFlagPoint >= 1 {
						i += 1
						lenFieldData{{ $fieldName }} := int(binary.LittleEndian.Uint32(data[i:]))
						i += 4
						tmpFieldData{{ $fieldName }} := string(data[i : i+lenFieldData{{ $fieldName }}])
						cls.{{ $fieldName }} = &tmpFieldData{{ $fieldName }}
						i += lenFieldData{{ $fieldName }}
					} else {
						i += 1
					}
				} else {
					i += 1
				}
			{{ else }}
				if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
					i += 1

					lenFieldData{{ $fieldName }} := int(binary.LittleEndian.Uint32(data[i:]))
					i += 4
					cls.{{ $fieldName }} = string(data[i : i+lenFieldData{{ $fieldName }}])
					i += lenFieldData{{ $fieldName }}
				} else {
					i += 1
				}
			{{ end }}

		{{ else if $typeInfo.IsStruct }}

			{{ if $typeInfo.IsPoint }}
				if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
					if data[i]&persistCore.EMarshalFlagPoint >= 1 {
						i += 1
						lenFieldData{{ $fieldName }} := int(binary.LittleEndian.Uint32(data[i:]))
						i += 4
						// 自定义解析字段， 暂时不允许是其他包的结构，分析引入关系比较复杂
						cls.{{ $fieldName }} = &{{if ne $.ArgsInfo.PersistPkgPath ""}}{{$.ArgsInfo.PersistPkgName}}.{{end}}{{ trimPrefix "*" $typeInfo.Name }}{}

						if v, ok := ((interface{})(cls.{{ $fieldName }})).(core.Conversion); ok {
							err = v.FromDB(data[i : i+lenFieldData{{ $fieldName }}])
						} else {
							err = jsoniter.ConfigCompatibleWithStandardLibrary.Unmarshal(data[i:i+lenFieldData{{ $fieldName }}], &cls.{{ $fieldName }})
						}
						if err != nil {
							log.Println("BytesToPersist {{ $fieldName }} error ", err)
						}
						i += lenFieldData{{ $fieldName }}
					} else {
						i += 1
					}
				} else {
					i += 1
				}
			{{ else }}
				if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
					i += 1

					lenFieldData{{ $fieldName }} := int(binary.LittleEndian.Uint32(data[i:]))
					i += 4
					if v, ok := ((interface{})(&cls.{{ $fieldName }})).(core.Conversion); ok {
						err = v.FromDB(data[i : i+lenFieldData{{ $fieldName }}])
					} else {
						err = jsoniter.ConfigCompatibleWithStandardLibrary.Unmarshal(data[i:i+lenFieldData{{ $fieldName }}], &cls.{{ $fieldName }})
					}
					if err != nil {
						log.Println("BytesToPersist {{ $fieldName }} error ", err)
					}
					i += lenFieldData{{ $fieldName }}
				} else {
					i += 1
				}
			{{ end }}

		{{ else }}

			{{ if $typeInfo.IsPoint }}
				if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
					if data[i]&persistCore.EMarshalFlagPoint >= 1 {
						i += 1
						lenFieldData{{ $fieldName }} := int(binary.LittleEndian.Uint32(data[i:]))
						i += 4
						err = jsoniter.ConfigCompatibleWithStandardLibrary.Unmarshal(data[i:i+lenFieldData{{ $fieldName }}], &cls.{{ $fieldName }})
						if err != nil {
							log.Println("BytesToPersist {{ $fieldName }} error ", err)
						}
						i += lenFieldData{{ $fieldName }}
					} else {
						i += 1
					}
				} else {
					i += 1
				}
			{{ else }}
				if data[i]&persistCore.EMarshalFlagBitSet >= 1 {
					i += 1

					lenFieldData{{ $fieldName }} := int(binary.LittleEndian.Uint32(data[i:]))
					i += 4
					err = jsoniter.ConfigCompatibleWithStandardLibrary.Unmarshal(data[i:i+lenFieldData{{ $fieldName }}], &cls.{{ $fieldName }})
					if err != nil {
						log.Println("BytesToPersist {{ $fieldName }} error ", err)
					}
					i += lenFieldData{{ $fieldName }}
				} else {
					i += 1
				}
			{{ end }}

		{{ end }}

	{{end}}
	return
}


{{/* PersistToBytes }}
// PersistToBytes 序列化
func (m *PersistManager) PersistToBytes(cls *Persist, bitSet PersistBitSet) (data []byte) {
	var err error
	if cls == nil {
		return nil
	}
	defer func() {
		if r := recover(); r != nil {
			log.Println("recovered in ", r)
			log.Println("stack: ", string(debug.Stack()))
		}
		if err != nil {
			log.Println("PersistToBytes Error", err.Error())
		}
	}()
	size := 0
	//Uid            int32
	if isPk || bitSet.Get(EPersistFieldIndexUid) {
		size += 1 + 32/8
	} else {
		size += 1
	}

	//Id             int32
	size += 4
	//Time           int64
	size += 8

	//String         string
	size += 4 + len(cls.String)

	//ValueMap       map[int32]bool
	var fieldDataValueMap []byte
	if bitSet.Get(EPersistFieldIndexUid) {
		fieldDataValueMap, err = jsoniter.ConfigCompatibleWithStandardLibrary.Marshal(cls.ValueMap)
		if err != nil {
			log.Println("PersistToBytes ValueMap error ", err)
		}
		size += 1 + 4 + len(fieldDataValueMap)
	} else {
		size += 1
	}

	//StructSyncMap  InnerSyncMap
	var fieldDataStructSyncMap []byte
	if v, ok := ((interface{})(&cls.StructSyncMap)).(core.Conversion); ok {
		fieldDataStructSyncMap, err = v.ToDB()
	} else {
		fieldDataStructSyncMap, err = jsoniter.ConfigCompatibleWithStandardLibrary.Marshal(cls.StructSyncMap)
	}
	if err != nil {
		log.Println("PersistToBytes StructSyncMap error ", err)
	}
	size += 4 + len(fieldDataStructSyncMap)

	//StringP        *string
	if cls.StringP == nil {
		size += 1
	} else {
		size += 1 + 4 + len(cls.String)
	}

	//StructSyncMapP *InnerSyncMap
	var fieldDataStructSyncMapP []byte
	if bitSet.Get(EPersistFieldIndexUid) {
		if cls.StructSyncMapP == nil {
			size += 1
		} else {
			if v, ok := ((interface{})(cls.StructSyncMapP)).(core.Conversion); ok {
				fieldDataStructSyncMapP, err = v.ToDB()
			} else {
				fieldDataStructSyncMapP, err = jsoniter.ConfigCompatibleWithStandardLibrary.Marshal(cls.StructSyncMapP)
			}
			if err != nil {
				log.Println("PersistToBytes StructSyncMapP error ", err)
			}
			size += 1 + 4 + len(fieldDataStructSyncMapP)
		}
	} else {
		size += 1
	}

	//SListMap []map[int32]bool
	var fieldDataSListMap []byte
	fieldDataSListMap, err = jsoniter.ConfigCompatibleWithStandardLibrary.Marshal(cls.SListMap)
	if err != nil {
		log.Println("PersistToBytes SListMap error ", err)
	}
	size += 4 + len(fieldDataSListMap)

	//Int32P		*int32
	if cls.Int32P == nil {
		size += 1
	} else {
		size += 1 + 4
	}

	//Float32P		*float32
	if cls.Float32P == nil {
		size += 1
	} else {
		size += 1 + 4
	}

	//Int8		int8
	size += 1

	//Bool 		bool
	size += 1

	// ************************************ marshal ************************************
	data = make([]byte, size)
	i := 0
	//Uid           int32
	if isPk || bitSet.Get(EPersistFieldIndexUid) {
		data[i] |= persistCore.EMarshalFlagBitSet
		i += 1
		binary.LittleEndian.PutUint32(data[i:], uint32(cls.Uid))
		i += 32 / 8
	} else {
		i += 1
	}
	//Id			int32
	binary.LittleEndian.PutUint32(data[i:], uint32(cls.Id))
	i += 4
	//Time          int64
	binary.LittleEndian.PutUint64(data[i:], uint64(cls.Time))
	i += 8

	//String		string
	binary.LittleEndian.PutUint32(data[i:], uint32(len(cls.String)))
	i += 4
	copy(data[i:], cls.String)
	i += len(cls.String)

	//ValueMap       map[int32]bool
	binary.LittleEndian.PutUint32(data[i:], uint32(len(fieldDataValueMap)))
	i += 4
	copy(data[i:], fieldDataValueMap)
	i += len(fieldDataValueMap)

	//StructSyncMap  InnerSyncMap
	binary.LittleEndian.PutUint32(data[i:], uint32(len(fieldDataStructSyncMap)))
	i += 4
	copy(data[i:], fieldDataStructSyncMap)
	i += len(fieldDataStructSyncMap)

	//StringP        *string
	if bitSet.Get(EPersistFieldIndexUid) {
		data[i] |= persistCore.EMarshalFlagBitSet
		if cls.StringP == nil {
			i += 1
		} else {
			data[i] |= persistCore.EMarshalFlagPoint
			i += 1
			binary.LittleEndian.PutUint32(data[i:], uint32(len(*cls.StringP)))
			i += 4
			copy(data[i:], *cls.StringP)
			i += len(*cls.StringP)
		}
	} else {
		i += 1
	}


	//StructSyncMapP *InnerSyncMap
	if cls.StructSyncMapP == nil {
		i += 1
	} else {
		data[i] |= persistCore.EMarshalFlagPoint
		i += 1
		binary.LittleEndian.PutUint32(data[i:], uint32(len(fieldDataStructSyncMapP)))
		i += 4
		copy(data[i:], fieldDataStructSyncMapP)
		i += len(fieldDataStructSyncMapP)
	}

	//SListMap []map[int32]bool
	binary.LittleEndian.PutUint32(data[i:], uint32(len(fieldDataSListMap)))
	i += 4
	copy(data[i:], fieldDataSListMap)
	i += len(fieldDataSListMap)

	//Int32P		*int32
	if cls.Int32P == nil {
		i += 1
	} else {
		data[i] |= persistCore.EMarshalFlagPoint
		i += 1
		binary.LittleEndian.PutUint32(data[i:], uint32(*cls.Int32P))
		i += 4
	}

	//Float32P		*float32
	if cls.Float32P == nil {
		i += 1
	} else {
		data[i] |= persistCore.EMarshalFlagPoint
		i += 1
		binary.LittleEndian.PutUint32(data[i:], math.Float32bits(*cls.Float32P))
		i += 4
	}

	//Int8		int8
	data[i] = byte(cls.Int8)
	i += 1

	//Bool 		bool
	if cls.Bool {
		data[i] = 1
	} else {
		data[i] = 0
	}

	return
}
{{*/}}

//

{{/* PersistInterfaceToBytes }}
	func (m *PersistManager) PersistInterfaceToBytes(i interface{}) (data []byte) {
		return m.PersistToBytes(i.(*protocol.Persist), m.bitSetAll)
	}
{{*/}}

func (m *{{.DataName}}Manager) PersistInterfaceToBytes(i interface{}) (data []byte) {
	return m.PersistToBytes(i.(*{{.ArgsInfo.PersistPkgName}}.{{.DataName}}), m.bitSetAll)
}


{{/* PersistInterfaceToPkStruct }}
	func (m *PersistManager) PersistInterfaceToPkStruct(i interface{}) interface{} {
		cls, ok := i.(*protocol.Persist)
		if !ok {
			return nil
		}
		return PersistUidId{
			Uid: cls.Uid,
			Id:  cls.Id,
		}
	}
{{*/}}

func (m *{{.DataName}}Manager) PersistInterfaceToPkStruct(i interface{}) interface{} {
	cls, ok := i.(*{{.ArgsInfo.PersistPkgName}}.{{.DataName}})
	_ = cls
	if !ok {
		return nil
	}

	{{if .HashIndexPk}}
		pk := {{.DataName}}{{.HashIndexPk.Keys}}{
			{{range $i, $col := .HashIndexPk.Cols}}
				{{$col}}: cls.{{$col}},
			{{end}}
		}
		return pk
	{{else}}
		return nil
	{{end}}

	{{if $.ArgsInfo.Save}}
	{{else}}
	{{end}}
}



// PersistToBytes 序列化
func (m *{{.DataName}}Manager) PersistToBytes(cls *{{.ArgsInfo.PersistPkgName}}.{{.DataName}}, bitSet {{.DataName}}BitSet) (data []byte) {
	var err error
	if cls == nil {
		return nil
	}
	defer func() {
		if r := recover(); r != nil {
			log.Println("recovered in ", r)
			log.Println("stack: ", string(debug.Stack()))
		}
		if err != nil {
			log.Println("PersistToBytes Error", err.Error())
		}
	}()
	size := 0


	{{range $i, $typeInfo := .FieldTypeList}}
		{{ $fieldName := index $.FieldNameList $i }}
		//{{ $fieldName }}	{{ $typeInfo.Name }}
		{{ if $typeInfo.IsBool }}

			{{ if $typeInfo.IsPoint }}
				if {{ if $typeInfo.IsPk }} true || {{end}} bitSet.Get(E{{$.DataName}}FieldIndex{{ $fieldName }}) {
					if cls.{{ $fieldName }} == nil {
						size += 1
					} else {
						size += 1 + 1
					}
				} else {
					size += 1
				}
			{{ else }}
				if {{ if $typeInfo.IsPk }} true || {{end}} bitSet.Get(E{{$.DataName}}FieldIndex{{ $fieldName }}) {
					size += 1 + 1
				} else {
					size += 1
				}
			{{ end }}

		{{ else if $typeInfo.IsInt8 }}

			{{ if $typeInfo.IsPoint }}
				if {{ if $typeInfo.IsPk }} true || {{end}} bitSet.Get(E{{$.DataName}}FieldIndex{{ $fieldName }}) {
					if cls.{{ $fieldName }} == nil {
						size += 1
					} else {
						size += 1 + 1
					}
				} else {
					size += 1
				}

			{{ else }}
				if {{ if $typeInfo.IsPk }} true || {{end}} bitSet.Get(E{{$.DataName}}FieldIndex{{ $fieldName }}) {
					size += 1 + 1
				} else {
					size += 1
				}
			{{ end }}

		{{ else if $typeInfo.IsInt }}

			{{ if $typeInfo.IsPoint }}
				if {{ if $typeInfo.IsPk }} true || {{end}} bitSet.Get(E{{$.DataName}}FieldIndex{{ $fieldName }}) {
					if cls.{{ $fieldName }} == nil {
						size += 1
					} else {
						size += 1 + {{ $typeInfo.Bit }} / 8
					}
				} else {
					size += 1
				}
			{{ else }}
				if {{ if $typeInfo.IsPk }} true || {{end}} bitSet.Get(E{{$.DataName}}FieldIndex{{ $fieldName }}) {
					size += 1 + {{ $typeInfo.Bit }} / 8
				} else {
					size += 1
				}
			{{ end }}

		{{ else if $typeInfo.IsFloat }}

			{{ if $typeInfo.IsPoint }}
				if {{ if $typeInfo.IsPk }} true || {{end}} bitSet.Get(E{{$.DataName}}FieldIndex{{ $fieldName }}) {
					if cls.{{ $fieldName }} == nil {
						size += 1
					} else {
						size += 1 + {{ $typeInfo.Bit }} / 8
					}
				} else {
					size += 1
				}
			{{ else }}
				if {{ if $typeInfo.IsPk }} true || {{end}} bitSet.Get(E{{$.DataName}}FieldIndex{{ $fieldName }}) {
					size += 1 + {{ $typeInfo.Bit }} / 8
				} else {
					size += 1
				}
			{{ end }}

		{{ else if $typeInfo.IsString }}

			{{ if $typeInfo.IsPoint }}
				if {{ if $typeInfo.IsPk }} true || {{end}} bitSet.Get(E{{$.DataName}}FieldIndex{{ $fieldName }}) {
					if cls.{{ $fieldName }} == nil {
						size += 1
					} else {
						size += 1 + 4 + len(*cls.{{ $fieldName }})
					}
				} else {
					size += 1
				}
			{{ else }}
				if {{ if $typeInfo.IsPk }} true || {{end}} bitSet.Get(E{{$.DataName}}FieldIndex{{ $fieldName }}) {
					size += 1 + 4 + len(cls.{{ $fieldName }})
				} else {
					size += 1
				}
			{{ end }}

		{{ else if $typeInfo.IsStruct }}

			{{ if $typeInfo.IsPoint }}
				var fieldData{{ $fieldName }} []byte
				if {{ if $typeInfo.IsPk }} true || {{end}} bitSet.Get(E{{$.DataName}}FieldIndex{{ $fieldName }}) {
					if cls.{{ $fieldName }} == nil {
						size += 1
					} else {
						if v, ok := ((interface{})(cls.{{ $fieldName }})).(core.Conversion); ok {
							fieldData{{ $fieldName }}, err = v.ToDB()
						} else {
							fieldData{{ $fieldName }}, err = jsoniter.ConfigCompatibleWithStandardLibrary.Marshal(cls.{{ $fieldName }})
						}
						if err != nil {
							log.Println("PersistToBytes {{ $fieldName }} error ", err)
						}
						size += 1 + 4 + len(fieldData{{ $fieldName }})
					}
				} else {
					size += 1
				}
			{{ else }}
				var fieldData{{ $fieldName }} []byte
				if {{ if $typeInfo.IsPk }} true || {{end}} bitSet.Get(E{{$.DataName}}FieldIndex{{ $fieldName }}) {
					if v, ok := ((interface{})(&cls.{{ $fieldName }})).(core.Conversion); ok {
						fieldData{{ $fieldName }}, err = v.ToDB()
					} else {
						fieldData{{ $fieldName }}, err = jsoniter.ConfigCompatibleWithStandardLibrary.Marshal(cls.{{ $fieldName }})
					}
					if err != nil {
						log.Println("PersistToBytes {{ $fieldName }} error ", err)
					}
					size += 1 + 4 + len(fieldData{{ $fieldName }})
				} else {
					size += 1
				}
			{{ end }}

		{{ else }}

			{{ if $typeInfo.IsPoint }}
				var fieldData{{ $fieldName }} []byte
				if {{ if $typeInfo.IsPk }} true || {{end}} bitSet.Get(E{{$.DataName}}FieldIndex{{ $fieldName }}) {
					if cls.{{ $fieldName }} == nil {
						size += 1
					} else {
						fieldData{{ $fieldName }}, err = jsoniter.ConfigCompatibleWithStandardLibrary.Marshal(cls.{{ $fieldName }})
						if err != nil {
							log.Println("PersistToBytes {{ $fieldName }} error ", err)
						}
						size += 1 + 4 + len(fieldData{{ $fieldName }})
					}
				} else {
					size += 1
				}
			{{ else }}
				var fieldData{{ $fieldName }} []byte
				if {{ if $typeInfo.IsPk }} true || {{end}} bitSet.Get(E{{$.DataName}}FieldIndex{{ $fieldName }}) {
					fieldData{{ $fieldName }}, err = jsoniter.ConfigCompatibleWithStandardLibrary.Marshal(&cls.{{ $fieldName }})
					if err != nil {
						log.Println("PersistToBytes {{ $fieldName }} error ", err)
					}
					size += 1 + 4 + len(fieldData{{ $fieldName }})
				} else {
					size += 1
				}

			{{ end }}

		{{ end }}

	{{end}}

	// ************************************ marshal ************************************
	data = make([]byte, size)
	i := 0

	{{range $i, $typeInfo := .FieldTypeList}}
		{{ $fieldName := index $.FieldNameList $i }}
		//{{ $fieldName }}	{{ $typeInfo.Name }}

		{{ if $typeInfo.IsBool }}

			{{ if $typeInfo.IsPoint }}
				if {{ if $typeInfo.IsPk }} true || {{end}} bitSet.Get(E{{$.DataName}}FieldIndex{{ $fieldName }}) {
					data[i] |= persistCore.EMarshalFlagBitSet

					if cls.{{ $fieldName }} == nil {
						i += 1
					} else {
						data[i] |= persistCore.EMarshalFlagPoint
						i += 1
						if *cls.{{ $fieldName }} {
							data[i] = 1
						} else {
							data[i] = 0
						}
						i += 1
					}
				} else {
					i += 1
				}
			{{ else }}
				if {{ if $typeInfo.IsPk }} true || {{end}} bitSet.Get(E{{$.DataName}}FieldIndex{{ $fieldName }}) {
					data[i] |= persistCore.EMarshalFlagBitSet
					i += 1
					if cls.{{ $fieldName }} {
						data[i] = 1
					} else {
						data[i] = 0
					}
					i += 1
				} else {
					i += 1
				}
			{{ end }}

		{{ else if $typeInfo.IsInt8 }}

			{{ if $typeInfo.IsPoint }}
				if {{ if $typeInfo.IsPk }} true || {{end}} bitSet.Get(E{{$.DataName}}FieldIndex{{ $fieldName }}) {
					data[i] |= persistCore.EMarshalFlagBitSet

					if cls.{{ $fieldName }} == nil {
						i += 1
					} else {
						data[i] |= persistCore.EMarshalFlagPoint
						i += 1
						data[i] = byte(*cls.{{ $fieldName }})
						i += 1
					}
				} else {
					i += 1
				}

			{{ else }}
				if {{ if $typeInfo.IsPk }} true || {{end}} bitSet.Get(E{{$.DataName}}FieldIndex{{ $fieldName }}) {
					data[i] |= persistCore.EMarshalFlagBitSet
					i += 1

					data[i] = byte(cls.{{ $fieldName }})
					i += 1
				} else {
					i += 1
				}

			{{ end }}

		{{ else if $typeInfo.IsInt }}

			{{ if $typeInfo.IsPoint }}
				if {{ if $typeInfo.IsPk }} true || {{end}} bitSet.Get(E{{$.DataName}}FieldIndex{{ $fieldName }}) {
					data[i] |= persistCore.EMarshalFlagBitSet

					if cls.{{ $fieldName }} == nil {
						i += 1
					} else {
						data[i] |= persistCore.EMarshalFlagPoint
						i += 1
						binary.LittleEndian.PutUint{{ $typeInfo.Bit }}(data[i:], uint{{ $typeInfo.Bit }}(*cls.{{ $fieldName }}))
						i += {{ $typeInfo.Bit }} / 8
					}
				} else {
					i += 1
				}

			{{ else }}
				if {{ if $typeInfo.IsPk }} true || {{end}} bitSet.Get(E{{$.DataName}}FieldIndex{{ $fieldName }}) {
					data[i] |= persistCore.EMarshalFlagBitSet
					i += 1

					binary.LittleEndian.PutUint{{ $typeInfo.Bit }}(data[i:], uint{{ $typeInfo.Bit }}(cls.{{ $fieldName }}))
					i += {{ $typeInfo.Bit }} / 8
				} else {
					i += 1
				}

			{{ end }}

		{{ else if $typeInfo.IsFloat }}

			{{ if $typeInfo.IsPoint }}
				if {{ if $typeInfo.IsPk }} true || {{end}} bitSet.Get(E{{$.DataName}}FieldIndex{{ $fieldName }}) {
					data[i] |= persistCore.EMarshalFlagBitSet

					if cls.{{ $fieldName }} == nil {
						i += 1
					} else {
						data[i] |= persistCore.EMarshalFlagPoint
						i += 1
						binary.LittleEndian.PutUint{{ $typeInfo.Bit }}(data[i:], math.Float{{ $typeInfo.Bit }}bits(*cls.{{ $fieldName }}))
						i += {{ $typeInfo.Bit }} / 8
					}
				} else {
					i += 1
				}

			{{ else }}
				if {{ if $typeInfo.IsPk }} true || {{end}} bitSet.Get(E{{$.DataName}}FieldIndex{{ $fieldName }}) {
					data[i] |= persistCore.EMarshalFlagBitSet
					i += 1

					binary.LittleEndian.PutUint{{ $typeInfo.Bit }}(data[i:], math.Float{{ $typeInfo.Bit }}bits(cls.{{ $fieldName }}))
					i += {{ $typeInfo.Bit }} / 8
				} else {
					i += 1
				}

			{{ end }}

		{{ else if $typeInfo.IsString }}

			{{ if $typeInfo.IsPoint }}
				if {{ if $typeInfo.IsPk }} true || {{end}} bitSet.Get(E{{$.DataName}}FieldIndex{{ $fieldName }}) {
					data[i] |= persistCore.EMarshalFlagBitSet

					if cls.{{ $fieldName }} == nil {
						i += 1
					} else {
						data[i] |= persistCore.EMarshalFlagPoint
						i += 1
						binary.LittleEndian.PutUint32(data[i:], uint32(len(*cls.{{ $fieldName }})))
						i += 4
						copy(data[i:], *cls.{{ $fieldName }})
						i += len(*cls.{{ $fieldName }})
					}
				} else {
					i += 1
				}

			{{ else }}
				if {{ if $typeInfo.IsPk }} true || {{end}} bitSet.Get(E{{$.DataName}}FieldIndex{{ $fieldName }}) {
					data[i] |= persistCore.EMarshalFlagBitSet
					i += 1

					binary.LittleEndian.PutUint32(data[i:], uint32(len(cls.{{ $fieldName }})))
					i += 4
					copy(data[i:], cls.{{ $fieldName }})
					i += len(cls.{{ $fieldName }})
				} else {
					i += 1
				}

			{{ end }}

		{{ else if $typeInfo.IsStruct }}

			{{ if $typeInfo.IsPoint }}
				if {{ if $typeInfo.IsPk }} true || {{end}} bitSet.Get(E{{$.DataName}}FieldIndex{{ $fieldName }}) {
					data[i] |= persistCore.EMarshalFlagBitSet

					if cls.{{ $fieldName }} == nil {
						i += 1
					} else {
						data[i] |= persistCore.EMarshalFlagPoint
						i += 1
						binary.LittleEndian.PutUint32(data[i:], uint32(len(fieldData{{ $fieldName }})))
						i += 4
						copy(data[i:], fieldData{{ $fieldName }})
						i += len(fieldData{{ $fieldName }})
					}
				} else {
					i += 1
				}

			{{ else }}
				if {{ if $typeInfo.IsPk }} true || {{end}} bitSet.Get(E{{$.DataName}}FieldIndex{{ $fieldName }}) {
					data[i] |= persistCore.EMarshalFlagBitSet
					i += 1

					binary.LittleEndian.PutUint32(data[i:], uint32(len(fieldData{{ $fieldName }})))
					i += 4
					copy(data[i:], fieldData{{ $fieldName }})
					i += len(fieldData{{ $fieldName }})
				} else {
					i += 1
				}

			{{ end }}

		{{ else }}

			{{ if $typeInfo.IsPoint }}
				if {{ if $typeInfo.IsPk }} true || {{end}} bitSet.Get(E{{$.DataName}}FieldIndex{{ $fieldName }}) {
					data[i] |= persistCore.EMarshalFlagBitSet

					if cls.{{ $fieldName }} == nil {
						i += 1
					} else {
						data[i] |= persistCore.EMarshalFlagPoint
						i += 1
						binary.LittleEndian.PutUint32(data[i:], uint32(len(fieldData{{ $fieldName }})))
						i += 4
						copy(data[i:], fieldData{{ $fieldName }})
						i += len(fieldData{{ $fieldName }})
					}
				} else {
					i += 1
				}

			{{ else }}
				if {{ if $typeInfo.IsPk }} true || {{end}} bitSet.Get(E{{$.DataName}}FieldIndex{{ $fieldName }}) {
					data[i] |= persistCore.EMarshalFlagBitSet
					i += 1

					binary.LittleEndian.PutUint32(data[i:], uint32(len(fieldData{{ $fieldName }})))
					i += 4
					copy(data[i:], fieldData{{ $fieldName }})
					i += len(fieldData{{ $fieldName }})
				} else {
					i += 1
				}

			{{ end }}

		{{ end }}

	{{end}}
	return
}



{{/* PersistToPersistByBitSet }}
// PersistToPersistByBitSet 按位图复制数据
func (m *PersistManager) PersistToPersistByBitSet(dst, src *Persist, bitSet PersistBitSet) {
	var err error
	if dst == nil || src == nil {
		log.Println("PersistToPersistByBitSet Error, dst or src is nil")
		return
	}
	defer func() {
		if r := recover(); r != nil {
			log.Println("recovered in ", r)
			log.Println("stack: ", string(debug.Stack()))
		}
		if err != nil {
			log.Println("PersistToPersistByBitSet Error", err.Error())
		}
	}()

	//Uid	int32

	if bitSet.Get(EPersistFieldIndexUid) {
		dst.Uid = src.Uid
	}
	// ...

	return
}
{{*/}}


// PersistToPersistByBitSet 按位图复制数据
func (m *{{.DataName}}Manager) PersistToPersistByBitSet(dst, src *{{.ArgsInfo.PersistPkgName}}.{{.DataName}}, bitSet {{.DataName}}BitSet) {
	var err error
	if dst == nil || src == nil {
		log.Println("PersistToPersistByBitSet Error, dst or src is nil")
		return
	}
	defer func() {
		if r := recover(); r != nil {
			log.Println("recovered in ", r)
			log.Println("stack: ", string(debug.Stack()))
		}
		if err != nil {
			log.Println("PersistToPersistByBitSet Error", err.Error())
		}
	}()

	{{range $i, $typeInfo := .FieldTypeList}}
		{{ $fieldName := index $.FieldNameList $i }}
		//{{ $fieldName }}	{{ $typeInfo.Name }}
		if bitSet.Get(E{{$.DataName}}FieldIndex{{ $fieldName }}) {
			dst.{{ $fieldName }} = src.{{ $fieldName }}
		}
	{{ end }}

	return
}

{{/* BytesToPersistSync }}
// BytesToPersistSync 反序列化sync
func (m *PersistManager) BytesToPersistSync(data []byte) (persistSync *PersistSync) {
	var err error
	if data == nil {
		return nil
	}
	defer func() {
		if r := recover(); r != nil {
			log.Println("recovered in ", r)
			log.Println("stack: ", string(debug.Stack()))
		}
		if err != nil {
			log.Println("BytesToPersistSync Error", err.Error())
		}
	}()
	i := 0

	const bitSetSize = (int)((EPersistFiledIndexLength>>EPersistLog2WordSize)+1) * 8

	persistSync = &PersistSync{}
	lenPersistData := len(data) - bitSetSize - 1

	persistSync.Data = m.BytesToPersist(data[:lenPersistData])

	i += lenPersistData
	persistSync.Op = int8(data[i])
	i += 1
	for j := 0; j < bitSetSize/8; j++ {
		persistSync.BitSet.set[j] = binary.LittleEndian.Uint64(data[i:])
		i += 8
	}

	return
}
{{*/}}

// BytesToPersistSync 反序列化sync
func (m *{{.DataName}}Manager) BytesToPersistSync(data []byte) (persistSync *{{.DataName}}Sync) {
	var err error
	if data == nil {
		return nil
	}
	defer func() {
		if r := recover(); r != nil {
			log.Println("recovered in ", r)
			log.Println("stack: ", string(debug.Stack()))
		}
		if err != nil {
			log.Println("BytesToPersistSync Error", err.Error())
		}
	}()
	i := 0

	const bitSetSize = (int)((E{{.DataName}}FiledIndexLength>>E{{.DataName}}Log2WordSize)+1) * 8

	persistSync = &{{.DataName}}Sync{}
	lenPersistData := len(data) - bitSetSize - 1

	persistSync.Data = m.BytesToPersist(data[:lenPersistData])

	i += lenPersistData
	persistSync.Op = int8(data[i])
	i += 1
	for j := 0; j < bitSetSize/8; j++ {
		persistSync.BitSet.set[j] = binary.LittleEndian.Uint64(data[i:])
		i += 8
	}

	return
}



{{/* PersistSyncToBytes }}
// PersistSyncToBytes 序列化sync
func (m *PersistManager) PersistSyncToBytes(persistSync *PersistSync) (data []byte) {
	var err error
	if persistSync == nil {
		return nil
	}
	defer func() {
		if r := recover(); r != nil {
			log.Println("recovered in ", r)
			log.Println("stack: ", string(debug.Stack()))
		}
		if err != nil {
			log.Println("PersistSyncToBytes Error", err.Error())
		}
	}()
	size := 0

	const bitSetSize = (int)((EPersistFiledIndexLength>>EPersistLog2WordSize)+1) * 8

	pData := m.PersistToBytes(persistSync.Data, persistSync.BitSet)
	size += len(pData) + 1 + bitSetSize

	data = make([]byte, size)

	i := 0

	copy(data[i:], pData)
	i += len(pData)
	data[i] = uint8(persistSync.Op)
	i += 1
	for _, setItem := range persistSync.BitSet.set {
		binary.LittleEndian.PutUint64(data[i:], setItem)
		i += 8
	}

	return
}
{{*/}}

// PersistSyncToBytes 序列化sync
func (m *{{.DataName}}Manager) PersistSyncToBytes(persistSync *{{.DataName}}Sync) (data []byte) {
	var err error
	if persistSync == nil {
		return nil
	}
	defer func() {
		if r := recover(); r != nil {
			log.Println("recovered in ", r)
			log.Println("stack: ", string(debug.Stack()))
		}
		if err != nil {
			log.Println("PersistSyncToBytes Error", err.Error())
		}
	}()
	size := 0

	const bitSetSize = (int)((E{{.DataName}}FiledIndexLength>>E{{.DataName}}Log2WordSize)+1) * 8


	pData := m.PersistToBytes(persistSync.Data, persistSync.BitSet)
	size += len(pData) + 1 + bitSetSize

	data = make([]byte, size)

	i := 0

	copy(data[i:], pData)
	i += len(pData)
	data[i] = uint8(persistSync.Op)
	i += 1
	for _, setItem := range persistSync.BitSet.set {
		binary.LittleEndian.PutUint64(data[i:], setItem)
		i += 8
	}

	return
}

{{/* 反序列化2sync }}
// StringToPersistSyncInterface 反序列化2syncInterface
func (m *PersistManager) StringToPersistSyncInterface(data string) interface{} {
	return m.StringToPersistSync(data)
}

// StringToPersistSync 反序列化2sync
func (m *PersistManager) StringToPersistSync(data string) (persistSync *PersistSync) {
	if data == "" {
		return nil
	}
	buf, err := base64.StdEncoding.DecodeString(data)
	if err != nil {
		return nil
	}
	return m.BytesToPersistSync(buf)
}

// PersistSyncToString 序列化2sync
func (m *PersistManager) PersistSyncToString(persistSync *PersistSync) (data string) {
	buf := m.PersistSyncToBytes(persistSync)
	if buf == nil {
		return ""
	}
	data = base64.StdEncoding.EncodeToString(buf)
	return
}
{{*/}}

// StringToPersistSyncInterface 反序列化2syncInterface
func (m *{{.DataName}}Manager) StringToPersistSyncInterface(data string) interface{} {
	return m.StringToPersistSync(data)
}

// StringToPersistSync 反序列化2sync
func (m *{{.DataName}}Manager) StringToPersistSync(data string) (persistSync *{{.DataName}}Sync) {
	if data == "" {
		return nil
	}
	buf, err := base64.StdEncoding.DecodeString(data)
	if err != nil {
		return nil
	}
	return m.BytesToPersistSync(buf)
}

// PersistSyncToString 序列化2sync
func (m *{{.DataName}}Manager) PersistSyncToString(persistSync *{{.DataName}}Sync) (data string) {
	buf := m.PersistSyncToBytes(persistSync)
	if buf == nil {
		return ""
	}
	data = base64.StdEncoding.EncodeToString(buf)
	return
}


{{/* UnmarshalFailQueue }}
// UnmarshalFailQueue 失败队列反序列化
func (m *PersistManager) UnmarshalFailQueue(data []byte, failQueue *[]*PersistSync) (err error) {
	if data == nil || failQueue == nil {
		return nil
	}
	defer func() {
		if r := recover(); r != nil {
			log.Println("recovered in ", r)
			log.Println("stack: ", string(debug.Stack()))
		}
		if err != nil {
			log.Println("UnmarshalFailQueue Error", err.Error())
		}
	}()
	i := 0
	lenFailQueue := binary.LittleEndian.Uint32(data[i:])
	i += 4
	*failQueue = make([]*PersistSync, lenFailQueue)
	for idx := 0; idx < int(lenFailQueue); idx++ {
		lenPersistSyncData := int(binary.LittleEndian.Uint32(data[i:]))
		i += 4
		persistSync := m.BytesToPersistSync(data[i : i+lenPersistSyncData])
		i += lenPersistSyncData
		(*failQueue)[idx] = persistSync
	}
	return nil
}
{{*/}}

// UnmarshalFailQueue 失败队列反序列化
func (m *{{.DataName}}Manager) UnmarshalFailQueue(data []byte, failQueue *[]*{{.DataName}}Sync) (err error) {
	if data == nil || failQueue == nil {
		return nil
	}
	defer func() {
		if r := recover(); r != nil {
			log.Println("recovered in ", r)
			log.Println("stack: ", string(debug.Stack()))
		}
		if err != nil {
			log.Println("UnmarshalFailQueue Error", err.Error())
		}
	}()
	i := 0
	lenFailQueue := binary.LittleEndian.Uint32(data[i:])
	i += 4
	*failQueue = make([]*{{.DataName}}Sync, lenFailQueue)
	for idx := 0; idx < int(lenFailQueue); idx++ {
		lenPersistSyncData := int(binary.LittleEndian.Uint32(data[i:]))
		i += 4
		persistSync := m.BytesToPersistSync(data[i : i+lenPersistSyncData])
		i += lenPersistSyncData
		(*failQueue)[idx] = persistSync
	}
	return nil
}

{{/* MarshalFailQueue }}
// MarshalFailQueue 失败队列序列化
func (m *PersistManager) MarshalFailQueue(failQueue []*PersistSync) (data []byte, err error) {
	var idx int
	var size int
	var persistSync *PersistSync
	defer func() {
		if r := recover(); r != nil {
			log.Println("recovered in ", r)
			log.Println("stack: ", string(debug.Stack()))
		}
		if err != nil {
			log.Println("MarshalFailQueue Error", err.Error())
		}
	}()
	persistSyncDataList := make([][]byte, len(failQueue))
	size += 4
	for idx = range failQueue {
		persistSync = failQueue[idx]
		pData := m.PersistSyncToBytes(persistSync)
		persistSyncDataList[idx] = pData
		size += 4 + len(pData)
	}

	data = make([]byte, size)
	i := 0
	binary.LittleEndian.PutUint32(data[i:], uint32(len(failQueue)))
	i += 4
	for idx = range failQueue {
		binary.LittleEndian.PutUint32(data[i:], uint32(len(persistSyncDataList[idx])))
		i += 4
		copy(data[i:], persistSyncDataList[idx])
		i += len(persistSyncDataList[idx])
	}
	return
}
{{*/}}

// MarshalFailQueue 失败队列序列化
func (m *{{.DataName}}Manager) MarshalFailQueue(failQueue []*{{.DataName}}Sync) (data []byte, err error) {
	var idx int
	var size int
	var persistSync *{{.DataName}}Sync
	defer func() {
		if r := recover(); r != nil {
			log.Println("recovered in ", r)
			log.Println("stack: ", string(debug.Stack()))
		}
		if err != nil {
			log.Println("MarshalFailQueue Error", err.Error())
		}
	}()
	persistSyncDataList := make([][]byte, len(failQueue))
	size += 4
	for idx = range failQueue {
		persistSync = failQueue[idx]
		pData := m.PersistSyncToBytes(persistSync)
		persistSyncDataList[idx] = pData
		size += 4 + len(pData)
	}

	data = make([]byte, size)
	i := 0
	binary.LittleEndian.PutUint32(data[i:], uint32(len(failQueue)))
	i += 4
	for idx = range failQueue {
		binary.LittleEndian.PutUint32(data[i:], uint32(len(persistSyncDataList[idx])))
		i += 4
		copy(data[i:], persistSyncDataList[idx])
		i += len(persistSyncDataList[idx])
	}
	return
}




{{/* acquireDeepCopyObject }}
{{if $.ArgsInfo.Save}}    

	// acquireDeepCopyObject 拷贝一个新对象用于写回
	func (m *PersistManager) acquireDeepCopyObject(cls *Persist) (ret *Persist) {
		//生成如下赋值代码
		//ret = m.pool.Get().(*Persist)
		//ret.Uid = cls.Uid
		//ret.Id = cls.Id
		//ret.State = cls.State
		//ret.Value = cls.Value
		//ret.String = cls.String
		////ret.ValueMap = cls.ValueMap
		//ret.ValueMap = make(map[int32]bool)
		//for k, v := range cls.ValueMap {
		//	ret.ValueMap[k] = v
		//}
		//ret.ValueArray = cls.ValueArray
		//ret.ValueSliceList = make([][2]int32, len(cls.ValueSliceList))
		//for i := range cls.ValueSliceList {
		//	ret.ValueSliceList[i] = cls.ValueSliceList[i]
		//}
		//ret = m.BytesToPersist(m.PersistToBytes(cls, m.bitSetAll))
		return
}
{{end}}
{{*/}}
{{if $.ArgsInfo.Save}}    

	// acquireDeepCopyObject 拷贝一个新对象用于写回
	func (m *{{.DataName}}Manager) acquireDeepCopyObject(cls *{{.ArgsInfo.PersistPkgName}}.{{.DataName}}) (ret *{{.ArgsInfo.PersistPkgName}}.{{.DataName}}) {
		if v, ok := ((interface{})(cls)).({{.DataName}}DeepCopy); ok {
			//ret = m.pool.Get().(*{{.ArgsInfo.PersistPkgName}}.{{.DataName}})
			ret = &{{.ArgsInfo.PersistPkgName}}.{{.DataName}}{}
			v.CopyTo(ret)
		} else {
			ret = m.BytesToPersist(m.PersistToBytes(cls, m.bitSetAll))
		}
		return
	}
{{end}}




{{/* releaseDeepCopyObject }}
{{if $.ArgsInfo.Save}}    
	// releaseDeepCopyObject 释放对象
	func (m *PersistManager) releaseDeepCopyObject(cls *Persist) {
		m.pool.Put(cls)
	}
{{end}}
{{*/}}
{{if $.ArgsInfo.Save}}
	// releaseDeepCopyObject 释放对象
	func (m *{{.DataName}}Manager) releaseDeepCopyObject(cls *{{.ArgsInfo.PersistPkgName}}.{{.DataName}}) {
		//if _, ok := ((interface{})(cls)).(*{{.DataName}}DeepCopy); ok {
		//	m.pool.Put(cls)
		//}
		return
	}
{{end}}


{{/* CheckOverload }}
	{{if $.ArgsInfo.Save}}    
		// CheckOverload 检查负载
		func (m *PersistManager) CheckOverload() {
			// queueLength 不是精确值,  cacheQueue, FailQueue 一写多读
			queueLength := len(*m.cacheQueue) + len(m.FailQueue)
			if queueLength > 10000 {
				if v, ok := ((interface{})(gPersistNil)).(PersistOverload); ok {
					go util.RecoverWrapFunc(func() { v.Overload(queueLength, m.lastWriteBackTime) })
				} else {
				}
			} else {
			}
		}
	{{end}}
{{*/}}
{{if $.ArgsInfo.Save}}    
	// CheckOverload 检查负载
	func (m *{{.DataName}}Manager) CheckOverload() {
		// queueLength 不是精确值,  cacheQueue, FailQueue 一写多读
		queueLength := len(*m.cacheQueue) + len(m.FailQueue)
		if queueLength > {{$.ArgsInfo.QueueThreshold}} {
			if v, ok := ((interface{})(g{{.DataName}}Nil)).({{.DataName}}Overload); ok {
				go util.RecoverWrapFunc(func() { v.Overload(queueLength, m.lastWriteBackTime) })
			} else {
			}
		} else {
		}
	}
{{end}}






{{/* add }}
// 主键必须放在HashIndexList第一个
// addPersist 添加一个对象
func (m *PersistManager) addPersist(cls *Persist) (*Persist, bool) {
{{if .ArgsInfo.OptimizeFlagUsePoolAndDisableDeleteUnload}}
	actual, loaded := m.hashUid.LoadOrStore(cls.Uid, -1)
	if !loaded {
		idx := m.objectPool.Put(cls)
		m.hashUid.Store(cls.Uid, idx)

		if v, ok := m.hashAccountName.LoadOrStore(cls.AccountName, -1); !ok {
			idxMap := m.objectMapPool.New(idx)
			m.hashAccountName.Store(cls.AccountName, idxMap)
		} else {
			m.objectMapPool.Put(v, idx)
		}
		actual = idx
	}
	return m.objectPool.Get(actual), !loaded
{{else}}
	actual, loaded := m.hashUidId.LoadOrStore(PersistKeyTypeHashUidId{cls.Uid, cls.Id,}, cls)
	// 不在主键中
	if !loaded {
		if _, ok := m.hashUid.Load(cls.Uid); !ok {
			m.hashUid.Store(cls.Uid, &PersistSet{})
		}
		if v, ok := m.hashUid.Load(cls.Uid); ok {
			v.Store(cls, true)
		}
		actual = cls
	}
	return actual, !loaded
{{end}}
}
{{*/}}
{{if .HashIndexPk}}
	{{if .ArgsInfo.OptimizeFlagUsePoolAndDisableDeleteUnload}}
		// add{{.DataName}}添加一个对象
		func (m *{{.DataName}}Manager) add{{.DataName}}(cls *{{.ArgsInfo.PersistPkgName}}.{{.DataName}}) (*{{.ArgsInfo.PersistPkgName}}.{{.DataName}}, bool) {
		{{range $i, $indexItem := .HashIndexList}}
			` + indexAddItem + `
		{{end}}
				{{if $.HaveRBTree}}
				m.SetData(cls)
				{{end}}
			}
			return m.objectPool.Get(actual), !loaded
		}
	{{else}}
		// add{{.DataName}}添加一个对象
		func (m *{{.DataName}}Manager) add{{.DataName}}(cls *{{.ArgsInfo.PersistPkgName}}.{{.DataName}}) (*{{.ArgsInfo.PersistPkgName}}.{{.DataName}}, bool) {
		{{range $i, $indexItem := .HashIndexList}}
			` + indexAddItem + `
		{{end}}
				{{if $.HaveRBTree}}
				m.SetData(cls)
				{{end}}
			}
			return actual, !loaded
		}
	{{end}}
{{else}}

{{end}}


{{/* remove }}
{{if .ArgsInfo.OptimizeFlagUsePoolAndDisableDeleteUnload}}
// EOptimizeFlagUsePoolAndDisableDeleteUnload 优化下不支持删除
// removePersist 删除一个对象
//func (m *PersistManager) removePersist(cls *Persist) {
//	m.hashUidId.Delete(PersistKeyTypeHashUidId{cls.Uid, cls.Id})
//	if v, ok := m.hashUid.Load(cls.Uid); ok {
//		v.Delete(cls)
//	}
//	if v, ok := m.hashUid.Load(cls.Uid); ok {
//		has := false
//		v.Range(func(key *Persist, value bool) bool {
//			has = true
//			return false
//		})
//		if !has {
//			m.hashUid.Delete(cls.Uid)
//		}
//	}
//	// m.hashUidIdMark.Delete(PersistKeyTypeHashUidId{cls.Uid, cls.Id})
//	return
//}
{{else}}
// removePersist 删除一个对象
func (m *PersistManager) removePersist(cls *Persist) {
	m.hashUidId.Delete(PersistKeyTypeHashUidId{cls.Uid, cls.Id})
	if v, ok := m.hashUid.Load(cls.Uid); ok {
		v.Delete(cls)
	}
	if v, ok := m.hashUid.Load(cls.Uid); ok {
		has := false
		v.Range(func(key *Persist, value bool) bool {
			has = true
			return false
		})
		if !has {
			m.hashUid.Delete(cls.Uid)
		}
	}
	// m.hashUidIdMark.Delete(PersistKeyTypeHashUidId{cls.Uid, cls.Id})
	return
}
{{end}}
{{*/}}
{{if .ArgsInfo.OptimizeFlagUsePoolAndDisableDeleteUnload}}
	{{if .HashIndexPk}}    
		// EOptimizeFlagUsePoolAndDisableDeleteUnload 优化下不支持删除
		// remove{{.DataName}} 删除一个对象
		//func (m *{{.DataName}}Manager) remove{{.DataName}}(cls *{{.ArgsInfo.PersistPkgName}}.{{.DataName}}) {
			//	// m.hash{{.HashIndexPk.Keys}}Mark.Delete({{$.DataName}}KeyTypeHash{{.HashIndexPk.Keys}}{ {{.HashIndexPk.ClsPointKeys}} })
		{{range $i, $indexItem := .ReverseHashIndexList}}
			` + indexRemoveItem + `
			{{if $.HaveRBTree}}
			m.RemoveData(cls)
			{{end}}
		{{end}}
		//	return
		//}
	{{else}}

	{{end}}
{{else}}
	{{if .HashIndexPk}}    
		// remove{{.DataName}} 删除一个对象
		func (m *{{.DataName}}Manager) remove{{.DataName}}(cls *{{.ArgsInfo.PersistPkgName}}.{{.DataName}}) {
			// m.hash{{.HashIndexPk.Keys}}Mark.Delete({{$.DataName}}KeyTypeHash{{.HashIndexPk.Keys}}{ {{.HashIndexPk.ClsPointKeys}} })
		{{range $i, $indexItem := .ReverseHashIndexList}}
			` + indexRemoveItem + `
		{{end}}
			
			{{if $.HaveRBTree}}
			m.RemoveData(cls)
			{{end}}
			return
		}
	{{else}}

	{{end}}

{{end}}



{{/* new }}
// InitDS ds并发map初始化
func (m *PersistManager) InitDS(cls *Persist) {
	// todo
	// cls.MyMap = ds.RWMapInt32Int32{}
}
{{*/}}

// InitDS ds并发map初始化
func (m *{{.DataName}}Manager) InitDS(cls *{{.ArgsInfo.PersistPkgName}}.{{.DataName}}) {
	// todo
	// cls.MyMap = ds.RWMapInt32Int32{}
	{{range $i, $typeInfo := .FieldTypeList}}
		{{ $fieldName := index $.FieldNameList $i }}
		//{{ $fieldName }}	{{ $typeInfo.Name }}

		{{ if $typeInfo.IsNotNull }}
			if cls.{{ $fieldName }} == nil {
				{{ if $typeInfo.NeedInit }}
					cls.{{ $fieldName }} = (&{{ $.DropStar $typeInfo.Name }}{}).Init()
				{{else}}
					cls.{{ $fieldName }} = &{{ $.DropStar $typeInfo.Name }}{}
				{{ end }}
			}
		{{ end }}
	{{ end }}
}


{{/* new }}
// NewPersist 添加对象并异步写回数据库, (1 数据没有导入或已经导出, 2 数据已存在, 3 对象为空) 会返回失败
func (m *PersistManager) NewPersist(cls *Persist) (*Persist, error) {
	if cls == nil {
		return nil, persistCore.EPersistErrorNil
	}
	{{if $.ArgsInfo.Save}}
		{{if .HashIndexUnload}}
			if m.LoadState(cls.Uid) != EPersistLoadStateMemory {
				return nil, persistCore.EPersistErrorNotInMemory
			}
		{{ else if $.IsGlobalPersist }}
			if m.LoadAllState() != EBillShareLoadStateMemory {
				return nil, persistCore.EPersistErrorNotInMemory
			}
		{{else}}
		{{end}}
	{{end}}

	{{if .ArgsInfo.OptimizeFlagIndexMutex}}
		{{range $i, $indexItem := .HashIndexList}}
			m.hash{{$indexItem.Keys}}Mutex.Lock()
			defer m.hash{{$indexItem.Keys}}Mutex.Unlock()
		{{end}}
	{{end}}
	actual, success := m.addPersist(cls)
{{if $.ArgsInfo.Save}}
	if success {
		m.InitDS(cls)
		bitSet := PersistBitSet{}
		bitSet.SetAll()
		newCls := m.acquireDeepCopyObject(cls)

		persistSync := &PersistSync{Data: newCls, Op: EPersistOpInsert, BitSet: bitSet}
		{{if .ArgsInfo.OptimizeFlagTraceSwitch}}
			log.Println("[sql trace Persist]", m.PersistSyncToString(persistSync))
		{{end}}
		m.syncChan <- persistSync

	} else {
		return actual, persistCore.EPersistErrorAlreadyExist
	}
{{else}}
	if success {
	} else {
		return actual, persistCore.EPersistErrorAlreadyExist
	}
{{end}}
	return actual, nil
}
{{*/}}
// New{{.DataName}} 添加对象并异步写回数据库, (1 数据没有导入或已经导出, 2 数据已存在, 3 对象为空) 会返回失败
func (m *{{.DataName}}Manager) New{{.DataName}}(cls *{{.ArgsInfo.PersistPkgName}}.{{.DataName}}) (*{{.ArgsInfo.PersistPkgName}}.{{.DataName}}, error) {

	if cls == nil {
		return nil, persistCore.EPersistErrorNil
	}
	{{if $.ArgsInfo.Save}}
		{{if .HashIndexUnload}}
			if m.LoadState(cls.{{index .HashIndexUnload.Cols 0}}) != E{{.DataName}}LoadStateMemory {
				return nil, persistCore.EPersistErrorNotInMemory
			}
		{{ else if $.IsGlobalPersist }}
			if m.LoadAllState() != E{{.DataName}}LoadStateMemory {
				return nil, persistCore.EPersistErrorNotInMemory
			}
		{{else}}
		{{end}}
	{{end}}

	{{if .HashIndexPk}}
		{{if .ArgsInfo.OptimizeFlagIndexMutex}}
			{{range $i, $indexItem := .HashIndexList}}
				m.hash{{$indexItem.Keys}}Mutex.Lock()
				defer m.hash{{$indexItem.Keys}}Mutex.Unlock()
			{{end}}
		{{end}}

		actual, success := m.add{{.DataName}}(cls)
	{{else}}
		actual, success := cls, true
	{{end}}
{{if $.ArgsInfo.Save}}
	if success {
		m.InitDS(cls)
		bitSet := {{.DataName}}BitSet{}
		bitSet.SetAll()
		newCls := m.acquireDeepCopyObject(cls)

		persistSync := &{{.DataName}}Sync{Data: newCls, Op: E{{.DataName}}OpInsert, BitSet: bitSet}
		{{if .ArgsInfo.OptimizeFlagTraceSwitch}}
			log.Println("[sql trace {{.DataName}}]", m.PersistSyncToString(persistSync))
		{{end}}
		m.syncChan <- persistSync

	} else {
		return actual, persistCore.EPersistErrorAlreadyExist
	}
{{else}}
	if success {
	} else {
		return actual, persistCore.EPersistErrorAlreadyExist
	}
{{end}}
	return actual, nil
}


{{/* delete }}
{{if .ArgsInfo.OptimizeFlagUsePoolAndDisableDeleteUnload}}
	// EOptimizeFlagUsePoolAndDisableDeleteUnload 优化下不支持删除
	// DeletePersist 删除对象并异步写回数据库 (1 数据没有导入或已经导出, 2 数据已经重新导入, 3 对象为空) 会返回失败
	//func (m *PersistManager) DeletePersist(cls *Persist) error {
	//	{{if $.ArgsInfo.Save}}
	//		if cls == nil {
	//			return persistCore.EPersistErrorNil
	//		}
	//		if m.LoadState(cls.Uid) != EPersistLoadStateMemory {
	//			return persistCore.EPersistErrorNotInMemory
	//		}
	//  	{{ else if $.IsGlobalPersist }}
	//		if m.LoadAllState() != E{{.DataName}}LoadStateMemory {
	//			return persistCore.EPersistErrorNotInMemory
	//		}
	//	{{end}}

	//	p := m.GetPersistByUidId(cls.Uid, cls.Id)
	//	if p == nil || p != cls {
	//		return persistCore.EPersistErrorOutOfDate
	//	}

	//	{{if .ArgsInfo.OptimizeFlagIndexMutex}}
	//		{{range $i, $indexItem := .HashIndexList}}
	//			m.hash{{$indexItem.Keys}}Mutex.Lock()
	//			defer m.hash{{$indexItem.Keys}}Mutex.Unlock()
	//		{{end}}
	//	{{end}}
	//	m.removePersist(cls)
	//{{if $.ArgsInfo.Save}}
	//	// 主键不能修改
	//	newCls := m.acquireDeepCopyObject(cls)
	//	m.syncChan <- &PersistSync{Data: newCls, Op: EPersistOpDelete}

	//	persistSync := &PersistSync{Data: newCls, Op: EPersistOpDelete}
	//	{{if .ArgsInfo.OptimizeFlagTraceSwitch}}
	//		log.Println("[sql trace Persist]", m.PersistSyncToString(persistSync))
	//	{{end}}
	//	m.syncChan <- persistSync

	//{{end}}
	//	return nil
	//}
{{else}}
	// DeletePersist 删除对象并异步写回数据库 (1 数据没有导入或已经导出, 2 数据已经重新导入, 3 对象为空) 会返回失败
	func (m *PersistManager) DeletePersist(cls *Persist) error {
		if cls == nil {
			return persistCore.EPersistErrorNil
		}
		{{if $.ArgsInfo.Save}}
			{{if .HashIndexUnload}}
				if m.LoadState(cls.Uid) != EPersistLoadStateMemory {
					return persistCore.EPersistErrorNotInMemory
				}
			{{ else if $.IsGlobalPersist }}
				if m.LoadAllState() != E{{.DataName}}LoadStateMemory {
					return persistCore.EPersistErrorNotInMemory
				}
			{{else}}
			{{end}}
		{{end}}

		p := m.GetPersistByUidId(cls.Uid, cls.Id)
		if p == nil || p != cls {
			return persistCore.EPersistErrorOutOfDate
		}

		{{if .ArgsInfo.OptimizeFlagIndexMutex}}
			{{range $i, $indexItem := .HashIndexList}}
				m.hash{{$indexItem.Keys}}Mutex.Lock()
				defer m.hash{{$indexItem.Keys}}Mutex.Unlock()
			{{end}}
		{{end}}
		m.removePersist(cls)
	{{if $.ArgsInfo.Save}}
		// 主键不能修改
		newCls := m.acquireDeepCopyObject(cls)
		m.syncChan <- &PersistSync{Data: newCls, Op: EPersistOpDelete}

		persistSync := &PersistSync{Data: newCls, Op: EPersistOpDelete}
		{{if .ArgsInfo.OptimizeFlagTraceSwitch}}
			log.Println("[sql trace Persist]", m.PersistSyncToString(persistSync))
		{{end}}
		m.syncChan <- persistSync

	{{end}}
		return nil
	}
{{end}}

{{*/}}
{{if .ArgsInfo.OptimizeFlagUsePoolAndDisableDeleteUnload}}
	{{if .HashIndexPk}}
		// EOptimizeFlagUsePoolAndDisableDeleteUnload 优化下不支持删除
		// Delete{{.DataName}} 删除对象并异步写回数据库 (1 数据没有导入或已经导出, 2 数据已经重新导入, 3 对象为空) 会返回失败
		//func (m *{{.DataName}}Manager) Delete{{.DataName}}(cls *{{.ArgsInfo.PersistPkgName}}.{{.DataName}}) error {
		//	if cls == nil {
		//		return persistCore.EPersistErrorNil
		//	}
		//
			{{if $.ArgsInfo.Save}}
				{{if .HashIndexUnload}}
		//			if m.LoadState(cls.{{index .HashIndexUnload.Cols 0}}) != E{{.DataName}}LoadStateMemory {
		//				return persistCore.EPersistErrorNotInMemory
		//			}
				{{ else if $.IsGlobalPersist }}
		//			if m.LoadAllState() != E{{.DataName}}LoadStateMemory {
		//				return persistCore.EPersistErrorNotInMemory
		//			}
		  		{{else}}
				{{end}}
			{{end}}

			{{if .HashIndexPk}}
			//	p := m.Get{{.DataName}}By{{.HashIndexPk.Keys}}({{.HashIndexPk.ClsPointKeys}})
			//	if p == nil || p != cls {
			//		return persistCore.EPersistErrorOutOfDate
			//	}
			{{end}}
		//
			{{if .ArgsInfo.OptimizeFlagIndexMutex}}
		//		{{range $i, $indexItem := .HashIndexList}}
		//			m.hash{{$indexItem.Keys}}Mutex.Lock()
		//			defer m.hash{{$indexItem.Keys}}Mutex.Unlock()
		//		{{end}}
			{{end}}

		//	m.remove{{.DataName}}(cls)
		{{if $.ArgsInfo.Save}}
		//	// 主键不能修改
		//	newCls := m.acquireDeepCopyObject(cls)
		//
		//	persistSync := &{{.DataName}}Sync{Data: newCls, Op: E{{.DataName}}OpDelete}
		//	{{if .ArgsInfo.OptimizeFlagTraceSwitch}}
			//	log.Println("[sql trace {{.DataName}}]", m.PersistSyncToString(persistSync))
			{{end}}
		//	m.syncChan <- persistSync
		//
		{{end}}
		//	return nil
		//}
	{{else}}

	{{end}}

{{else}}
	{{if .HashIndexPk}}
		// Delete{{.DataName}} 删除对象并异步写回数据库 (1 数据没有导入或已经导出, 2 数据已经重新导入, 3 对象为空) 会返回失败
		func (m *{{.DataName}}Manager) Delete{{.DataName}}(cls *{{.ArgsInfo.PersistPkgName}}.{{.DataName}}) error {
			if cls == nil {
				return persistCore.EPersistErrorNil
			}

			{{if $.ArgsInfo.Save}}
				{{if .HashIndexUnload}}
					if m.LoadState(cls.{{index .HashIndexUnload.Cols 0}}) != E{{.DataName}}LoadStateMemory {
						return persistCore.EPersistErrorNotInMemory
					}
				{{ else if $.IsGlobalPersist }}
					if m.LoadAllState() != E{{.DataName}}LoadStateMemory {
						return persistCore.EPersistErrorNotInMemory
					}
				{{else}}
				{{end}}
			{{end}}

			{{if .HashIndexPk}}
				p := m.Get{{.DataName}}By{{.HashIndexPk.Keys}}({{.HashIndexPk.ClsPointKeys}})
				if p == nil || p != cls {
					return persistCore.EPersistErrorOutOfDate
				}
			{{end}}

			{{if .ArgsInfo.OptimizeFlagIndexMutex}}
				{{range $i, $indexItem := .HashIndexList}}
					m.hash{{$indexItem.Keys}}Mutex.Lock()
					defer m.hash{{$indexItem.Keys}}Mutex.Unlock()
				{{end}}
			{{end}}

			m.remove{{.DataName}}(cls)
		{{if $.ArgsInfo.Save}}
			// 主键不能修改
			bitSet := {{.DataName}}BitSet{}
			bitSet.SetAll()
			newCls := m.acquireDeepCopyObject(cls)

			persistSync := &{{.DataName}}Sync{Data: newCls, Op: E{{.DataName}}OpDelete, BitSet: bitSet}
			{{if .ArgsInfo.OptimizeFlagTraceSwitch}}
				log.Println("[sql trace {{.DataName}}]", m.PersistSyncToString(persistSync))
			{{end}}
			m.syncChan <- persistSync

		{{end}}
			return nil
		}
	{{else}}

	{{end}}
{{end}}


{{/* delete all }}
{{if .ArgsInfo.OptimizeFlagUsePoolAndDisableDeleteUnload}}
	// EOptimizeFlagUsePoolAndDisableDeleteUnload 优化下不支持删除
	// DeleteAll 删除所有对象并异步写回数据库
	//func (m *PersistManager) DeleteAll() {
	//	{{if .ArgsInfo.OptimizeFlagIndexMutex}}
	//		{{range $i, $indexItem := .HashIndexList}}
	//			m.hash{{$indexItem.Keys}}Mutex.Lock()
	//			defer m.hash{{$indexItem.Keys}}Mutex.Unlock()
	//		{{end}}
	//	{{end}}
	//	var tmpPersistList []*Persist
	//	m.hashUidId.Range(func(k PersistKeyTypeHashUidId, v *Persist) bool {
	//		tmpPersistList = append(tmpPersistList, k)
	//		return true
	//	})
	//	for _, cls := range tmpPersistList {
	//		if cls == nil {
	//			continue
	//		}
	//		m.removePersist(cls)
	//		{{if $.ArgsInfo.Save}}
	//			// 主键不能修改
	//			newCls := m.acquireDeepCopyObject(cls)

	//			persistSync := &PersistSync{Data: newCls, Op: EPersistOpDelete}
	//			{{if .ArgsInfo.OptimizeFlagTraceSwitch}}
	//				log.Println("[sql trace Persist]", m.PersistSyncToString(persistSync))
	//			{{end}}
	//			m.syncChan <- persistSync

	//		{{end}}
	//	}
	//}
{{else}}
	// DeleteAll 删除所有对象并异步写回数据库
	func (m *PersistManager) DeleteAll() {
		{{if .ArgsInfo.OptimizeFlagIndexMutex}}
			{{range $i, $indexItem := .HashIndexList}}
				m.hash{{$indexItem.Keys}}Mutex.Lock()
				defer m.hash{{$indexItem.Keys}}Mutex.Unlock()
			{{end}}
		{{end}}
		var tmpPersistList []*Persist
		m.hashUidId.Range(func(k PersistKeyTypeHashUidId, v *Persist) bool {
			tmpPersistList = append(tmpPersistList, k)
			return true
		})
		for _, cls := range tmpPersistList {
			if cls == nil {
				continue
			}
			m.removePersist(cls)
			{{if $.ArgsInfo.Save}}
				// 主键不能修改
				newCls := m.acquireDeepCopyObject(cls)

				persistSync := &PersistSync{Data: newCls, Op: EPersistOpDelete}
				{{if .ArgsInfo.OptimizeFlagTraceSwitch}}
					log.Println("[sql trace Persist]", m.PersistSyncToString(persistSync))
				{{end}}
				m.syncChan <- persistSync

			{{end}}
		}
	}
{{end}}
{{*/}}
{{if .ArgsInfo.OptimizeFlagUsePoolAndDisableDeleteUnload}}
	{{if .HashIndexPk}}    
		// EOptimizeFlagUsePoolAndDisableDeleteUnload 优化下不支持删除
		// DeleteAll 删除所有对象并异步写回数据库
		//func (m *{{.DataName}}Manager) DeleteAll() {
		//	{{if .ArgsInfo.OptimizeFlagIndexMutex}}
		//		{{range $i, $indexItem := .HashIndexList}}
		//			m.hash{{$indexItem.Keys}}Mutex.Lock()
		//			defer m.hash{{$indexItem.Keys}}Mutex.Unlock()
		//		{{end}}
		//	{{end}}
		//	var tmp{{.DataName}}List []*{{.ArgsInfo.PersistPkgName}}.{{.DataName}}
		//	m.hash{{.HashIndexPk.Keys}}.Range(func(k {{.DataName}}KeyTypeHash{{.HashIndexPk.Keys}}, v *{{.ArgsInfo.PersistPkgName}}.{{.DataName}}) bool {
		//		tmp{{.DataName}}List = append(tmp{{.DataName}}List, v)
		//		return true
		//	})
		//	for _, cls := range tmp{{.DataName}}List {
		//		if cls == nil {
		//			continue
		//		}
		//		m.remove{{.DataName}}(cls)
		//		{{if $.ArgsInfo.Save}}
			//		// 主键不能修改
			//		newCls := m.acquireDeepCopyObject(cls)
			//
			//		persistSync := &{{.DataName}}Sync{Data: newCls, Op: E{{.DataName}}OpDelete}
			//		{{if .ArgsInfo.OptimizeFlagTraceSwitch}}
				//		log.Println("[sql trace {{.DataName}}]", m.PersistSyncToString(persistSync))
			//		{{end}}
			//		m.syncChan <- persistSync

		//		{{end}}
		//	}
		//}
	{{else}}

	{{end}}
{{else}}
	{{if .HashIndexPk}}    
		// DeleteAll 删除所有对象并异步写回数据库
		func (m *{{.DataName}}Manager) DeleteAll() {
			{{if .ArgsInfo.OptimizeFlagIndexMutex}}
				{{range $i, $indexItem := .HashIndexList}}
					m.hash{{$indexItem.Keys}}Mutex.Lock()
					defer m.hash{{$indexItem.Keys}}Mutex.Unlock()
				{{end}}
			{{end}}
			var tmp{{.DataName}}List []*{{.ArgsInfo.PersistPkgName}}.{{.DataName}}
			m.hash{{.HashIndexPk.Keys}}.Range(func(k {{.DataName}}KeyTypeHash{{.HashIndexPk.Keys}}, v *{{.ArgsInfo.PersistPkgName}}.{{.DataName}}) bool {
				tmp{{.DataName}}List = append(tmp{{.DataName}}List, v)
				return true
			})
			for _, cls := range tmp{{.DataName}}List {
				if cls == nil {
					continue
				}
				m.remove{{.DataName}}(cls)
				{{if $.ArgsInfo.Save}}
					// 主键不能修改
					bitSet := {{.DataName}}BitSet{}
					bitSet.SetAll()
					newCls := m.acquireDeepCopyObject(cls)

					persistSync := &{{.DataName}}Sync{Data: newCls, Op: E{{.DataName}}OpDelete, BitSet: bitSet}
					{{if .ArgsInfo.OptimizeFlagTraceSwitch}}
						log.Println("[sql trace {{.DataName}}]", m.PersistSyncToString(persistSync))
					{{end}}
					m.syncChan <- persistSync

				{{end}}
			}
		}
	{{else}}

	{{end}}
{{end}}



{{/* Clean }}
{{if .ArgsInfo.OptimizeFlagUsePoolAndDisableDeleteUnload}}
	// EOptimizeFlagUsePoolAndDisableDeleteUnload 优化下支持清空数据
	// Clean (非线程安全) 清空所有对象并异步写回数据库, 仅支持测试代码使用
	func (m *AccountGlobalManager) Clean() {

		var tmpAccountGlobalList []*AccountGlobal
		tmpAccountGlobalList = m.objectPool.GetAll()
		for _, cls := range tmpAccountGlobalList {
			if cls == nil {
				continue
			}

			m.hashAccountName.Delete(cls.AccountName)
			m.hashUid.Delete(cls.Uid)

			// 主键不能修改
			newCls := m.acquireDeepCopyObject(cls)

			persistSync := &AccountGlobalSync{Data: newCls, Op: EAccountGlobalOpDelete}

			log.Println("[sql trace AccountGlobal]", m.PersistSyncToString(persistSync))

			m.syncChan <- persistSync

		}
		m.objectPool.Clean()
		m.objectMapPool.Clean()
	}
{{end}}
{{*/}}
{{if .ArgsInfo.OptimizeFlagUsePoolAndDisableDeleteUnload}}
	// EOptimizeFlagUsePoolAndDisableDeleteUnload 优化下支持清空数据
	// Clean (非线程安全) 清空所有对象并异步写回数据库, 仅支持测试代码使用
	func (m *{{.DataName}}Manager) Clean() {

		{{if .ArgsInfo.OptimizeFlagIndexMutex}}
			{{range $i, $indexItem := .HashIndexList}}
				m.hash{{$indexItem.Keys}}Mutex.Lock()
				defer m.hash{{$indexItem.Keys}}Mutex.Unlock()
			{{end}}
		{{end}}


		var tmp{{.DataName}}List []*{{.ArgsInfo.PersistPkgName}}.{{.DataName}}
		tmp{{.DataName}}List = m.objectPool.GetAll()
		for _, cls := range tmp{{.DataName}}List {
			if cls == nil {
				continue
			}

			// m.hash{{.HashIndexPk.Keys}}Mark.Delete({{$.DataName}}KeyTypeHash{{.HashIndexPk.Keys}}{ {{.HashIndexPk.ClsPointKeys}} })

			{{range $i, $indexItem := .ReverseHashIndexList}}
				m.hash{{$indexItem.Keys}}.Delete({{$.DataName}}KeyTypeHash{{$indexItem.Keys}}{ {{$indexItem.ClsPointKeys}} })
			{{end}}

			{{if $.ArgsInfo.Save}}
				// 主键不能修改
				newCls := m.acquireDeepCopyObject(cls)

				persistSync := &{{.DataName}}Sync{Data: newCls, Op: E{{.DataName}}OpDelete}
				{{if .ArgsInfo.OptimizeFlagTraceSwitch}}
					log.Println("[sql trace {{.DataName}}]", m.PersistSyncToString(persistSync))
				{{end}}
				m.syncChan <- persistSync

			{{end}}
		}
		m.objectPool.Clean()
		m.objectMapPool.Clean()
	}

{{end}}








{{/* SetIndexXXX 非主键的索引列修改,必须用set方法}}
只删除相关连的索引, 修改索引时, 上锁
{{if .ArgsInfo.OptimizeFlagUsePoolAndDisableDeleteUnload}}
	// 修改包含索引字段, 标记脏对象并异步写回数据库, 需要保证一致性, 生成时开启 EOptimizeFlagIndexMutex
	// SetIndexKeyState (1 数据没有导入或已经导出, 2 数据已经重新导入, 3 对象为空) 会返回失败
	//func (m *PersistManager) SetIndexKeyState(cls *Persist, State int32) error {
	//	{{if .ArgsInfo.OptimizeFlagIndexMutex}}
	//		m.hashStateMutex.Lock()
	//		defer m.hashStateMutex.Unlock()
	//	{{end}}
	//	if cls == nil {
	//		return persistCore.EPersistErrorNil
	//	}
	//	if v, ok := m.hashState.Load(cls.State); ok {
	//		v.Delete(cls)
	//	}
	//	cls.State = State
	//	if v, ok := m.hashState.LoadOrStore(cls.State, &PersistSet{}); !ok {
	//		v.Store(cls, true)
	//	} else {
	//		v.Store(cls, true)
	//	}
	//	// return m.MarkUpdate(cls)
	//	bitSet := PersistBitSet{}
	//	bitSet.Set(EPersistFieldIndexState)
	//	return m.MarkUpdateByBitSet(cls, bitSet)
	//}
{{else}}
	// 修改包含索引字段, 标记脏对象并异步写回数据库, 需要保证一致性, 生成时开启 EOptimizeFlagIndexMutex
	// SetIndexKeyState (1 数据没有导入或已经导出, 2 数据已经重新导入, 3 对象为空) 会返回失败
	func (m *PersistManager) SetIndexKeyState(cls *Persist, State int32) error {
		{{if .ArgsInfo.OptimizeFlagIndexMutex}}
			m.hashStateMutex.Lock()
			defer m.hashStateMutex.Unlock()
		{{end}}
		if cls == nil {
			return persistCore.EPersistErrorNil
		}
		{{if $.ArgsInfo.Save}}
			{{if .HashIndexUnload}}
				if m.LoadState(cls.Uid) != EPersistLoadStateMemory {
					return persistCore.EPersistErrorNotInMemory
				}
			{{ else if $.IsGlobalPersist }}
				if m.LoadAllState() != E{{.DataName}}LoadStateMemory {
					return persistCore.EPersistErrorNotInMemory
				}
			{{else}}
			{{end}}
		{{end}}

		if v, ok := m.hashState.Load(cls.State); ok {
			v.Delete(cls)
		}
		cls.State = State
		if v, ok := m.hashState.LoadOrStore(cls.State, &PersistSet{}); !ok {
			v.Store(cls, true)
		} else {
			v.Store(cls, true)
		}
		// return m.MarkUpdate(cls)
		bitSet := PersistBitSet{}
		bitSet.Set(EPersistFieldIndexState)
		return m.MarkUpdateByBitSet(cls, bitSet)
	}
{{end}}
{{*/}}

{{if .ArgsInfo.OptimizeFlagUsePoolAndDisableDeleteUnload}}
	// EOptimizeFlagUsePoolAndDisableDeleteUnload 优化下不支持修改索引

	// 不建议修改索引列
	{{range $i, $v := .ModifyHashIndexList}}
		// SetIndexKey{{$v.Keys}} 修改包含索引字段, 标记脏对象并异步写回数据库, 需要保证一致性, 生成时开启 EOptimizeFlagIndexMutex
		// (1 数据没有导入或已经导出, 2 数据已经重新导入, 3 对象为空) 会返回失败
		//func (m *{{$.DataName}}Manager) SetIndexKey{{$v.Keys}}(cls *{{$.ArgsInfo.PersistPkgName}}.{{$.DataName}}, {{$v.KeyTypesStripPk}} ) error {
		//	{{if $.ArgsInfo.OptimizeFlagIndexMutex}}
		//		// 需要按照顺序上锁
		//		{{range $ii, $indexItem := $v.EffectIndex}}
		//			m.hash{{$indexItem.Keys}}Mutex.Lock()
		//			defer m.hash{{$indexItem.Keys}}Mutex.Unlock()
		//		{{end}}
		//	{{end}}
		//	if cls == nil {
		//		return persistCore.EPersistErrorNil
		//	}
			{{range $ii, $indexItem := $v.EffectIndex}}
				` + indexRemoveItem + `
			{{end}}

			{{range $iEffect, $vEffect := $v.KeysStripPk}}
			//	cls.{{$vEffect}} = {{$vEffect}}
			{{end}}

			// 不支持修改后插入
			{{/*}}
			{{range $ii, $indexItem := $v.EffectIndex}}
				` + indexAddItem + `
			{{end}}
			{{*/}}
		//	// return m.MarkUpdate(cls)
		//	bitSet := {{$.DataName}}BitSet{}
		//	{{range $iEffect, $vEffect := $v.KeysStripPk}}
			//	bitSet.Set(E{{$.DataName}}FieldIndex{{$vEffect}})
		//	{{end}}
		//	return m.MarkUpdateByBitSet(cls, bitSet)
		//}
	{{end}}
{{else}}
	// EOptimizeFlagUsePoolAndDisableDeleteUnload 优化下不支持修改索引

	// 不建议修改索引列
	{{range $i, $v := .ModifyHashIndexList}}
		// SetIndexKey{{$v.Keys}} 修改包含索引字段, 标记脏对象并异步写回数据库, 需要保证一致性, 生成时开启 EOptimizeFlagIndexMutex
		// (1 数据没有导入或已经导出, 2 数据已经重新导入, 3 对象为空) 会返回失败
		func (m *{{$.DataName}}Manager) SetIndexKey{{$v.Keys}}(cls *{{$.ArgsInfo.PersistPkgName}}.{{$.DataName}}, {{$v.KeyTypesStripPk}} ) error {
			{{if $.ArgsInfo.OptimizeFlagIndexMutex}}
				// 需要按照顺序上锁
				{{range $ii, $indexItem := $v.EffectIndex}}
					m.hash{{$indexItem.Keys}}Mutex.Lock()
					defer m.hash{{$indexItem.Keys}}Mutex.Unlock()
				{{end}}
			{{end}}
			if cls == nil {
				return persistCore.EPersistErrorNil
			}

			{{if $.ArgsInfo.Save}}
				{{if $.HashIndexUnload}}
					if m.LoadState(cls.{{index $.HashIndexUnload.Cols 0}}) != E{{$.DataName}}LoadStateMemory {
						return persistCore.EPersistErrorNotInMemory
					}
				{{ else if $.IsGlobalPersist }}
					if m.LoadAllState() != E{{$.DataName}}LoadStateMemory {
						return persistCore.EPersistErrorNotInMemory
					}
				{{else}}
				{{end}}
			{{end}}


			{{range $ii, $indexItem := $v.EffectIndex}}
				` + indexRemoveItem + `
			{{end}}

			{{range $iEffect, $vEffect := $v.KeysStripPk}}
				cls.{{$vEffect}} = {{$vEffect}}
			{{end}}

			{{range $ii, $indexItem := $v.EffectIndex}}
				` + indexAddItem + `
			{{end}}
			// return m.MarkUpdate(cls)
			bitSet := {{$.DataName}}BitSet{}
			{{range $iEffect, $vEffect := $v.KeysStripPk}}
				bitSet.Set(E{{$.DataName}}FieldIndex{{$vEffect}})
			{{end}}
			return m.MarkUpdateByBitSet(cls, bitSet)
		}
	{{end}}
{{end}}

{{if .ArgsInfo.OptimizeFlagUsePoolAndDisableDeleteUnload}}
	{{range $i, $col := .ModifyColList}}
		// SetIndexKey{{$col}} 修改包含索引字段, 标记脏对象并异步写回数据库, 需要保证一致性, 生成时开启 EOptimizeFlagIndexMutex
		// (1 数据没有导入或已经导出, 2 数据已经重新导入, 3 对象为空) 会返回失败
		//func (m *{{$.DataName}}Manager) SetIndexKey{{$col}}(cls *{{$.ArgsInfo.PersistPkgName}}.{{$.DataName}}, {{$col}} {{index $.KeyTypeMap $col}} ) error {
		//	{{if $.ArgsInfo.OptimizeFlagIndexMutex}}
		//		// 需要按照顺序上锁
		//		{{range $ii, $indexItem := index $.ColEffectHashMap $col}}
		//			m.hash{{$indexItem.Keys}}Mutex.Lock()
		//			defer m.hash{{$indexItem.Keys}}Mutex.Unlock()
		//		{{end}}
		//	{{end}}
		//	if cls == nil {
		//		return persistCore.EPersistErrorNil
		//	}
			{{range $ii, $indexItem := index $.ColEffectHashMap $col}}
				` + indexRemoveItem + `
			{{end}}

		//	cls.{{$col}} = {{$col}}

			// 不支持修改后插入
			{{/*}}
			{{range $ii, $indexItem := index $.ColEffectHashMap $col}}
				` + indexAddItem + `
			{{end}}
			{{*/}}
		//	// return m.MarkUpdate(cls)
		//	bitSet := {{$.DataName}}BitSet{}
		//	bitSet.Set(E{{$.DataName}}FieldIndex{{$col}})
		//	return m.MarkUpdateByBitSet(cls, bitSet)
		//}
	{{end}}
{{else}}
	{{range $i, $col := .ModifyColList}}
		// SetIndexKey{{$col}} 修改包含索引字段, 标记脏对象并异步写回数据库, 需要保证一致性, 生成时开启 EOptimizeFlagIndexMutex
		// (1 数据没有导入或已经导出, 2 数据已经重新导入, 3 对象为空) 会返回失败
		func (m *{{$.DataName}}Manager) SetIndexKey{{$col}}(cls *{{$.ArgsInfo.PersistPkgName}}.{{$.DataName}}, {{$col}} {{index $.KeyTypeMap $col}} ) error {
			{{if $.ArgsInfo.OptimizeFlagIndexMutex}}
				// 需要按照顺序上锁
				{{range $ii, $indexItem := index $.ColEffectHashMap $col}}
					m.hash{{$indexItem.Keys}}Mutex.Lock()
					defer m.hash{{$indexItem.Keys}}Mutex.Unlock()
				{{end}}
			{{end}}
			if cls == nil {
				return persistCore.EPersistErrorNil
			}

			{{if $.ArgsInfo.Save}}
				{{if $.HashIndexUnload}}
					if m.LoadState(cls.{{index $.HashIndexUnload.Cols 0}}) != E{{$.DataName}}LoadStateMemory {
						return persistCore.EPersistErrorNotInMemory
					}
				{{ else if $.IsGlobalPersist }}
					if m.LoadAllState() != E{{$.DataName}}LoadStateMemory {
						return persistCore.EPersistErrorNotInMemory
					}
				{{else}}
				{{end}}
			{{end}}


			{{range $ii, $indexItem := index $.ColEffectHashMap $col}}
				` + indexRemoveItem + `
			{{end}}

			cls.{{$col}} = {{$col}}

			{{range $ii, $indexItem := index $.ColEffectHashMap $col}}
				` + indexAddItem + `
			{{end}}
			// return m.MarkUpdate(cls)
			bitSet := {{$.DataName}}BitSet{}
			bitSet.Set(E{{$.DataName}}FieldIndex{{$col}})
			return m.MarkUpdateByBitSet(cls, bitSet)
		}
	{{end}}
{{end}}


{{/* mark update }}
// MarkUpdate 标记脏对象并异步写回数据库, (1 数据没有导入或已经导出, 2 数据已经重新导入, 3 对象为空) 会返回失败
func (m *PersistManager) MarkUpdate(cls *Persist) error {

	if cls == nil {
		return persistCore.EPersistErrorNil
	}
	{{if $.ArgsInfo.Save}}
		{{if .HashIndexUnload}}
			if m.LoadState(cls.Uid) != EPersistLoadStateMemory {
				return persistCore.EPersistErrorNotInMemory
			}
		{{ else if $.IsGlobalPersist }}
			if m.LoadAllState() != E{{$.DataName}}LoadStateMemory {
				return persistCore.EPersistErrorNotInMemory
			}
		{{else}}
		{{end}}
	{{end}}

	p := m.GetPersistByUidId(cls.Uid, cls.Id)
	if p == nil || p != cls {
		return persistCore.EPersistErrorOutOfDate
	}

{{if $.ArgsInfo.Save}}
	m.InitDS(cls)

	bitSet := PersistBitSet{}
	bitSet.SetAll()
	newCls := m.acquireDeepCopyObject(cls)

	persistSync := &PersistSync{Data: newCls, Op: E{{.DataName}}OpUpdate, BitSet: bitSet}
	{{if .ArgsInfo.OptimizeFlagTraceSwitch}}
		log.Println("[sql trace Persist]", m.PersistSyncToString(persistSync))
	{{end}}
	m.syncChan <- persistSync

{{end}}
	return nil
}
{{*/}}
// MarkUpdate 标记脏对象并异步写回数据库, (1 数据没有导入或已经导出, 2 数据已经重新导入, 3 对象为空) 会返回失败
func (m *{{.DataName}}Manager) MarkUpdate(cls *{{.ArgsInfo.PersistPkgName}}.{{.DataName}}) error {
	if cls == nil {
		return persistCore.EPersistErrorNil
	}
	{{if $.ArgsInfo.Save}}
		{{if .HashIndexUnload}}
			if m.LoadState(cls.{{index .HashIndexUnload.Cols 0}}) != E{{.DataName}}LoadStateMemory {
				return persistCore.EPersistErrorNotInMemory
			}
		{{ else if $.IsGlobalPersist }}
			if m.LoadAllState() != E{{.DataName}}LoadStateMemory {
				return persistCore.EPersistErrorNotInMemory
			}
		{{else}}
		{{end}}
	{{end}}

	{{if .HashIndexPk}}
		p := m.Get{{.DataName}}By{{.HashIndexPk.Keys}}({{.HashIndexPk.ClsPointKeys}})
		if p == nil || p != cls {
			return persistCore.EPersistErrorOutOfDate
		}
	{{end}}
	
	{{if $.HaveRBTree}}
		m.SetData(cls)
	{{end}}
{{if $.ArgsInfo.Save}}
	m.InitDS(cls)
	bitSet := {{.DataName}}BitSet{}
	bitSet.SetAll()
	newCls := m.acquireDeepCopyObject(cls)

	persistSync := &{{.DataName}}Sync{Data: newCls, Op: E{{.DataName}}OpUpdate, BitSet: bitSet}
	{{if .ArgsInfo.OptimizeFlagTraceSwitch}}
		log.Println("[sql trace {{.DataName}}]", m.PersistSyncToString(persistSync))
	{{end}}
	m.syncChan <- persistSync

{{end}}
	return nil
}

{{/* MarkUpdateByBitSet }}
// MarkUpdateByBitSet 标记脏对象并异步写回数据库, (1 数据没有导入或已经导出, 2 数据已经重新导入, 3 对象为空) 会返回失败
func (m *PersistManager) MarkUpdateByBitSet(cls *Persist, bitSet PersistBitSet) error {
	if cls == nil {
		return persistCore.EPersistErrorNil
	}

	{{if .HashIndexUnload}}
		if m.LoadState(cls.Uid) != EPersistLoadStateMemory {
			return persistCore.EPersistErrorNotInMemory
		}
	{{ else if $.IsGlobalPersist }}
		if m.LoadAllState() != E{{$.DataName}}LoadStateMemory {
			return persistCore.EPersistErrorNotInMemory
		}
	{{else}}
	{{end}}


	p := m.GetPersistByUidId(cls.Uid, cls.Id)
	if p == nil || p != cls {
		return persistCore.EPersistErrorOutOfDate
	}

	m.InitDS(cls)

	newCls := m.acquireDeepCopyObject(cls)

	persistSync := &PersistSync{Data: newCls, Op: EPersistOpUpdate, BitSet: bitSet}
	{{if .ArgsInfo.OptimizeFlagTraceSwitch}}
		log.Println("[sql trace Persist]", m.PersistSyncToString(persistSync))
	{{end}}
	m.syncChan <- persistSync

	return nil
}
{{*/}}
// MarkUpdateByBitSet 标记脏对象并异步写回数据库, (1 数据没有导入或已经导出, 2 数据已经重新导入, 3 对象为空) 会返回失败
func (m *{{.DataName}}Manager) MarkUpdateByBitSet(cls *{{.ArgsInfo.PersistPkgName}}.{{.DataName}}, bitSet {{.DataName}}BitSet) error {
	if cls == nil {
		return persistCore.EPersistErrorNil
	}

	{{if $.ArgsInfo.Save}}
		{{if .HashIndexUnload}}
			if m.LoadState(cls.{{index .HashIndexUnload.Cols 0}}) != E{{.DataName}}LoadStateMemory {
				return persistCore.EPersistErrorNotInMemory
			}
		{{ else if $.IsGlobalPersist }}
			if m.LoadAllState() != E{{$.DataName}}LoadStateMemory {
				return persistCore.EPersistErrorNotInMemory
			}
		{{else}}
		{{end}}
	{{end}}

	{{if .HashIndexPk}}
		p := m.Get{{.DataName}}By{{.HashIndexPk.Keys}}({{.HashIndexPk.ClsPointKeys}})
		if p == nil || p != cls {
			return persistCore.EPersistErrorOutOfDate
		}
	{{end}}

{{if $.HaveRBTree}}
	 rbtreeValueUpdate := false 	
	{{range $i, $typeInfo := .FieldTypeList}}
		{{ $fieldName := index $.FieldNameList $i }}
		{{if $.IsRBTreeValue $fieldName}} 
			if bitSet.Get(E{{$.DataName}}FieldIndex{{ $fieldName }}) {
	 			rbtreeValueUpdate = true 	
			}
		{{end}}
	{{end}}
	if rbtreeValueUpdate {
		m.SetData(cls)
	}
{{end}}

{{if $.ArgsInfo.Save}}
	m.InitDS(cls)

	newCls := m.acquireDeepCopyObject(cls)

	persistSync := &{{.DataName}}Sync{Data: newCls, Op: E{{.DataName}}OpUpdate, BitSet: bitSet}
	{{if .ArgsInfo.OptimizeFlagTraceSwitch}}
		log.Println("[sql trace {{.DataName}}]", m.PersistSyncToString(persistSync))
	{{end}}
	m.syncChan <- persistSync

{{end}}
	return nil
}


{{/* MarkUpdateByBitSet }}
// MarkUpdateByFieldIndex 标记脏对象并异步写回数据库, (1 数据没有导入或已经导出, 2 数据已经重新导入, 3 对象为空) 会返回失败
func (m *PersistManager) MarkUpdateByFieldIndex(cls *Persist, fieldIndex PersistFieldIndex) error {
	return m.MarkUpdateByBitSet(cls, *((&PersistBitSet{}).Set(fieldIndex)))
}
{{*/}}
// MarkUpdateByFieldIndex 标记脏对象并异步写回数据库, (1 数据没有导入或已经导出, 2 数据已经重新导入, 3 对象为空) 会返回失败
func (m *{{.DataName}}Manager) MarkUpdateByFieldIndex(cls *{{.ArgsInfo.PersistPkgName}}.{{.DataName}}, fieldIndex {{.DataName}}FieldIndex) error {
	return m.MarkUpdateByBitSet(cls, *((&{{.DataName}}BitSet{}).Set(fieldIndex)))
}



{{/* get }}
{{if .ArgsInfo.OptimizeFlagUsePoolAndDisableDeleteUnload}}
	// GetPersistByUidId 通过索引查找对象
	func (m *PersistManager) GetPersistByUidId(Uid int32, Id int32) (*Persist) {
		{{if $.ArgsInfo.OptimizeFlagIndexMutex}}
			// 需要按照顺序上锁
			{{range $ii, $indexItem := $v.EffectIndex}}
				m.hash{{$indexItem.Keys}}Mutex.RLock()
				defer m.hash{{$indexItem.Keys}}Mutex.RUnlock()
			{{end}}
		{{end}}
		if data, ok := m.hashUidId.Load(PersistKeyTypeHashUidId{Uid, Id}); ok {
			return  m.objectPool.Get(data)
		}
		return nil
	}
	// GetPersistsByUid 通过索引查找对象
	func (m *PersistManager) GetPersistsByUid(Uid int32) (ret []*Persist) {
		{{if $.ArgsInfo.OptimizeFlagIndexMutex}}
			// 需要按照顺序上锁
			{{range $ii, $indexItem := $v.EffectIndex}}
				m.hash{{$indexItem.Keys}}Mutex.RLock()
				defer m.hash{{$indexItem.Keys}}Mutex.RUnlock()
			{{end}}
		{{end}}
		if data, ok := m.hashUid.Load(Uid); ok {
			for _, objIdx := range m.objectMapPool.Get(data){
				obj := m.objectPool.Get(objIdx)
				if obj != nil {
					ret = append(ret, obj)
				}
			}
		}
		return
	}
{{else}}
	// GetPersistByUidId 通过索引查找对象
	func (m *PersistManager) GetPersistByUidId(Uid int32, Id int32) (*Persist) {
		{{if $.ArgsInfo.OptimizeFlagIndexMutex}}
			// 需要按照顺序上锁
			{{range $ii, $indexItem := $v.EffectIndex}}
				m.hash{{$indexItem.Keys}}Mutex.RLock()
				defer m.hash{{$indexItem.Keys}}Mutex.RUnlock()
			{{end}}
		{{end}}
		if data, ok := m.hashUidId.Load(PersistKeyTypeHashUidId{Uid, Id}); ok {
			return data
		}
		return nil
	}
	// GetPersistsByUid 通过索引查找对象
	func (m *PersistManager) GetPersistsByUid(Uid int32) (ret []*Persist) {
		{{if $.ArgsInfo.OptimizeFlagIndexMutex}}
			// 需要按照顺序上锁
			{{range $ii, $indexItem := $v.EffectIndex}}
				m.hash{{$indexItem.Keys}}Mutex.RLock()
				defer m.hash{{$indexItem.Keys}}Mutex.RUnlock()
			{{end}}
		{{end}}
		if data, ok := m.hashUid.Load(Uid); ok {
			data.Range(func(k *Persist, v bool) bool {
				ret = append(ret, k)
				return true
			})
		}
		return
	}
{{end}}
{{*/}}
{{if .ArgsInfo.OptimizeFlagUsePoolAndDisableDeleteUnload}}
	{{range $i, $v := .HashIndexList}}
		{{if $v.Unique}}    
			// Get{{$.DataName}}By{{$v.Keys}} 通过索引查找对象
			func (m *{{$.DataName}}Manager) Get{{$.DataName}}By{{$v.Keys}}({{$v.KeyTypes}}) (*{{$.ArgsInfo.PersistPkgName}}.{{$.DataName}}) {
				{{if $.ArgsInfo.OptimizeFlagIndexMutex}}
					// 需要按照顺序上锁, 主键不允许修改不需要上锁
					{{range $ii, $indexItem := $v.EffectIndex}}
						m.hash{{$indexItem.Keys}}Mutex.RLock()
						defer m.hash{{$indexItem.Keys}}Mutex.RUnlock()
					{{end}}
				{{end}}
				if data, ok := m.hash{{$v.Keys}}.Load({{$.DataName}}KeyTypeHash{{$v.Keys}}{ {{$v.CommaKeys}} }); ok {
					return m.objectPool.Get(data)
				}
				return nil
			}
		{{else}}
			// Get{{$.DataName}}sBy{{$v.Keys}} 通过索引查找对象
			func (m *{{$.DataName}}Manager) Get{{$.DataName}}sBy{{$v.Keys}}({{$v.KeyTypes}}) (ret []*{{$.ArgsInfo.PersistPkgName}}.{{$.DataName}}) {
				{{if $.ArgsInfo.OptimizeFlagIndexMutex}}
					// 需要按照顺序上锁, 主键不允许修改不需要上锁
					{{range $ii, $indexItem := $v.EffectIndex}}
						m.hash{{$indexItem.Keys}}Mutex.RLock()
						defer m.hash{{$indexItem.Keys}}Mutex.RUnlock()
					{{end}}
				{{end}}
				if data, ok := m.hash{{$v.Keys}}.Load({{$.DataName}}KeyTypeHash{{$v.Keys}}{ {{$v.CommaKeys}} }); ok {
					for _, objIdx := range m.objectMapPool.Get(data){
						obj := m.objectPool.Get(objIdx)
						if obj != nil {
							ret = append(ret, obj)
						}
					}
				}
				return
			}
		{{end}}
	{{end}}
{{else}}
	{{range $i, $v := .HashIndexList}}
		{{if $v.Unique}}    
			// Get{{$.DataName}}By{{$v.Keys}} 通过索引查找对象
			func (m *{{$.DataName}}Manager) Get{{$.DataName}}By{{$v.Keys}}({{$v.KeyTypes}}) (*{{$.ArgsInfo.PersistPkgName}}.{{$.DataName}}) {
				{{if $.ArgsInfo.OptimizeFlagIndexMutex}}
					// 需要按照顺序上锁, 主键不允许修改不需要上锁
					{{range $ii, $indexItem := $v.EffectIndex}}
						m.hash{{$indexItem.Keys}}Mutex.RLock()
						defer m.hash{{$indexItem.Keys}}Mutex.RUnlock()
					{{end}}
				{{end}}
				if data, ok := m.hash{{$v.Keys}}.Load({{$.DataName}}KeyTypeHash{{$v.Keys}}{ {{$v.CommaKeys}} }); ok {
					return data
				}
				return nil
			}
		{{else}}
			// Get{{$.DataName}}sBy{{$v.Keys}} 通过索引查找对象
			func (m *{{$.DataName}}Manager) Get{{$.DataName}}sBy{{$v.Keys}}({{$v.KeyTypes}}) (ret []*{{$.ArgsInfo.PersistPkgName}}.{{$.DataName}}) {
				{{if $.ArgsInfo.OptimizeFlagIndexMutex}}
					// 需要按照顺序上锁, 主键不允许修改不需要上锁
					{{range $ii, $indexItem := $v.EffectIndex}}
						m.hash{{$indexItem.Keys}}Mutex.RLock()
						defer m.hash{{$indexItem.Keys}}Mutex.RUnlock()
					{{end}}
				{{end}}
				if data, ok := m.hash{{$v.Keys}}.Load({{$.DataName}}KeyTypeHash{{$v.Keys}}{ {{$v.CommaKeys}} }); ok {
					data.Range(func(k *{{$.ArgsInfo.PersistPkgName}}.{{$.DataName}}, v bool) bool {
						ret = append(ret, k)
						return true
					})
				}
				return
			}
		{{end}}
	{{end}}
{{end}}



{{/* get all }}
{{if .ArgsInfo.OptimizeFlagUsePoolAndDisableDeleteUnload}}
	// GetAll 通过主键查找所有对象
	func (m *PersistManager) GetAll() (ret []*Persist) {
		return m.objectPool.GetAll()
	}
{{else}}
	// GetAll 通过主键查找所有对象
	func (m *PersistManager) GetAll() (ret []*Persist) {
		 // 这里的锁其实是多余的
		{{if $.ArgsInfo.OptimizeFlagIndexMutex}}
			// 需要按照顺序上锁
			{{range $ii, $indexItem := .HashIndexList}}
				m.hash{{$indexItem.Keys}}Mutex.RLock()
				defer m.hash{{$indexItem.Keys}}Mutex.RUnlock()
			{{end}}
		{{end}}
		m.hashUidId.Range(func(k PersistKeyTypeHashUidId, v *Persist) bool {
			ret = append(ret, v)
			return true
		})
		return
	}
{{end}}
{{*/}}
{{if .ArgsInfo.OptimizeFlagUsePoolAndDisableDeleteUnload}}
	{{if .HashIndexPk}}    
		// GetAll 通过主键查找所有对象
		func (m *{{.DataName}}Manager) GetAll() (ret []*{{.ArgsInfo.PersistPkgName}}.{{.DataName}}) {
			{{if $.ArgsInfo.OptimizeFlagIndexMutex}}
				// 需要按照顺序上锁
				{{range $ii, $indexItem := .HashIndexList}}
					m.hash{{$indexItem.Keys}}Mutex.RLock()
					defer m.hash{{$indexItem.Keys}}Mutex.RUnlock()
				{{end}}
			{{end}}
			return m.objectPool.GetAll()
		}
	{{else}}

	{{end}}
{{else}}
	{{if .HashIndexPk}}    
		// GetAll 通过主键查找所有对象
		func (m *{{.DataName}}Manager) GetAll() (ret []*{{.ArgsInfo.PersistPkgName}}.{{.DataName}}) {
			{{if $.ArgsInfo.OptimizeFlagIndexMutex}}
				// 需要按照顺序上锁
				{{range $ii, $indexItem := .HashIndexList}}
					m.hash{{$indexItem.Keys}}Mutex.RLock()
					defer m.hash{{$indexItem.Keys}}Mutex.RUnlock()
				{{end}}
			{{end}}
			m.hash{{.HashIndexPk.Keys}}.Range(func(k {{.DataName}}KeyTypeHash{{.HashIndexPk.Keys}}, v *{{.ArgsInfo.PersistPkgName}}.{{.DataName}}) bool {
				ret = append(ret, v)
				return true
			})
			return
		}
	{{else}}

	{{end}}

{{end}}

{{/* LoadAllState }}
{{if $.ArgsInfo.Save}}
	// LoadAllState 所有数据导入状态
	func (m *PersistManager) LoadAllState() int32 {
		return atomic.LoadInt32(&m.loadAll)
	}
{{end}}
{{*/}}
{{if $.ArgsInfo.Save}}
	// LoadAllState 所有数据导入状态
	func (m *{{.DataName}}Manager) LoadAllState() int32 {
		return atomic.LoadInt32(&m.loadAll)
	}
{{end}}


{{/* loadAll }}
{{if $.ArgsInfo.Save}}
	// LoadAll (非线程安全) 导入所有数据, 全导入后只能全导出, 不能再按照key导入导出
	func (m *PersistManager) LoadAll() (err error) {
		log.Println("PersistManager LoadAll begin")
		// 未全导入状态切换到全导入
		if atomic.CompareAndSwapInt32(&m.loadAll, EPersistTableStateDisk, EPersistTableStateLoading){
			rows := make([]*Persist, 0)
			err = m.engine.Find(&rows, gPersistNil)
			if err != nil {
				atomic.StoreInt32(&m.loadAll, EPersistTableStateDisk)
				return err
			} else {
				{{if .ArgsInfo.OptimizeFlagIndexMutex}}
					{{range $i, $indexItem := .HashIndexList}}
						m.hash{{$indexItem.Keys}}Mutex.Lock()
						defer m.hash{{$indexItem.Keys}}Mutex.Unlock()
					{{end}}
				{{end}}
				for _, row := range rows{
					m.addPersist(row)
				}
				atomic.StoreInt32(&m.loadAll, EPersistTableStateMemory)
			}
		} else {
			return persistCore.EPersistErrorIncorrectState
		}
		log.Println("PersistManager LoadAll end")
		return
	}
	{{end}}
{{*/}}
{{if .HashIndexPk}}
	{{if $.ArgsInfo.Save}}
		// LoadAll (非线程安全) 导入所有数据, 全导入后只能全导出, 不能再按照key导入导出
		func (m *{{.DataName}}Manager) LoadAll() (err error) {
			log.Println("{{.DataName}}Manager LoadAll begin")
			// 未全导入状态切换到全导入
			if atomic.CompareAndSwapInt32(&m.loadAll, E{{.DataName}}TableStateDisk, E{{.DataName}}TableStateLoading){
				rows := make([]*{{.ArgsInfo.PersistPkgName}}.{{.DataName}}, 0)
				err = m.engine.Find(&rows, g{{.DataName}}Nil)
				if err != nil {
					atomic.StoreInt32(&m.loadAll, E{{.DataName}}TableStateDisk)
					return err
				} else {
					{{if .ArgsInfo.OptimizeFlagIndexMutex}}
						{{range $i, $indexItem := .HashIndexList}}
							m.hash{{$indexItem.Keys}}Mutex.Lock()
							defer m.hash{{$indexItem.Keys}}Mutex.Unlock()
						{{end}}
					{{end}}
					for _, row := range rows {
						m.add{{.DataName}}(row)
					}
					atomic.StoreInt32(&m.loadAll, E{{.DataName}}TableStateMemory)
				}
			} else {
				return persistCore.EPersistErrorIncorrectState
			}
			log.Println("{{.DataName}}Manager LoadAll end")
			return
		}
	{{end}}
{{else}}

{{end}}

{{/* LoadState }}
{{if $.ArgsInfo.Save}}
{{if .HashIndexUnload}}
	// LoadState 查询包含该key的数据导入状态
	func (m *PersistManager) LoadState(Uid int32) int32 {
		if atomic.LoadInt32(&m.loadAll) == EPersistTableStateDisk {
			if value, ok := m.loadUidMap.Load(Uid); ok {
				state := value
				return atomic.LoadInt32(state)
			} else {
				return EPersistLoadStateDisk
			}
		} else {
			return EPersistLoadStateMemory
		}
	}
{{end}}
{{end}}
{{*/}}
{{if $.ArgsInfo.Save}}
{{if .HashIndexUnload}}
	// LoadState 查询包含该key的数据导入状态
	func (m *{{.DataName}}Manager) LoadState({{index .HashIndexUnload.Cols 0}} {{index .HashIndexUnload.Types 0}}) int32 {
		if atomic.LoadInt32(&m.loadAll) == E{{.DataName}}TableStateDisk {
			if value, ok := m.load{{index .HashIndexUnload.Cols 0}}Map.Load({{index .HashIndexUnload.Cols 0}}); ok {
				state := value
				return atomic.LoadInt32(state)
			} else {
				return E{{.DataName}}LoadStateDisk
			}
		} else {
			return E{{.DataName}}LoadStateMemory
		}
	}
{{end}}
{{end}}


{{/* SetLoadState2Memory }}
{{if $.ArgsInfo.Save}}
{{if .HashIndexUnload}}
	// SetLoadState2Memory 没有数据时, 标记数据在内存中. 仅用于第一次数据库导入空数据, 错误使用会导致未定义的行为
	func (m *PersistManager) SetLoadState2Memory(Uid int32) {
		if atomic.LoadInt32(&m.loadAll) == EPersistTableStateDisk {
			p := int32(EPersistLoadStateMemory)
			m.loadUidMap.Store(Uid, &p)
		} else {
		}
	}
{{end}}
{{end}}
{{*/}}
{{if $.ArgsInfo.Save}}
{{if .HashIndexUnload}}
	// SetLoadState2Memory 没有数据时, 标记数据在内存中. 仅用于第一次数据库导入空数据, 错误使用会导致未定义的行为
	func (m *{{.DataName}}Manager) SetLoadState2Memory({{index .HashIndexUnload.Cols 0}} {{index .HashIndexUnload.Types 0}}) {
		if atomic.LoadInt32(&m.loadAll) == E{{.DataName}}TableStateDisk {
			p := int32(E{{.DataName}}LoadStateMemory)
			m.load{{index .HashIndexUnload.Cols 0}}Map.Store({{index .HashIndexUnload.Cols 0}}, &p)
		} else {
		}
	}
{{end}}
{{end}}


{{/* load }}
{{if $.ArgsInfo.Save}}
	// Load 按照key导入数据, 必须存在unload key的索引
	func (m *PersistManager) Load(UnloadKey UnloadKeyType) (err error) {
		// return 不存在unload key时直接返回
		// LoadAll后不能再次Load
		if atomic.LoadInt32(&m.loadAll) == EPersistTableStateDisk {
			p := int32(0)
			value, _ := m.loadUidMap.LoadOrStore(Uid, &p)
			state := value
			// 检查导入状态
			switch atomic.LoadInt32(state) {
			// 未导入状态切换到导入
			case EPersistLoadStateDisk:
				if atomic.CompareAndSwapInt32(state, EPersistLoadStateDisk, EPersistLoadStateLoading) {
					rows := make([]*Persist, 0)
					err = m.engine.Find(&rows, &Persist{Uid: Uid})
					if err != nil { // 导入失败, 状态回到导出
						atomic.StoreInt32(state, EPersistLoadStateDisk)
					} else {
						for _, row := range rows{
							m.addPersist(row)
						}
						atomic.StoreInt32(state, EPersistLoadStateMemory)
					}
					return
				} else { // 期间状态变化,不确定操作是否成功
					return persistCore.EPersistErrorUnknownError
				}

			case EPersistLoadStateLoading: // 正在导入
				// 并发导入暂时轮询等待
				bTime := time.Now().Unix()
				for {
					if atomic.LoadInt32(state) != EPersistLoadStateLoading {
						break
					}
					if time.Now().Unix() > bTime+persistCore.ELoadPollingTimeOut {
						break
					}
					time.Sleep(time.Millisecond * 100)
				}
				if atomic.LoadInt32(state) == EPersistLoadStateMemory {
					return
				} else {
					return persistCore.EPersistErrorUnknownError
				}

			case EPersistLoadStateMemory: // 导入完成
				return

			case EPersistLoadStatePrepareUnloading: // 准备导出,立即取消导出
				if atomic.CompareAndSwapInt32(state, EPersistLoadStatePrepareUnloading, EPersistLoadStateMemory) {
					return
				} else { // 期间状态变化,不确定操作是否成功
					return persistCore.EPersistErrorUnknownError
				}
			case EPersistLoadStateUnloading: // 正在导出
				return persistCore.EPersistErrorUnloading
			default: // ???
				return persistCore.EPersistErrorUnknownError
			}
		} else {
			return
		}
	}
{{end}}
{{*/}}
{{if $.ArgsInfo.Save}}
{{if .HashIndexUnload}}
	// Load 按照key导入数据, 必须存在unload key的索引
	func (m *{{.DataName}}Manager) Load({{index .HashIndexUnload.Cols 0}} {{index .HashIndexUnload.Types 0}}) (err error) {
		// LoadAll后不能再次Load
		if atomic.LoadInt32(&m.loadAll) == E{{.DataName}}TableStateDisk {
			p := int32(0)
			value, _ := m.load{{index .HashIndexUnload.Cols 0}}Map.LoadOrStore({{index .HashIndexUnload.Cols 0}}, &p)
			state := value
			// 检查导入状态
			switch atomic.LoadInt32(state) {
			// 未导入状态切换到导入
			case E{{.DataName}}LoadStateDisk:
				if atomic.CompareAndSwapInt32(state, E{{.DataName}}LoadStateDisk, E{{.DataName}}LoadStateLoading) {
					rows := make([]*{{.ArgsInfo.PersistPkgName}}.{{.DataName}}, 0)
					err = m.engine.Find(&rows, &{{.ArgsInfo.PersistPkgName}}.{{.DataName}}{ {{index .HashIndexUnload.Cols 0}}: {{index .HashIndexUnload.Cols 0}} })

					if err != nil { // 导入失败, 状态回到导出
						atomic.StoreInt32(state, E{{.DataName}}LoadStateDisk)
					} else {
						{{if .ArgsInfo.OptimizeFlagIndexMutex}}
							{{range $i, $indexItem := .HashIndexList}}
								m.hash{{$indexItem.Keys}}Mutex.Lock()
								defer m.hash{{$indexItem.Keys}}Mutex.Unlock()
							{{end}}
						{{end}}
						for _, row := range rows{
							m.add{{.DataName}}(row)
						}
						atomic.StoreInt32(state, E{{.DataName}}LoadStateMemory)
					}
					return
				} else { // 期间状态变化,不确定操作是否成功
					return persistCore.EPersistErrorUnknownError
				}

			case E{{.DataName}}LoadStateLoading: // 正在导入
				// 并发导入暂时轮询等待
				bTime := time.Now().Unix()
				for {
					if atomic.LoadInt32(state) != E{{.DataName}}LoadStateLoading {
						break
					}
					if time.Now().Unix() > bTime+persistCore.ELoadPollingTimeOut {
						break
					}
					time.Sleep(time.Millisecond * 100)
				}
				if atomic.LoadInt32(state) == E{{.DataName}}LoadStateMemory {
					return
				} else {
					return persistCore.EPersistErrorUnknownError
				}

			case E{{.DataName}}LoadStateMemory: // 导入完成
				return

			case E{{.DataName}}LoadStatePrepareUnloading: // 准备导出,立即取消导出
				if atomic.CompareAndSwapInt32(state, E{{.DataName}}LoadStatePrepareUnloading, E{{.DataName}}LoadStateMemory) {
					return
				} else { // 期间状态变化,不确定操作是否成功
					return persistCore.EPersistErrorUnknownError
				}

			case E{{.DataName}}LoadStateUnloading: // 正在导出
				return persistCore.EPersistErrorUnloading
			default: // ???
				return persistCore.EPersistErrorUnknownError
			}
		} else {
			return
		}
	}
{{end}}
{{end}}



{{/* UnloadAll }}
{{if .ArgsInfo.OptimizeFlagUsePoolAndDisableDeleteUnload}}
	//{{if $.ArgsInfo.Save}}
	// EOptimizeFlagUsePoolAndDisableDeleteUnload 优化下不支持导出
	//	// UnloadAll (非线程安全) 导出所有数据, 调用UnloadAll后,不允许再修改相关的数据(必须先导入才能修改数据)
	//	func (m *PersistManager) UnloadAll() (err error) {
	//		var clsList []*Persist
	//		// 未导入状态切换到导入
	//		if atomic.CompareAndSwapInt32(&m.loadAll, EPersistTableStateMemory, EPersistTableStateUnloading) {
	//			{{if .ArgsInfo.OptimizeFlagIndexMutex}}
	//				{{range $i, $indexItem := .HashIndexList}}
	//					m.hash{{$indexItem.Keys}}Mutex.Lock()
	//					defer m.hash{{$indexItem.Keys}}Mutex.Unlock()
	//				{{end}}
	//			{{end}}
	//			m.hashUidId.Range(func(k PersistKeyTypeHashUidId, v *Persist) bool {
	//				clsList = append(clsList, v)
	//				return true
	//			})
	//			for _, cls := range clsList {
	//				m.removePersist(cls)
	//			}
	//			atomic.StoreInt32(&m.loadAll, EPersistTableStateDisk)
	//		} else {
	//			return persistCore.EPersistErrorIncorrectState
	//		}
	//		return
	//	}
	//{{end}}
{{else}}
	{{if $.ArgsInfo.Save}}
		// EOptimizeFlagUsePoolAndDisableDeleteUnload 优化下不支持导出
		// UnloadAll (非线程安全) 导出所有数据, 调用UnloadAll后,不允许再修改相关的数据(必须先导入才能修改数据)
		func (m *PersistManager) UnloadAll() (err error) {
			var clsList []*Persist
			// 未导入状态切换到导入
			if atomic.CompareAndSwapInt32(&m.loadAll, EPersistTableStateMemory, EPersistTableStateUnloading) {
				{{if .ArgsInfo.OptimizeFlagIndexMutex}}
					{{range $i, $indexItem := .HashIndexList}}
						m.hash{{$indexItem.Keys}}Mutex.Lock()
						defer m.hash{{$indexItem.Keys}}Mutex.Unlock()
					{{end}}
				{{end}}
				m.hashUidId.Range(func(k PersistKeyTypeHashUidId, v *Persist) bool {
					clsList = append(clsList, v)
					return true
				})
				for _, cls := range clsList {
					m.removePersist(cls)
				}
				atomic.StoreInt32(&m.loadAll, EPersistTableStateDisk)
			} else {
				return persistCore.EPersistErrorIncorrectState
			}
			return
		}
	{{end}}
{{end}}
{{*/}}

{{if .ArgsInfo.OptimizeFlagUsePoolAndDisableDeleteUnload}}
	{{if .HashIndexPk}}
	{{if $.ArgsInfo.Save}}
		// EOptimizeFlagUsePoolAndDisableDeleteUnload 优化下不支持导出
		// UnloadAll (非线程安全) 导出所有数据, 调用UnloadAll后,不允许再修改相关的数据(必须先导入才能修改数据)
		//func (m *{{.DataName}}Manager) UnloadAll() (err error) {
		//	var clsList []*{{.ArgsInfo.PersistPkgName}}.{{.DataName}}
		//	// 未导入状态切换到导入
		//	if atomic.CompareAndSwapInt32(&m.loadAll, E{{.DataName}}TableStateMemory, E{{.DataName}}TableStateUnloading) {
		//		{{if .ArgsInfo.OptimizeFlagIndexMutex}}
		//			{{range $i, $indexItem := .HashIndexList}}
		//				m.hash{{$indexItem.Keys}}Mutex.Lock()
		//				defer m.hash{{$indexItem.Keys}}Mutex.Unlock()
		//			{{end}}
		//		{{end}}
		//		m.hash{{.HashIndexPk.Keys}}.Range(func(k {{.DataName}}KeyTypeHash{{.HashIndexPk.Keys}}, v *{{.ArgsInfo.PersistPkgName}}.{{.DataName}}) bool {
		//			clsList = append(clsList, v)
		//			return true
		//		})
		//		for _, cls := range clsList {
		//			m.remove{{.DataName}}(cls)
		//		}
		//		atomic.StoreInt32(&m.loadAll, E{{.DataName}}TableStateDisk)
		//	} else {
		//		return persistCore.EPersistErrorIncorrectState
		//	}
		//	return
		//}
	{{end}}
	{{else}}

	{{end}}
{{else}}
	{{if .HashIndexPk}}
	{{if $.ArgsInfo.Save}}
		// UnloadAll (非线程安全) 导出所有数据, 调用UnloadAll后,不允许再修改相关的数据(必须先导入才能修改数据)
		func (m *{{.DataName}}Manager) UnloadAll() (err error) {
			var clsList []*{{.ArgsInfo.PersistPkgName}}.{{.DataName}}
			// 未导入状态切换到导入
			if atomic.CompareAndSwapInt32(&m.loadAll, E{{.DataName}}TableStateMemory, E{{.DataName}}TableStateUnloading) {
				{{if .ArgsInfo.OptimizeFlagIndexMutex}}
					{{range $i, $indexItem := .HashIndexList}}
						m.hash{{$indexItem.Keys}}Mutex.Lock()
						defer m.hash{{$indexItem.Keys}}Mutex.Unlock()
					{{end}}
				{{end}}
				m.hash{{.HashIndexPk.Keys}}.Range(func(k {{.DataName}}KeyTypeHash{{.HashIndexPk.Keys}}, v *{{.ArgsInfo.PersistPkgName}}.{{.DataName}}) bool {
					clsList = append(clsList, v)
					return true
				})
				for _, cls := range clsList {
					m.remove{{.DataName}}(cls)
				}
				atomic.StoreInt32(&m.loadAll, E{{.DataName}}TableStateDisk)
			} else {
				return persistCore.EPersistErrorIncorrectState
			}
			return
		}
	{{end}}
	{{else}}

	{{end}}
{{end}}




{{/* Unload }}
{{if .ArgsInfo.OptimizeFlagUsePoolAndDisableDeleteUnload}}
	{{if $.ArgsInfo.Save}}
		// EOptimizeFlagUsePoolAndDisableDeleteUnload 优化下不支持导出
		// Unload 按照key导出数据, 必须存在unload key的索引. 调用Unload后,不允许再修改相关的数据(必须先导入才能修改数据).
		//func (m *PersistManager) Unload(UnloadKey UnloadKeyType) (err error) {
		//	{{if $.ArgsInfo.Unload}}
		//		// return 不存在unload key时直接返回
		//		// LoadAll后不能unload
		//		if atomic.LoadInt32(&m.loadAll) == EPersistTableStateDisk {
		//			if value, ok := m.loadUnloadKeyMap.Load(UnloadKey); ok {
		//				state := value
		//				switch atomic.LoadInt32(state) {
		//				case EPersistLoadStateDisk: // 未导入
		//					return //persistCore.EPersistErrorNotInMemory
		//				case EPersistLoadStateLoading: // 正在导入
		//					return persistCore.EPersistErrorLoading
		//				case EPersistLoadStateMemory: // 导入完成, 开始导出吧
		//					if atomic.CompareAndSwapInt32(state, EPersistLoadStateMemory, EPersistLoadStatePrepareUnloading) {
		//						m.syncChan <- &PersistSync{Data: &Persist{Uid: Uid}, Op: EPersistOpUnload}
		//						return
		//					} else { // 期间状态变化,不确定操作是否成功
		//						return persistCore.EPersistErrorUnknownError
		//					}
		//				case EPersistLoadStatePrepareUnloading: // 准备导出, 立即取消导出
		//					return //persistCore.EPersistErrorAlreadyUnload
		//				case EPersistLoadStateUnloading: // 正在导出, 导入失败
		//					return //persistCore.EPersistErrorUnloading
		//				default:
		//					return persistCore.EPersistErrorUnknownError
		//				}
		//			} else {
		//				return //persistCore.EPersistErrorNotInMemory
		//			}
		//		} else {
		//			return persistCore.EPersistErrorAlreadyLoadAll
		//		}
		//	{{else}}
		//		return
		//	{{end}}
		//}
	{{end}}
{{else}}
	{{if $.ArgsInfo.Save}}
		// Unload 按照key导出数据, 必须存在unload key的索引. 调用Unload后,不允许再修改相关的数据(必须先导入才能修改数据).
		func (m *PersistManager) Unload(UnloadKey UnloadKeyType) (err error) {
			{{if $.ArgsInfo.Unload}}
				// return 不存在unload key时直接返回
				// LoadAll后不能unload
				if atomic.LoadInt32(&m.loadAll) == EPersistTableStateDisk {
					if value, ok := m.loadUnloadKeyMap.Load(UnloadKey); ok {
						state := value
						switch atomic.LoadInt32(state) {
						case EPersistLoadStateDisk: // 未导入
							return //persistCore.EPersistErrorNotInMemory
						case EPersistLoadStateLoading: // 正在导入
							return persistCore.EPersistErrorLoading
						case EPersistLoadStateMemory: // 导入完成, 开始导出吧
							if atomic.CompareAndSwapInt32(state, EPersistLoadStateMemory, EPersistLoadStatePrepareUnloading) {
								m.syncChan <- &PersistSync{Data: &Persist{Uid: Uid}, Op: EPersistOpUnload}
								return
							} else { // 期间状态变化,不确定操作是否成功
								return persistCore.EPersistErrorUnknownError
							}
						case EPersistLoadStatePrepareUnloading: // 准备导出, 立即取消导出
							return //persistCore.EPersistErrorAlreadyUnload
						case EPersistLoadStateUnloading: // 正在导出, 导入失败
							return //persistCore.EPersistErrorUnloading
						default:
							return persistCore.EPersistErrorUnknownError
						}
					} else {
						return //persistCore.EPersistErrorNotInMemory
					}
				} else {
					return persistCore.EPersistErrorAlreadyLoadAll
				}
			{{else}}
				return
			{{end}}
		}
	{{end}}
{{end}}
{{*/}}
{{if .ArgsInfo.OptimizeFlagUsePoolAndDisableDeleteUnload}}
	{{if $.ArgsInfo.Save}}
	{{if .HashIndexUnload}}
		// EOptimizeFlagUsePoolAndDisableDeleteUnload 优化下不支持导出
		// Unload 按照key导出数据, 必须存在unload key的索引. 调用Unload后,不允许再修改相关的数据(必须先导入才能修改数据).
		//func (m *{{.DataName}}Manager) Unload({{index .HashIndexUnload.Cols 0}} {{index .HashIndexUnload.Types 0}}) (err error) {
		//	{{if $.ArgsInfo.Unload}}

		//		// LoadAll后不能unload
		//		if atomic.LoadInt32(&m.loadAll) == E{{.DataName}}TableStateDisk {
		//			if value, ok := m.load{{index .HashIndexUnload.Cols 0}}Map.Load({{index .HashIndexUnload.Cols 0}}); ok {
		//				state := value

		//				switch atomic.LoadInt32(state) {
		//				case E{{.DataName}}LoadStateDisk: // 未导入
		//					return //persistCore.EPersistErrorNotInMemory
		//				case E{{.DataName}}LoadStateLoading: // 正在导入
		//					return persistCore.EPersistErrorLoading
		//				case E{{.DataName}}LoadStateMemory: // 导入完成, 开始导出吧
		//					if atomic.CompareAndSwapInt32(state, E{{.DataName}}LoadStateMemory, E{{.DataName}}LoadStatePrepareUnloading) {
		//						m.syncChan <- &{{.DataName}}Sync{Data: &{{.ArgsInfo.PersistPkgName}}.{{.DataName}}{ {{index .HashIndexUnload.Cols 0}}: {{index .HashIndexUnload.Cols 0}} }, Op: E{{.DataName}}OpUnload}
		//						return
		//					} else { // 期间状态变化,不确定操作是否成功
		//						return persistCore.EPersistErrorUnknownError
		//					}
		//				case E{{.DataName}}LoadStatePrepareUnloading: // 准备导出, 立即取消导出
		//					return //persistCore.EPersistErrorAlreadyUnload
		//				case E{{.DataName}}LoadStateUnloading: // 正在导出, 导入失败
		//					return //persistCore.EPersistErrorUnloading
		//				default:
		//					return persistCore.EPersistErrorUnknownError
		//				}
		//			} else {
		//				return //persistCore.EPersistErrorNotInMemory
		//			}
		//		} else {
		//			return persistCore.EPersistErrorAlreadyLoadAll
		//		}
		//	{{else}}
		//		return
		//	{{end}}
		//}
	{{end}}
	{{end}}
{{else}}
	{{if $.ArgsInfo.Save}}
	{{if .HashIndexUnload}}
		// Unload 按照key导出数据, 必须存在unload key的索引. 调用Unload后,不允许再修改相关的数据(必须先导入才能修改数据).
		func (m *{{.DataName}}Manager) Unload({{index .HashIndexUnload.Cols 0}} {{index .HashIndexUnload.Types 0}}) (err error) {
			{{if $.ArgsInfo.Unload}}

				// LoadAll后不能unload
				if atomic.LoadInt32(&m.loadAll) == E{{.DataName}}TableStateDisk {
					if value, ok := m.load{{index .HashIndexUnload.Cols 0}}Map.Load({{index .HashIndexUnload.Cols 0}}); ok {
						state := value

						switch atomic.LoadInt32(state) {
						case E{{.DataName}}LoadStateDisk: // 未导入
							return //persistCore.EPersistErrorNotInMemory
						case E{{.DataName}}LoadStateLoading: // 正在导入
							return persistCore.EPersistErrorLoading
						case E{{.DataName}}LoadStateMemory: // 导入完成, 开始导出吧
							if atomic.CompareAndSwapInt32(state, E{{.DataName}}LoadStateMemory, E{{.DataName}}LoadStatePrepareUnloading) {
								m.syncChan <- &{{.DataName}}Sync{Data: &{{.ArgsInfo.PersistPkgName}}.{{.DataName}}{ {{index .HashIndexUnload.Cols 0}}: {{index .HashIndexUnload.Cols 0}} }, Op: E{{.DataName}}OpUnload}
								return
							} else { // 期间状态变化,不确定操作是否成功
								return persistCore.EPersistErrorUnknownError
							}
						case E{{.DataName}}LoadStatePrepareUnloading: // 准备导出, 立即取消导出
							return //persistCore.EPersistErrorAlreadyUnload
						case E{{.DataName}}LoadStateUnloading: // 正在导出, 导入失败
							return //persistCore.EPersistErrorUnloading
						default:
							return persistCore.EPersistErrorUnknownError
						}
					} else {
						return //persistCore.EPersistErrorNotInMemory
					}
				} else {
					return persistCore.EPersistErrorAlreadyLoadAll
				}
			{{else}}
				return
			{{end}}
		}
	{{end}}
	{{end}}
{{end}}



{{/* unload }}
{{if .ArgsInfo.OptimizeFlagUsePoolAndDisableDeleteUnload}}
	{{if $.ArgsInfo.Save}}
		// EOptimizeFlagUsePoolAndDisableDeleteUnload 优化下不支持导出
		// unload (非线程安全) 按照key导出数据, 必须存在unload key的索引. 调用Unload后,不允许再修改相关的数据(必须先导入才能修改数据).
		//func (m *PersistManager) unload(UnloadKey UnloadKeyType) {
		//	{{if .ArgsInfo.OptimizeFlagIndexMutex}}
		//		{{range $i, $indexItem := .HashIndexList}}
		//			m.hash{{$indexItem.Keys}}Mutex.Lock()
		//			defer m.hash{{$indexItem.Keys}}Mutex.Unlock()
		//		{{end}}
		//	{{end}}
		//	// 不存在unload key 索引什么都不干
		//	// unload key unique = 0
		//	for _, cls := range m.GetPersistsByUnloadKey(UnloadKey) {
		//		m.removePersist(cls)
		//	}
		//	// unload key unique = 1
		//	//cls := m.GetPersistByUnloadKey(UnloadKey)
		//	//if cls != nil {
		//	//	m.removePersist(cls)
		//	//}
		//}
	{{end}}
{{else}}
	{{if $.ArgsInfo.Save}}
		// unload (非线程安全) 按照key导出数据, 必须存在unload key的索引. 调用Unload后,不允许再修改相关的数据(必须先导入才能修改数据).
		func (m *PersistManager) unload(UnloadKey UnloadKeyType) {
			{{if .ArgsInfo.OptimizeFlagIndexMutex}}
				{{range $i, $indexItem := .HashIndexList}}
					m.hash{{$indexItem.Keys}}Mutex.Lock()
					defer m.hash{{$indexItem.Keys}}Mutex.Unlock()
				{{end}}
			{{end}}
			// 不存在unload key 索引什么都不干
			// unload key unique = 0
			for _, cls := range m.GetPersistsByUnloadKey(UnloadKey) {
				m.removePersist(cls)
			}
			// unload key unique = 1
			//cls := m.GetPersistByUnloadKey(UnloadKey)
			//if cls != nil {
			//	m.removePersist(cls)
			//}
		}
	{{end}}
{{end}}
{{*/}}
{{if .ArgsInfo.OptimizeFlagUsePoolAndDisableDeleteUnload}}
	{{if $.ArgsInfo.Save}}
	{{if .HashIndexUnload}}
		// EOptimizeFlagUsePoolAndDisableDeleteUnload 优化下不支持导出
		// unload (非线程安全) 按照key导出数据, 必须存在unload key的索引. 调用Unload后,不允许再修改相关的数据(必须先导入才能修改数据).
		//func (m *{{.DataName}}Manager) unload({{index .HashIndexUnload.Cols 0}} {{index .HashIndexUnload.Types 0}}) {
		//	{{if .ArgsInfo.OptimizeFlagIndexMutex}}
		//		{{range $i, $indexItem := .HashIndexList}}
		//			m.hash{{$indexItem.Keys}}Mutex.Lock()
		//			defer m.hash{{$indexItem.Keys}}Mutex.Unlock()
		//		{{end}}
		//	{{end}}
		//	{{if .HashIndexUnload.Unique}}
		//		cls := m.Get{{.DataName}}By{{index .HashIndexUnload.Cols 0}}({{index .HashIndexUnload.Cols 0}})
		//		if cls != nil {
		//			m.remove{{.DataName}}(cls)
		//		}
		//	{{else}}
		//		for _, cls := range m.Get{{.DataName}}sBy{{index .HashIndexUnload.Cols 0}}({{index .HashIndexUnload.Cols 0}}) {
		//			m.remove{{.DataName}}(cls)
		//		}
		//	{{end}}
		//}
	{{end}}
	{{end}}
{{else}}
	{{if $.ArgsInfo.Save}}
	{{if .HashIndexUnload}}
		// unload (非线程安全) 按照key导出数据, 必须存在unload key的索引. 调用Unload后,不允许再修改相关的数据(必须先导入才能修改数据).
		func (m *{{.DataName}}Manager) unload({{index .HashIndexUnload.Cols 0}} {{index .HashIndexUnload.Types 0}}) {
			{{if .ArgsInfo.OptimizeFlagIndexMutex}}
				{{range $i, $indexItem := .HashIndexList}}
					m.hash{{$indexItem.Keys}}Mutex.Lock()
					defer m.hash{{$indexItem.Keys}}Mutex.Unlock()
				{{end}}
			{{end}}
			{{if .HashIndexUnload.Unique}}
				cls := m.Get{{.DataName}}By{{index .HashIndexUnload.Cols 0}}({{index .HashIndexUnload.Cols 0}})
				if cls != nil {
					m.remove{{.DataName}}(cls)
				}
			{{else}}
				for _, cls := range m.Get{{.DataName}}sBy{{index .HashIndexUnload.Cols 0}}({{index .HashIndexUnload.Cols 0}}) {
					m.remove{{.DataName}}(cls)
				}
			{{end}}
		}
	{{end}}
	{{end}}
{{end}}







{{/* init global manage }}
var GPersistManager *PersistManager
// init 注册管理类
func init() {
	if GetDB == nil {
		log.Println(persistCore.EPersistErrorEngineNil)
		persistCore.RegisterPersistLazy("Persist", GPersistManager)
		return
	}
	engine := GetDB()
	if engine == nil {
		log.Println(persistCore.EPersistErrorEngineNil)
		return
	}
	GPersistManager = NewPersistManager(engine)
{{if $.ArgsInfo.Save}}
	Register("Persist", GPersistManager)
	// go GPersistManager.Collect()
	//for idx, name := range PersistStructFiledMap {
	//	PersistDBFiledMap[idx] = engine.GetColumnMapper().Obj2Table(name)
	//}
{{end}}
}
{{*/}}
var G{{.DataName}}Manager *{{.DataName}}Manager
// init 注册管理类
func init() {
{{if $.ArgsInfo.Save}}
	if GetDB == nil {
		log.Println(persistCore.EPersistErrorEngineNil)
		persistCore.RegisterPersistLazy("{{.DataName}}", G{{.DataName}}Manager)
		return
	}
	engine := GetDB()
	if engine == nil {
		log.Println(persistCore.EPersistErrorEngineNil)
		return
	}
	G{{.DataName}}Manager = New{{.DataName}}Manager(engine)
	Register("{{.DataName}}", G{{.DataName}}Manager)
	// go G{{.DataName}}Manager.Collect()

	//for idx, name := range {{.DataName}}StructFiledMap {
	//	{{.DataName}}DBFiledMap[idx] = engine.GetColumnMapper().Obj2Table(name)
	//}
{{else}}
	G{{.DataName}}Manager = New{{.DataName}}Manager(nil)
{{end}}
}


{{/* LazyInit }}
// LazyInit 惰性创建注册初始化
func (m *PersistManager) LazyInit() (err error) {
	if GetDB == nil {
		err = errors.New("GetDB is nil")
		return
	}
	engine := GetDB()
	if engine == nil {
		err = errors.New("engine is nil")
		return
	}
	GPersistManager = NewPersistManager(engine)
	Register("Persist", GPersistManager)
	return
}
{{*/}}
// LazyInit 惰性创建注册初始化
func (m *{{.DataName}}Manager) LazyInit() (err error) {
{{if $.ArgsInfo.Save}}
	if GetDB == nil {
		err = errors.New("GetDB is nil")
		return
	}
	engine := GetDB()
	if engine == nil {
		err = errors.New("engine is nil")
		return
	}
	G{{.DataName}}Manager = New{{.DataName}}Manager(engine)
	Register("{{.DataName}}", G{{.DataName}}Manager)
{{end}}
	return
}



{{/* noneFunc }}
// noneFunc 仅用于处理依赖包goimport
func (m *PersistManager) noneFunc() {
	math.Abs(1.0)
	_ = jsoniter.ConfigCompatibleWithStandardLibrary
	_ = json.Marshal
	_ = sync.Mutex{}
	_ = reflect.Value{}
	_ = time.Now()
	_ = sentry.Client{}
	_ = strings.Builder{}
	log.Println("none")
}
{{*/}}
// noneFunc 惰性创建注册初始化
func (m *{{.DataName}}Manager) noneFunc() {
	math.Abs(1.0)
	_ = jsoniter.ConfigCompatibleWithStandardLibrary
	_ = json.Marshal
	_ = sync.Mutex{}
	_ = reflect.Value{}
	_ = time.Now()
	_ = sentry.Client{}
	_ = strings.Builder{}
	log.Println("none")
}





{{/* NeedSeparate}}
{{if $.ArgsInfo.NeedSeparate}}
func NewInit() {
	
}
{{end}}
{{*/}}
{{if $.ArgsInfo.NeedSeparate}}
// NewInit{{.DataName}} 分库切换 new persist
func NewInit{{.DataName}}() {
	engine := GetDB()
	if engine == nil {
		panic(persistCore.EPersistErrorEngineNil)
	}
	G{{.DataName}}Manager = New{{.DataName}}Manager(engine)
    ChangeRegisterPersist("{{.DataName}}", G{{.DataName}}Manager)
	// Register("{{.DataName}}", G{{.DataName}}Manager)
	go G{{.DataName}}Manager.Collect()
}
{{end}}



{{/* SaveDB }}
{{if $.ArgsInfo.Save}}
// SaveDB xorm写数据库
func (m *PersistManager) SaveDB(session *xorm.Session, persistSync *PersistSync) (err error) {
	defer func() {
		if r := recover(); r != nil {
			log.Println("recovered in ", r)
			log.Println("stack: ", string(debug.Stack()))
			if err == nil {
				err = errors.New("unknown error")
			}
		}
	}()
	switch persistSync.Op {
	case EPersistOpInsert:
		_, err = session.Insert(persistSync.Data)
		if err != nil {
			log.Println("insert error ", err, "[sql error Persist]", m.PersistSyncToString(persistSync))
			return
		}
	case EPersistOpUpdate:
		cls := persistSync.Data
		bitSet := persistSync.BitSet
		if bitSet.IsSetAll() {
			_, err = session.ID(core.NewPK(cls.Uid, cls.Id)).AllCols().Update(cls)
			if err != nil {
				log.Println("update error ", err, "[sql error Persist]", m.PersistSyncToString(persistSync))
				return
			}
		} else {
			var nameList []string
			for idx, name := range PersistDBFiledMap {
				if bitSet.Get(PersistFieldIndex(idx)) {
					nameList = append(nameList, name)
				}
			}
			if nameList != nil {
				_, err = session.ID(core.NewPK(cls.Uid, cls.Id)).Cols(nameList...).Update(cls)
				if err != nil {
					log.Println("update error ", err, "[sql error Persist]", m.PersistSyncToString(persistSync))
					return
				}
			} else {
				_, err = session.ID(core.NewPK(cls.Uid, cls.Id)).AllCols().Update(cls)
				if err != nil {
					log.Println("update error ", err, "[sql error Persist]", m.PersistSyncToString(persistSync))
					return
				}
			}
		}
	case EPersistOpDelete:
		cls := persistSync.Data
		_, err = session.ID(core.NewPK(cls.Uid, cls.Id, )).Delete(gPersistNil)
		if err != nil {
			log.Println("delete error ", err, "[sql error Persist]", m.PersistSyncToString(persistSync))
			return
		}
	case EPersistOpUnload:
		cls := persistSync.Data
		Uid := cls.Uid
		if value, ok := m.loadUidMap.Load(Uid); ok {
			state := value
			// 准备导出,  不中断的清理玩家数据
			// warning 导出后又修改, 不保证数据一致性
			if atomic.CompareAndSwapInt32(state, EPersistLoadStatePrepareUnloading, EPersistLoadStateUnloading) {
				m.unload(Uid)
				m.loadUidMap.Delete(Uid)
				atomic.StoreInt32(state, EPersistLoadStateDisk)
			} else {
				// 0:导出  1:导入开始  2:导入完成  4:正在导出  不确定状态
				// 以上状态跳过吧
			}
		} else {
			// 不存在的玩家,跳过吧
		}
	}
	return
}
{{end}}

{{*/}}
{{if $.ArgsInfo.Save}}
	// SaveDB xorm写数据库
	func (m *{{.DataName}}Manager) SaveDB(session *xorm.Session, persistSync *{{.DataName}}Sync) (err error) {
		defer func() {
			if r := recover(); r != nil {
				log.Println("recovered in ", r)
				log.Println("stack: ", string(debug.Stack()))
				if err == nil {
					err = errors.New("unknown error")
				}
			}
		}()
		switch persistSync.Op {
		case E{{.DataName}}OpInsert:
            {{if ne $.ArgsInfo.SwitchTable ""}}
			_, err = session.Table(Get{{.DataName}}TableName()).Insert(persistSync.Data)
			{{else}}
			_, err = session.Insert(persistSync.Data)
            {{end}}
			if err != nil {
				log.Println("insert error ", err, "[sql error {{.DataName}}]", m.PersistSyncToString(persistSync))
				return
			}
		{{if .HashIndexPk}}
			case E{{.DataName}}OpUpdate:
				cls := persistSync.Data
				bitSet := persistSync.BitSet
				if bitSet.IsSetAll() {
					_, err = session.ID(core.NewPK({{.HashIndexPk.ClsPointKeys}})).AllCols().Update(cls)
					if err != nil {
						log.Println("update error ", err, "[sql error {{.DataName}}]", m.PersistSyncToString(persistSync))
						return
					}
				} else {
					var nameList []string
					for idx, name := range {{.DataName}}DBFiledMap {
						if bitSet.Get({{.DataName}}FieldIndex(idx)) {
							nameList = append(nameList, name)
						}
					}
					if nameList != nil {
						_, err = session.ID(core.NewPK({{.HashIndexPk.ClsPointKeys}})).Cols(nameList...).Update(cls)
						if err != nil {
							log.Println("update error ", err, "[sql error {{.DataName}}]", m.PersistSyncToString(persistSync))
							return
						}
					} else {
						_, err = session.ID(core.NewPK({{.HashIndexPk.ClsPointKeys}})).AllCols().Update(cls)
						if err != nil {
							log.Println("update error ", err, "[sql error {{.DataName}}]", m.PersistSyncToString(persistSync))
							return
						}
					}
				}

			case E{{.DataName}}OpDelete:
				cls := persistSync.Data
				_, err = session.ID(core.NewPK({{.HashIndexPk.ClsPointKeys}})).Delete(g{{.DataName}}Nil)
				if err != nil {
					log.Println("delete error ", err, "[sql error {{.DataName}}]", m.PersistSyncToString(persistSync))
					return
				}
			{{if .HashIndexUnload}}
				case E{{.DataName}}OpUnload:
					cls := persistSync.Data
					{{index .HashIndexUnload.Cols 0}} := cls.{{index .HashIndexUnload.Cols 0}}
					if value, ok := m.load{{index .HashIndexUnload.Cols 0}}Map.Load({{index .HashIndexUnload.Cols 0}}); ok {
						state := value
						// 准备导出,  不中断的清理玩家数据
						// warning 导出后又修改, 不保证数据一致性
						if atomic.CompareAndSwapInt32(state, E{{.DataName}}LoadStatePrepareUnloading, E{{.DataName}}LoadStateUnloading) {
							m.unload({{index .HashIndexUnload.Cols 0}})
							m.load{{index .HashIndexUnload.Cols 0}}Map.Delete({{index .HashIndexUnload.Cols 0}})
							atomic.StoreInt32(state, E{{.DataName}}LoadStateDisk)
						} else {
							// 0:导出  1:导入开始  2:导入完成  4:正在导出  不确定状态
							// 以上状态跳过吧
						}
					} else {
						// 不存在的玩家,跳过吧
					}
			{{end}}
		{{else}}

		{{end}}
		}
		return
	}
{{end}}


{{/* DataToFailQueue }}
{{if $.ArgsInfo.Save}}
// DataToFailQueue 未写入成功数据, 添加到失败队列
func (m *PersistManager) DataToFailQueue() {
	var persistSync *PersistSync
	// 一旦失败标记所有的数据都是失败, 不允许导出

	m.FailQueue = append(m.FailQueue, m.InsertQueue...)
	m.InsertQueue = m.InsertQueue[0:0]

	for i := 0; i < len(*m.syncQueue); i++ {
		persistSync = (*m.syncQueue)[i]
		switch persistSync.Op {
		case EPersistOpInsert, EPersistOpUpdate, EPersistOpDelete:
			m.FailQueue = append(m.FailQueue, persistSync)
		case EPersistOpUnload:
			// 导出状态还原
			cls := persistSync.Data
			Uid := cls.Uid
			if value, ok := m.loadUidMap.Load(Uid); ok {
				state := value
				// 导出失败状态回退
				if atomic.CompareAndSwapInt32(state, EPersistLoadStatePrepareUnloading, EPersistLoadStateMemory) {
				} else {
				}
			}
		default:
		}
	}
	*m.syncQueue = (*m.syncQueue)[0:0]
}
{{end}}
{{*/}}
{{if $.ArgsInfo.Save}}
	// DataToFailQueue 未写入成功数据, 添加到失败队列
	func (m *{{.DataName}}Manager) DataToFailQueue() {
		var persistSync *{{.DataName}}Sync

		// 一旦失败标记所有的数据都是失败, 不允许导出
		{{if .ArgsInfo.OptimizeFlagSQLInsertMerge}}
			m.FailQueue = append(m.FailQueue, m.InsertQueue...)
			m.InsertQueue = m.InsertQueue[0:0]
		{{end}}

		for i := 0; i < len(*m.syncQueue); i++ {
			persistSync = (*m.syncQueue)[i]
			switch persistSync.Op {
			case E{{.DataName}}OpInsert, E{{.DataName}}OpUpdate, E{{.DataName}}OpDelete:
				m.FailQueue = append(m.FailQueue, persistSync)
			{{if .HashIndexUnload}}
				case E{{.DataName}}OpUnload:
					// 导出状态还原
					cls := persistSync.Data
					{{index .HashIndexUnload.Cols 0}} := cls.{{index .HashIndexUnload.Cols 0}}
					if value, ok := m.load{{index .HashIndexUnload.Cols 0}}Map.Load({{index .HashIndexUnload.Cols 0}}); ok {
						state := value
						// 导出失败状态回退
						if atomic.CompareAndSwapInt32(state, E{{.DataName}}LoadStatePrepareUnloading, E{{.DataName}}LoadStateMemory) {
						} else {
						}
					}
			{{end}}

			default:
			}
		}
		*m.syncQueue = (*m.syncQueue)[0:0]
	}
{{end}}


{{/* SaveFile }}
{{if $.ArgsInfo.Save}}
// LoadFile 文件读取写回失败数据
func (m *PersistManager) LoadFile() error {
	bombExist := util.Exists("./G_MyProjectGo_ultraman_src_menet_persist_tests_model/Persist.bomb")
	tmpExist := util.Exists("./G_MyProjectGo_ultraman_src_menet_persist_tests_model/Persist.tmp")

	if tmpExist {
		return persistCore.EPersistErrorTempFileExist
	}

	if bombExist {
		data, err := ioutil.ReadFile("./G_MyProjectGo_ultraman_src_menet_persist_tests_model/Persist.bomb")
		if err != nil {
			return err
		}
		pos := bytes.IndexByte(data, byte(' '))
		if pos == -1 {
			return persistCore.EPersistErrorInvalidBombFile
		}
		persistData := data[pos+1:]
		err = m.UnmarshalFailQueue(persistData, &m.FailQueue)
		if err != nil {
			return err
		}

		session := m.engine.NewSession()
		defer session.Close()

		var persistSync *PersistSync

		for i := range m.FailQueue {
			persistSync = m.FailQueue[i]
			err = m.SaveDB(session, persistSync)
			if err != nil {
				m.FailQueue = m.FailQueue[i:]
				m.SaveFile()
				return err
			}
		}
		m.FailQueue = m.FailQueue[0:0]
		m.RemoveFile()

	}
	return nil
}

{{end}}
{{*/}}
{{if $.ArgsInfo.Save}}
	// LoadFile 文件读取写回失败数据
	func (m *{{.DataName}}Manager) LoadFile() error {
		bombExist := util.Exists("{{.ArgsInfo.BombDir}}/{{.DataName}}.bomb")
		tmpExist := util.Exists("{{.ArgsInfo.BombDir}}/{{.DataName}}.tmp")

		if tmpExist {
			return persistCore.EPersistErrorTempFileExist
		}

		if bombExist {
			data, err := ioutil.ReadFile("{{.ArgsInfo.BombDir}}/{{.DataName}}.bomb")
			if err != nil {
				return err
			}
			pos := bytes.IndexByte(data, byte(' '))
			if pos == -1 {
				return persistCore.EPersistErrorInvalidBombFile
			}
			persistData := data[pos+1:]
			err = m.UnmarshalFailQueue(persistData, &m.FailQueue)
			if err != nil {
				return err
			}

			session := m.engine.NewSession()
			defer session.Close()

			var persistSync *{{.DataName}}Sync

			for i := range m.FailQueue {
				persistSync = m.FailQueue[i]
				err = m.SaveDB(session, persistSync)
				if err != nil {
					m.FailQueue = m.FailQueue[i:]
					m.SaveFile()
					return err
				}
			}
			m.FailQueue = m.FailQueue[0:0]
			m.RemoveFile()

		}
		return nil
	}
{{end}}


{{/* SaveFile }}
{{if $.ArgsInfo.Save}}
// SaveFile 写回失败,记录数据,写文件,等待下次写回
func (m *PersistManager) SaveFile() {

	m.DataToFailQueue()

	data, err := m.MarshalFailQueue(m.FailQueue)
	if err != nil {
		log.Println("SaveFile marshal error ", err)
	}
	_ = os.Mkdir("./G_MyProjectGo_demo_src_menet_persist_tests_model", 0770)
	err = ioutil.WriteFile("./???Data???/_Persist.tmp", append([]byte("Persist "), data...), 0660)
	if err != nil {
		log.Println("SaveFile write temp file error ", err)
	}
	err = ioutil.WriteFile("./???Data???/_Persist.bomb", append([]byte("Persist "), data...), 0660)
	if err != nil {
		log.Println("SaveFile write bomb file error ", err)
	}
	_ = os.Remove("./G_MyProjectGo_demo_src_menet_persist_tests_model/Persist.tmp")
}
{{end}}
{{*/}}
{{if $.ArgsInfo.Save}}
	// SaveFile 写回失败,记录数据,写文件,等待下次写回
	func (m *{{.DataName}}Manager) SaveFile() {

		m.DataToFailQueue()

		data, err := m.MarshalFailQueue(m.FailQueue)
		if err != nil {
			log.Println("SaveFile marshal error ", err)
		}
		_ = os.Mkdir("{{.ArgsInfo.BombDir}}", 0770)
		err = ioutil.WriteFile("{{.ArgsInfo.BombDir}}/{{.DataName}}.tmp", append([]byte("{{.DataName}} "), data...), 0660)
		if err != nil {
			log.Println("SaveFile write temp file error ", err)
		}
		err = ioutil.WriteFile("{{.ArgsInfo.BombDir}}/{{.DataName}}.bomb", append([]byte("{{.DataName}} "), data...), 0660)
		if err != nil {
			log.Println("SaveFile write bomb file error ", err)
		}
		_ = os.Remove("{{.ArgsInfo.BombDir}}/{{.DataName}}.tmp")
	}
{{end}}


{{/* RemoveFile }}
{{if $.ArgsInfo.Save}}
// RemoveFile 删除写回失败文件
func (m *PersistManager) RemoveFile() {
	_ = os.Remove("./G_MyProjectGo_demo_src_menet_persist_tests_model/Persist.bomb")
	_ = os.Remove("./G_MyProjectGo_demo_src_menet_persist_tests_model/Persist.tmp")
	_ = os.Remove("./G_MyProjectGo_demo_src_menet_persist_tests_model/")
}
{{end}}
{{*/}}
{{if $.ArgsInfo.Save}}
	// RemoveFile 删除写回失败文件
	func (m *{{.DataName}}Manager) RemoveFile() {
		_ = os.Remove("{{.ArgsInfo.BombDir}}/{{.DataName}}.tmp")
		_ = os.Remove("{{.ArgsInfo.BombDir}}/{{.DataName}}.bomb")
		_ = os.Remove("{{.ArgsInfo.BombDir}}")
	}
{{else}}
	// RemoveFile 删除写回失败文件
	func (m *{{.DataName}}Manager) RemoveFile() {
	}
{{end}}

{{/* RecoverBomb }}
{{if $.ArgsInfo.Save}}
// RecoverBomb bomb数据写入数据库
func (m *PersistManager) RecoverBomb(bomb []byte) (err error) {
	var persistSync *PersistSync
	var failQueue []*PersistSync
	session := m.engine.NewSession()
	defer session.Close()
	err = m.UnmarshalFailQueue(bomb, &failQueue)
	if err != nil {
		return
	}
	var i int
	for i = range failQueue {
		persistSync = failQueue[i]
		err = m.SaveDB(session, persistSync)
		if err != nil {
			break
		}
	}
	if len(failQueue)-1 > i {
		data, _ := m.MarshalFailQueue(failQueue[i:])
		_, _ = os.Stdout.Write([]byte("Persist "))
		_, _ = os.Stdout.Write(data)
	}
	return
}
{{end}}
{{*/}}
{{if $.ArgsInfo.Save}}
	// RecoverBomb bomb数据写入数据库
	func (m *{{.DataName}}Manager) RecoverBomb(bomb []byte) (err error) {
		var persistSync *{{.DataName}}Sync
		var failQueue []*{{.DataName}}Sync
		session := m.engine.NewSession()
		defer session.Close()
		err = m.UnmarshalFailQueue(bomb, &failQueue)
		if err != nil {
			return
		}
		var i int
		for i = range failQueue {
			persistSync = failQueue[i]
			err = m.SaveDB(session, persistSync)
			if err != nil {
				break
			}
		}
		if len(failQueue)-1 > i {
			data, _ := m.MarshalFailQueue(failQueue[i:])
			_, _ = os.Stdout.Write([]byte("{{.DataName}} "))
			_, _ = os.Stdout.Write(data)
		}
		return
	}
{{else}}
	// RecoverBomb bomb数据写入数据库
	func (m *{{.DataName}}Manager) RecoverBomb(bomb []byte) (err error) {
		return
	}
{{end}}


{{/* RecoverTrace }}
{{if $.ArgsInfo.Save}}
// RecoverTrace trace数据写入数据库
func (m *PersistManager) RecoverTrace(trace [][]byte) (err error) {
	var persistSync *PersistSync
	var traceQueue []*PersistSync
	var insertQueue []*PersistSync

	for i := 0; i < len(trace); i++ {
		persistSync = m.StringToPersistSync(string(trace[i]))
		if persistSync.Op == EPersistOpInsert {
			insertQueue = append(insertQueue, persistSync)
		} else {
			traceQueue = append(traceQueue, persistSync)
		}
	}

	insertQueue2, otherQueue := m.MergeQueue(traceQueue, false)
	for _, insertItem := range insertQueue2 {
		insertQueue = append(insertQueue, insertItem)
	}

	session := m.engine.NewSession()
	defer session.Close()

	var i int
	for i = range insertQueue {
		persistSync = insertQueue[i]
		_ = m.SaveDB(session, persistSync)
	}
	for i = range otherQueue {
		persistSync = otherQueue[i]
		_ = m.SaveDB(session, persistSync)
	}
	return
}
{{end}}
{{*/}}

{{if $.ArgsInfo.Save}}
	// RecoverTrace trace数据写入数据库
	func (m *{{.DataName}}Manager) RecoverTrace(trace [][]byte) (err error) {
		var persistSync *{{.DataName}}Sync
		var traceQueue []*{{.DataName}}Sync
		var insertQueue []*{{.DataName}}Sync

		for i := 0; i < len(trace); i++ {
			persistSync = m.StringToPersistSync(string(trace[i]))
			if persistSync.Op == E{{.DataName}}OpInsert {
				insertQueue = append(insertQueue, persistSync)
			} else {
				traceQueue = append(traceQueue, persistSync)
			}
		}

		insertQueue2, otherQueue := m.MergeQueue(traceQueue, false)
		for _, insertItem := range insertQueue2 {
			insertQueue = append(insertQueue, insertItem)
		}

		session := m.engine.NewSession()
		defer session.Close()

		var i int
		for i = range insertQueue {
			persistSync = insertQueue[i]
			_ = m.SaveDB(session, persistSync)
		}
		for i = range otherQueue {
			persistSync = otherQueue[i]
			_ = m.SaveDB(session, persistSync)
		}
		return
	}
{{else}}
	// RecoverTrace trace数据写入数据库
	func (m *{{.DataName}}Manager) RecoverTrace(trace [][]byte) (err error) {
		return
	}
{{end}}



{{/* merge queue }}
{{if $.ArgsInfo.Save}}
// MergeQueue 内存中合并操作
func (m *PersistManager) MergeQueue(q []*PersistSync, copyAll bool) (insertQueue, otherQueue []*PersistSync) {
	var currentPersistSync *PersistSync
	var oldPersistSync *PersistSync
	var ok bool

	var unloadList []*PersistSync

	// 合并可能失败, persistSyncMap必须创建副本
	persistSyncMap := map[PersistUidId]*PersistSync{}

	//unload 按照顺序强制移到最后
	//insert update delete 按照主键合并
	lenSyncQueue := len(q)
	fail := false

LabelForSyncQueue:
	for i := 0; i < lenSyncQueue; i++ {
		currentPersistSync = q[i]
		pk := PersistUidId{
			Uid: currentPersistSync.Data.Uid,
			Id:  currentPersistSync.Data.Id,
		}
		// 导出特殊处理
		if currentPersistSync.Op == EPersistOpUnload {
			unloadList = append(unloadList, currentPersistSync)
			continue
		}
		// 第一次出现直接拷贝
		if oldPersistSync, ok = persistSyncMap[pk]; !ok {
			persistSyncMap[pk] = &PersistSync{Data: currentPersistSync.Data, Op: currentPersistSync.Op, BitSet: currentPersistSync.BitSet}
			continue
		}

		switch oldPersistSync.Op {
		case EPersistOpInsert:
			switch currentPersistSync.Op {
			case EPersistOpInsert:
				fail = true
				break LabelForSyncQueue
			case EPersistOpUpdate:
				oldPersistSync.Op = EPersistOpInsert
				if copyAll {
					oldPersistSync.Data = currentPersistSync.Data
				} else {
					m.PersistToPersistByBitSet(oldPersistSync.Data, currentPersistSync.Data, currentPersistSync.BitSet)
				}
				oldPersistSync.BitSet.SetAll()
			case EPersistOpDelete:
				delete(persistSyncMap, pk)
			}
		case EPersistOpUpdate:
			switch currentPersistSync.Op {
			case EPersistOpInsert:
				fail = true
				break LabelForSyncQueue
			case EPersistOpUpdate:
				oldPersistSync.Op = EPersistOpUpdate
				if copyAll {
					oldPersistSync.Data = currentPersistSync.Data
				} else {
					m.PersistToPersistByBitSet(oldPersistSync.Data, currentPersistSync.Data, currentPersistSync.BitSet)
				}				
				oldPersistSync.BitSet.Merge(currentPersistSync.BitSet)
			case EPersistOpDelete:
				oldPersistSync.Op = EPersistOpDelete
				oldPersistSync.Data = currentPersistSync.Data
				oldPersistSync.BitSet.ClearAll()
			}
		case EPersistOpDelete:
			switch currentPersistSync.Op {
			case EPersistOpInsert:
				oldPersistSync.Op = EPersistOpUpdate
				oldPersistSync.Data = currentPersistSync.Data
				oldPersistSync.BitSet.SetAll()
			case EPersistOpUpdate:
				fail = true
				break LabelForSyncQueue
			case EPersistOpDelete:
				fail = true
				break LabelForSyncQueue
			}
		}
	}
	// 遇到错误取消合并
	if fail {
		otherQueue = q
		return
	}

	// 清空队列 该函数无副作用，需要外部自行清理

	{{if .ArgsInfo.OptimizeFlagSQLInsertMerge}}
		// 按照合并内容重建队列, 插入特殊处理
		for _, persistSync := range persistSyncMap {
			if persistSync.Op == EPersistOpInsert {
				insertQueue = append(insertQueue, persistSync)
			} else {
				otherQueue = append(otherQueue, persistSync)
			}
		}
	{{else}}
		// 按照合并内容重建队列
		for _, persistSync := range persistSyncMap {
			otherQueue = append(otherQueue, persistSync)
		}
	{{end}}
	for _, persistSync := range unloadList {
		otherQueue = append(otherQueue, persistSync)
	}

	return
}
{{end}}
{{*/}}
{{if $.ArgsInfo.Save}}
	// MergeQueue 内存中合并操作
	func (m *{{.DataName}}Manager) MergeQueue(q []*{{.DataName}}Sync, copyAll bool) (insertQueue, otherQueue []*{{.DataName}}Sync) {
		{{if .HashIndexPk}}
			var currentPersistSync *{{.DataName}}Sync
			var oldPersistSync *{{.DataName}}Sync
			var ok bool

			var unloadList []*{{.DataName}}Sync

			// 合并可能失败, persistSyncMap必须创建副本
			persistSyncMap := map[{{.DataName}}{{.HashIndexPk.Keys}}]*{{.DataName}}Sync{}

			//unload 按照顺序强制移到最后
			//insert update delete 按照主键合并
			lenSyncQueue := len(q)
			fail := false

		LabelForSyncQueue:
			for i := 0; i < lenSyncQueue; i++ {
				currentPersistSync = q[i]
				pk := {{.DataName}}{{.HashIndexPk.Keys}}{
					{{range $i, $col := .HashIndexPk.Cols}}
						{{$col}}: currentPersistSync.Data.{{$col}},
					{{end}}
				}
				// 导出特殊处理
				if currentPersistSync.Op == E{{.DataName}}OpUnload {
					unloadList = append(unloadList, currentPersistSync)
					continue
				}
				// 第一次出现直接拷贝
				if oldPersistSync, ok = persistSyncMap[pk]; !ok {
					persistSyncMap[pk] = &{{.DataName}}Sync{Data: currentPersistSync.Data, Op: currentPersistSync.Op, BitSet: currentPersistSync.BitSet}
					continue
				}

				switch oldPersistSync.Op {
				case E{{.DataName}}OpInsert:
					switch currentPersistSync.Op {
					case E{{.DataName}}OpInsert:
						fail = true
						break LabelForSyncQueue
					case E{{.DataName}}OpUpdate:
						oldPersistSync.Op = E{{.DataName}}OpInsert
						if copyAll {
							oldPersistSync.Data = currentPersistSync.Data
						} else {
							m.PersistToPersistByBitSet(oldPersistSync.Data, currentPersistSync.Data, currentPersistSync.BitSet)
						}
						oldPersistSync.BitSet.SetAll()
					case E{{.DataName}}OpDelete:
						delete(persistSyncMap, pk)
					}
				case E{{.DataName}}OpUpdate:
					switch currentPersistSync.Op {
					case E{{.DataName}}OpInsert:
						fail = true
						break LabelForSyncQueue
					case E{{.DataName}}OpUpdate:
						oldPersistSync.Op = E{{.DataName}}OpUpdate
						if copyAll {
							oldPersistSync.Data = currentPersistSync.Data
						} else {
							m.PersistToPersistByBitSet(oldPersistSync.Data, currentPersistSync.Data, currentPersistSync.BitSet)
						}
						oldPersistSync.BitSet.Merge(currentPersistSync.BitSet)
					case E{{.DataName}}OpDelete:
						oldPersistSync.Op = E{{.DataName}}OpDelete
						oldPersistSync.Data = currentPersistSync.Data
						oldPersistSync.BitSet.ClearAll()
					}
				case E{{.DataName}}OpDelete:
					switch currentPersistSync.Op {
					case E{{.DataName}}OpInsert:
						oldPersistSync.Op = E{{.DataName}}OpUpdate
						oldPersistSync.Data = currentPersistSync.Data
						oldPersistSync.BitSet.SetAll()
					case E{{.DataName}}OpUpdate:
						fail = true
						break LabelForSyncQueue
					case E{{.DataName}}OpDelete:
						fail = true
						break LabelForSyncQueue
					}
				}
			}
			// 遇到错误取消合并
			if fail {
				otherQueue = q
				return
			}

			// 清空队列 该函数无副作用，需要外部自行清理

			{{if .ArgsInfo.OptimizeFlagSQLInsertMerge}}
				// 按照合并内容重建队列, 插入特殊处理
				for _, persistSync := range persistSyncMap {
					if persistSync.Op == E{{.DataName}}OpInsert {
						insertQueue = append(insertQueue, persistSync)
					} else {
						otherQueue = append(otherQueue, persistSync)
					}
				}
			{{else}}
				// 按照合并内容重建队列
				for _, persistSync := range persistSyncMap {
					otherQueue = append(otherQueue, persistSync)
				}
			{{end}}

			for _, persistSync := range unloadList {
				otherQueue = append(otherQueue, persistSync)
			}
		{{else}}

			otherQueue = q

		{{end}}
		return
	}
{{end}}


{{/* async save }}
{{if $.ArgsInfo.Save}}
// Save 异步写回
func (m *PersistManager) Save() {
	var exit bool
	for {
		// 正常退出
		exit = m.AsyncSave()
		if exit {
			break
		}
	}
}


// AsyncSave 异步写回
func (m *PersistManager) AsyncSave() (exit bool) {
	var persistSync *PersistSync
	var err error
	var queueEmpty bool
	bTime := time.Now().UnixNano()
	defer func() {
		if r := recover(); r != nil {
			log.Println("recovered in ", r)
			log.Println("stack: ", string(debug.Stack()))
			if !queueEmpty {
				log.Println("save failed: incrementalSave")
			}
		} else {
			if !queueEmpty {
				if err == nil {
					log.Println("save success: incrementalSave")
				} else {
					log.Println("save failed: incrementalSave")
				}
			}
		}
		m.DataToFailQueue()
		m.lastWriteBackTime = time.Duration(time.Now().UnixNano() - bTime)
		m.syncEnd <- true
	}()
	
	needCollect := <-m.syncBegin
	if len(*m.syncQueue) == 0 {
		queueEmpty = true
		if needCollect {
			time.Sleep(time.Millisecond * {{$.ArgsInfo.QueueEmptySleepTime}})
		} else {
			exit = true
		}
		return
	}
	session := m.engine.NewSession()
	defer session.Close()

	log.Println("begin incrementalSave", bTime)

	if len(m.FailQueue) > 0 {
		tmpQueue := make([]*PersistSync, len(m.FailQueue)+len(*m.syncQueue))
		copy(tmpQueue, m.FailQueue)
		copy(tmpQueue[len(m.FailQueue):], *m.syncQueue)
		insertQueue, otherQueue := m.MergeQueue(tmpQueue, true)
		m.syncQueue = &otherQueue
		m.InsertQueue = insertQueue
		m.FailQueue = m.FailQueue[0:0]
	} else {
		insertQueue, otherQueue := m.MergeQueue(*m.syncQueue, true)
		m.syncQueue = &otherQueue
		m.InsertQueue = insertQueue
	}

{{if .ArgsInfo.OptimizeFlagSQLInsertMerge}}
	multiInsertFn := func() bool {
		var err error
		defer func() {
			if r := recover(); r != nil {
				_ = session.Rollback()
			} else {
				if err == nil {
					m.InsertQueue = m.InsertQueue[0:0]
				} else {
					_ = session.Rollback()
				}
			}
		}()

		if len(m.InsertQueue) <= 0 {
			return true
		}
		err = session.Begin()
		if err != nil {
			return false
		}

		const num = 100
		var insertArray [num]*Persist
		length := len(m.InsertQueue)
		quotient := length / num
		remainder := length % num
		for i := 0; i < quotient; i++ {
			//fmt.Println("s1->(", i*num, "-", (i+1)*num, "): ", m.InsertQueue[i*num:(i+1)*num])
			for j := 0; j < num; j++ {
				insertArray[j] = m.InsertQueue[i*num+j].Data
			}
			_, err = session.InsertMulti(insertArray[:])
			if err != nil {
				log.Println("InsertMulti error ", err)
				return false
			}
		}
		if remainder != 0 {
			//fmt.Println("s1->(", quotient*num, "-", length, "): ", m.InsertQueue[quotient*num:length])
			insertArray = [num]*Persist{}
			for j := 0; j < remainder; j++ {
				insertArray[j] = m.InsertQueue[quotient*num+j].Data
			}
			_, err = session.InsertMulti(insertArray[:remainder])
			if err != nil {
				log.Println("InsertMulti error ", err)
				return false
			}
		}
		err = session.Commit()
		if err != nil {
			return false
		}
		return true
	}

	multiInsertSuccess := multiInsertFn()

	// 批量插入失败, 改为单条插入
	if !multiInsertSuccess {
		for idx, persistSync := range m.InsertQueue {
			err = m.SaveDB(session, persistSync)
			if err != nil {
				m.InsertQueue = m.InsertQueue[idx:]
				m.SaveFile()
				return
			}
		}
		m.InsertQueue = m.InsertQueue[0:0]
	}
{{end}}

	for i := 0; i < len(*m.syncQueue); i++ {
		persistSync = (*m.syncQueue)[i]
		err = m.SaveDB(session, persistSync)
		if err != nil {
			*m.syncQueue = (*m.syncQueue)[i:]
			m.SaveFile()
			return
		}
	}
	*m.syncQueue = (*m.syncQueue)[0:0]
	m.RemoveFile()
	return
{{end}}
{{*/}}

{{if $.ArgsInfo.Save}}

	// Save 异步写回
	func (m *{{.DataName}}Manager) Save() {
		var exit bool
		for {
			// 正常退出
			exit = m.AsyncSave()
			if exit {
				break
			}
		}
	}

	// AsyncSave 异步写回
	func (m *{{.DataName}}Manager) AsyncSave() (exit bool) {
		var persistSync *{{.DataName}}Sync
		var err error
		var queueEmpty bool
		bTime := time.Now().UnixNano()
		defer func() {
			if r := recover(); r != nil {
				log.Println("recovered in ", r)
				log.Println("stack: ", string(debug.Stack()))
				if !queueEmpty {
					log.Println("save failed: incrementalSave")
				}
			} else {
				if !queueEmpty {
					if err == nil {
						log.Println("save success: incrementalSave")
					} else {
						log.Println("save failed: incrementalSave")
					}
				}
			}
			m.DataToFailQueue()
			m.lastWriteBackTime = time.Duration(time.Now().UnixNano() - bTime)
			m.syncEnd <- true
		}()
		
		needCollect := <-m.syncBegin
		if len(*m.syncQueue) == 0 {
			queueEmpty = true
			if needCollect {
				time.Sleep(time.Millisecond * {{$.ArgsInfo.QueueEmptySleepTime}})
			} else {
				exit = true
			}
			return
		}
		session := m.engine.NewSession()
		defer session.Close()

		log.Println("begin incrementalSave", bTime)

		{{if .ArgsInfo.OptimizeFlagSQLMerge}}
			if len(m.FailQueue) > 0 {
				tmpQueue := make([]*{{.DataName}}Sync, len(m.FailQueue)+len(*m.syncQueue))
				copy(tmpQueue, m.FailQueue)
				copy(tmpQueue[len(m.FailQueue):], *m.syncQueue)
				insertQueue, otherQueue := m.MergeQueue(tmpQueue, true)
				m.syncQueue = &otherQueue
				m.InsertQueue = insertQueue
				m.FailQueue = m.FailQueue[0:0]
			} else {
				insertQueue, otherQueue := m.MergeQueue(*m.syncQueue, true)
				m.syncQueue = &otherQueue
				m.InsertQueue = insertQueue
			}
		{{end}}

		{{if .ArgsInfo.OptimizeFlagSQLInsertMerge}}
			multiInsertFn := func() bool {
				var err error
				defer func() {
					if r := recover(); r != nil {
						_ = session.Rollback()
					} else {
						if err == nil {
							m.InsertQueue = m.InsertQueue[0:0]
						} else {
							_ = session.Rollback()
						}
					}
				}()

				if len(m.InsertQueue) <= 0 {
					return true
				}
				err = session.Begin()
				if err != nil {
					return false
				}

				const num = {{.ArgsInfo.MaxInsertRows}}
				var insertArray [num]*{{.ArgsInfo.PersistPkgName}}.{{.DataName}}
				length := len(m.InsertQueue)
				quotient := length / num
				remainder := length % num
				for i := 0; i < quotient; i++ {
					//fmt.Println("queue->(", i*num, "-", (i+1)*num, "): ", m.InsertQueue[i*num:(i+1)*num])
					for j := 0; j < num; j++ {
						insertArray[j] = m.InsertQueue[i*num+j].Data
					}
					{{if ne $.ArgsInfo.SwitchTable ""}}
					_, err = session.Table(Get{{.DataName}}TableName()).InsertMulti(insertArray[:])
					{{else}}
					_, err = session.InsertMulti(insertArray[:])
					{{end}}
					if err != nil {
						log.Println("InsertMulti error ", err)
						return false
					}
				}
				if remainder != 0 {
					//fmt.Println("queue->(", quotient*num, "-", length, "): ", m.InsertQueue[quotient*num:length])

					insertArray = [num]*{{.ArgsInfo.PersistPkgName}}.{{.DataName}}{}
					for j := 0; j < remainder; j++ {
						insertArray[j] = m.InsertQueue[quotient*num+j].Data
					}
					{{if ne $.ArgsInfo.SwitchTable ""}}
					_, err = session.Table(Get{{.DataName}}TableName()).InsertMulti(insertArray[:])
					{{else}}
					_, err = session.InsertMulti(insertArray[:remainder])
					{{end}}
					if err != nil {
						log.Println("InsertMulti error ", err)
						return false
					}
				}
				err = session.Commit()
				if err != nil {
					return false
				}
				return true
			}

			multiInsertSuccess := multiInsertFn()

			// 批量插入失败, 改为单条插入
			if !multiInsertSuccess {
				for idx, persistSync := range m.InsertQueue {
					err = m.SaveDB(session, persistSync)
					if err != nil {
						m.InsertQueue = m.InsertQueue[idx:]
						m.SaveFile()
						return
					}
				}
				m.InsertQueue = m.InsertQueue[0:0]
			}
		{{end}}


		for i := 0; i < len(*m.syncQueue); i++ {
			persistSync = (*m.syncQueue)[i]
			err = m.SaveDB(session, persistSync)
			if err != nil {
				*m.syncQueue = (*m.syncQueue)[i:]
				m.SaveFile()
				return
			}
		}
		*m.syncQueue = (*m.syncQueue)[0:0]
		m.RemoveFile()
		return
	}
{{end}}







{{/* collect }}
{{if $.ArgsInfo.Save}}
	// Collect 收集数据
	func (m *PersistManager) Collect() {
		var persistSync *PersistSync
		var ok bool
		// 0:normal  1:exit begin, save sync  2:save cache  3:save done
		var state int8
		go m.Save()
		m.syncBegin <- true
		for {
			select {
			case persistSync, ok = <-m.syncChan:
				if ok {
					*m.cacheQueue = append(*m.cacheQueue, persistSync)
				}
			case _, ok = <-m.syncEnd:
				if ok {
					m.CheckOverload()
					m.cacheQueue, m.syncQueue = m.syncQueue, m.cacheQueue
					switch state {
					case EPersistCollectStateNormal:
						//go m.AsyncSave()
						m.syncBegin <- true
					case EPersistCollectStateSaveSync:
						//go m.AsyncSave()
						m.syncBegin <- true
						state = EPersistCollectStateSaveCache
					case EPersistCollectStateSaveCache:
						//go m.AsyncSave()
						m.syncBegin <- true
						state = EPersistCollectStateSaveDone
					case EPersistCollectStateSaveDone:
						m.syncBegin <- false
						<-m.syncEnd
						m.exitEnd <- true
						return
					}
				}
			case _, ok = <-m.exitBegin:
				if ok {
					state = EPersistCollectStateSaveSync
				}
			//default:
			//	time.Sleep(time.Second/10)
			}
		}
	}
{{end}}
{{*/}}
{{if $.ArgsInfo.Save}}
	// Collect 收集数据
	func (m *{{.DataName}}Manager) Collect() {
		var persistSync *{{.DataName}}Sync
		var ok bool
		// 0:normal  1:exit begin, save sync  2:save cache  3:save done
		var state int8
		go m.Save()
		m.syncBegin <- true
		for {
			select {
			case persistSync, ok = <-m.syncChan:
				if ok {
					*m.cacheQueue = append(*m.cacheQueue, persistSync)
				}
			case _, ok = <-m.syncEnd:
				if ok {
					m.CheckOverload()
					m.cacheQueue, m.syncQueue = m.syncQueue, m.cacheQueue
					switch state {
					case E{{.DataName}}CollectStateNormal:
						//go m.AsyncSave()
						m.syncBegin <- true
					case E{{.DataName}}CollectStateSaveSync:
						//go m.AsyncSave()
						m.syncBegin <- true
						state = E{{.DataName}}CollectStateSaveCache
					case E{{.DataName}}CollectStateSaveCache:
						//go m.AsyncSave()
						m.syncBegin <- true
						state = E{{.DataName}}CollectStateSaveDone
					case E{{.DataName}}CollectStateSaveDone:
						m.syncBegin <- false
						<-m.syncEnd
						m.exitEnd <- true
						return
					}
				}
			case _, ok = <-m.exitBegin:
				if ok {
					state = E{{.DataName}}CollectStateSaveSync
				}
			//default:
			//	time.Sleep(time.Second/10)
			}
		}
	}
{{end}}


{{/* exit }}
{{if $.ArgsInfo.Save}}
	// Exit 管理类退出
	func (m *PersistManager) Exit(wg *sync.WaitGroup) {
		defer wg.Done()

		if atomic.LoadInt32(&m.managerState) != EPersistManagerStateNormal {
			return
		}

		m.exitBegin <- true
		<-m.exitEnd
		atomic.StoreInt32(&m.managerState, EPersistManagerStateIdle)
		return
	}
{{end}}
{{*/}}
{{if $.ArgsInfo.Save}}
	// Exit 管理类退出
	func (m *{{.DataName}}Manager) Exit(wg *sync.WaitGroup) {
		defer wg.Done()

		if atomic.LoadInt32(&m.managerState) != E{{.DataName}}ManagerStateNormal {
			return
		}

		m.exitBegin <- true
		<-m.exitEnd
		atomic.StoreInt32(&m.managerState, E{{.DataName}}ManagerStateIdle)
		return
	}
{{end}}


{{/* sync }}
{{if $.ArgsInfo.Save}}
	// Sync 数据库表结构同步
	func (m *PersistManager) Sync(wg *sync.WaitGroup) (err error) {
		defer wg.Done()
		err = m.engine.Sync2(gPersistNil)
		return
	}
{{end}}
{{*/}}
{{if $.ArgsInfo.Save}}
	// Sync 数据库表结构同步
	func (m *{{.DataName}}Manager) Sync(wg *sync.WaitGroup) (err error) {
		defer wg.Done()
		{{if ne $.ArgsInfo.SwitchTable ""}}
		changeDay := getNow{{.DataName}}Belong()
		if changeDay != nil {
			baseName := m.engine.TableName(g{{.DataName}}Nil)
			changeTable := fmt.Sprintf("%s_%s",baseName,changeDay.Format("20060102"))
			if changeTable != Get{{.DataName}}TableName(){
				log.Println("create new table :",changeTable,time.Now())
				m.engine.Table(changeTable).Sync2(g{{.DataName}}Nil)
				Change{{.DataName}}TableName(changeTable)
			}
		}else {
			err = m.engine.Sync2(g{{.DataName}}Nil)
		}
		{{else}}
		err = m.engine.Sync2(g{{.DataName}}Nil)
		{{end}}
		return
	}
{{end}}


{{/* SwitchTable }}
{{if ne $.ArgsInfo.SwitchTable ""}}
	// Segmentation 检查是否需要换表 如果需要换表 则根据时间 和切换间隔计算是否需要换表 否则为不处理
	func (m *PersistManager) Segmentation(wg *sync.WaitGroup) (err error) {
		defer wg.Done()
		// 根据常量计算是否需要换表
		changeDay := getNowTableBelong()
		if changeDay != nil {
			baseName := m.engine.TableName(gPersistNil)
			changeTable := fmt.Sprintf("%s_%s",baseName,changeDay.Format("20060102"))
			if changeTable != GetPersistTableName(){
				log.Println("create new table :",changeTable,time.Now())
				m.engine.Table(changeTable).Sync2(gPersistNil)
				ChangePersistTableName(changeTable)
			}
		}
		return
	}
{{else}}
    // Segmentation 检查是否需要换表 如果需要换表 则根据时间 和切换间隔计算是否需要换表 否则为不处理
	func (m *PersistManager) Segmentation(wg *sync.WaitGroup) (err error) {
		defer wg.Done()
        return
	}
{{end}}
{{*/}}
{{if ne $.ArgsInfo.SwitchTable ""}}
	// Segmentation 检查是否需要换表 如果需要换表 则根据时间 和切换间隔计算是否需要换表 否则为不处理
	func (m *{{.DataName}}Manager) Segmentation(wg *sync.WaitGroup) (err error) {
		defer wg.Done()
		// 根据常量计算是否需要换表
		changeDay := getNow{{.DataName}}Belong()
		if changeDay != nil {
			baseName := m.engine.TableName(g{{.DataName}}Nil)
			changeTable := fmt.Sprintf("%s_%s",baseName,changeDay.Format("20060102"))
			if changeTable != Get{{.DataName}}TableName(){
				log.Println("create new table :",changeTable,time.Now())
				m.engine.Table(changeTable).Sync2(g{{.DataName}}Nil)
				Change{{.DataName}}TableName(changeTable)
			}
		}
		return	
	}
{{else}}
    // Segmentation 检查是否需要换表 如果需要换表 则根据时间 和切换间隔计算是否需要换表 否则为不处理
	func (m *{{.DataName}}Manager) Segmentation(wg *sync.WaitGroup) (err error) {
		defer wg.Done()
		return
	}
{{end}}

{{/* SwitchTable }}
{{*/}}
{{if ne $.ArgsInfo.SwitchTable ""}}
{{/* reflect struct }}
	func getNowTableBelong() *time.Time {
		changeDay := time.Time{}
		if PersistSwitchDay == "day" {
			changeDay = time.Now()
		}else if PersistSwitchDay == "week" {
			weekStart := time.Now().Weekday()
			changeDay = time.Now().AddDate(0, 0, -int(weekStart)+1)
		}else if PersistSwitchDay == "month" {
			today := time.Now()
			changeDay = time.Date(today.Year(), today.Month(), 1, 0, 0, 0, 0, today.Location())
		}else {
			return nil
		}
		return &changeDay
	}
{{*/}}
	func getNow{{.DataName}}Belong() *time.Time {
		changeDay := time.Time{}
		if {{.DataName}}SwitchDay == "day" {
			changeDay = time.Now()
		}else if {{.DataName}}SwitchDay == "week" {
			weekStart := time.Now().Weekday()
			changeDay = time.Now().AddDate(0, 0, -int(weekStart)+1)
		}else if {{.DataName}}SwitchDay == "month" {
			today := time.Now()
			changeDay = time.Date(today.Year(), today.Month(), 1, 0, 0, 0, 0, today.Location())
		}else {
			return nil
		}
		return &changeDay
	}
{{end}}


{{/* exit }}
{{if $.ArgsInfo.Save}}
// compareAndUpdate 比较数据库，不相同则更新
func (m *PersistManager) compareAndUpdate(session *xorm.Session, cls *Persist,sentryDebug bool) (err error) {
	update := func(session *xorm.Session, cls *Persist, memData, dbData string) {
		log.Println("SyncData error. missing mark Mem. [sql error {{.DataName}}]", memData)
		log.Println("SyncData error. missing mark  Db. [sql error {{.DataName}}]", dbData)
		_, err = session.ID(core.NewPK(cls.Uid, cls.Id)).AllCols().Update(cls)
		if err != nil {
			log.Println("SyncData update error.", err, "[sql error {{.DataName}}]", m.PersistSyncToString(&PersistSync{
				Data:   cls,
				Op:     E{{.DataName}}OpUpdate,
				BitSet: m.bitSetAll,
			}))
			return
		}
	}
	resetTimeNSec := func(clsMem, clsDb *Persist) {
		defer func() {
			if r := recover(); r != nil {
				log.Println("recovered in ", r)
				log.Println("stack: ", string(debug.Stack()))
			}
		}()
		typeF := reflect.TypeOf(*clsMem)
		valueMemF := reflect.ValueOf(clsMem).Elem()
		valueDbF := reflect.ValueOf(clsDb).Elem()
		for i := 0; i < typeF.NumField(); i++ {
			if typeF.Field(i).Type.Name() == "Time" {
				f := valueMemF.Field(i)
				if f.CanInterface() {
					v := time.Unix(f.Interface().(time.Time).Unix(), 0)
					f.Set(reflect.ValueOf(v))
				}
				vMem := valueMemF.Field(i).Interface().(time.Time)
				vDb := valueDbF.Field(i).Interface().(time.Time)
				if vMem.Equal(vDb) {
					f.Set(reflect.ValueOf(vDb))
				}
			}
		}
	}

	dbCls := &Persist{

		Uid: cls.Uid,

		Id: cls.Id,
	}
	var has bool
	has, err = session.Get(dbCls)
	if err != nil || !has {
		log.Println("SyncData query error.", err, "[sql error {{.DataName}}]", m.PersistSyncToString(&PersistSync{
			Data:   cls,
			Op:     0,
			BitSet: m.bitSetAll,
		}))
		return
	}
	memCls := m.GetPersistByUidId(cls.Uid, cls.Id)
	if memCls != nil {
		resetTimeNSec(memCls, dbCls)
		memData :=  m.PersistSyncToString(&PersistSync{
			Data:   memCls,
			Op:     0,
			BitSet: m.bitSetAll,
		}) 
		dbData := m.PersistSyncToString(&PersistSync{
			Data:   dbCls,
			Op:     0,
			BitSet: m.bitSetAll,
		})
		// 数据库内存不一致
		if strings.Compare(memData, dbData) != 0 {
			if sentryDebug {
				func() {
					defer func(){
						memClsJson,_ := json.Marshal(&PersistSync{
							Data:   memCls,
							Op:     0,
							BitSet: m.bitSetAll,
						})
						dbClsJson,_ := json.Marshal(&PersistSync{
							Data:   dbCls,
							Op:     0,
							BitSet: m.bitSetAll,
						})
						sentry.WithScope(func(scope *sentry.Scope) {
							tagtag := "CompareError"+"{{.DataName}}"
							scope.SetTag(tagtag,"{{.DataName}}")
							scope.SetTag("transaction", "{{.DataName}}")
							scope.SetExtra("memClsJson", string(memClsJson))
							scope.SetExtra("dbClsJson", string(dbClsJson))
							sentry.CaptureMessage(tagtag)
						})
					}()	
				}()
			}
			update(session, memCls, memData, dbData)
		}
	}
	return
}

// SyncData 全部内存数据写入数据库, 本接口耗时长,仅用于停服后.  补救没有标记写回数据(只处理未标记数据,New Delete不存在漏写)
func (m *PersistManager) SyncData(wg *sync.WaitGroup, sentryDebug bool) (err error) {
	defer wg.Done()

	session := m.engine.NewSession()
	defer session.Close()
	
	if sentryDebug {
		func() {
			defer func(){
				for _, cls := range m.GetAll() {
					updateErr := m.compareAndUpdate(session, cls,sentryDebug)
					if updateErr != nil {
						err = updateErr
					}
				}
				if err != nil {
					sentry.WithScope(func(scope *sentry.Scope) {
						tagtag := "SyncDataError" + "{{.DataName}}" 
						scope.SetTag("SyncDataError", "{{.DataName}}")
						scope.SetTag("transaction", "{{.DataName}}")
						scope.SetExtra(err.Error(),1)
						sentry.CaptureMessage(tagtag)
					})
				}
			}()	
		}()
	}else {
		for _, cls := range m.GetAll() {
			updateErr := m.compareAndUpdate(session, cls,sentryDebug)
			if updateErr != nil {
				err = updateErr
			}
		}
	}
	return

}

// SyncUserData 用户内存和数据库数据比较并更新, 不允许并发， 用于数据导出时，补救没有标记写回数据(只处理未标记数据,New Delete不存在漏写)
func (m *PersistManager) SyncUserData(uid int32) (err error) {
	session := m.engine.NewSession()
	defer session.Close()
	var clsList []*Persist

	// 业务代码必须保证，不使用正在导出的数据， 否则可能引发崩溃
	func() {
		defer func() {
			if r := recover(); r != nil {
				log.Println("recovered in ", r)
				log.Println("stack: ", string(debug.Stack()))
				err = errors.New("SyncUserData error")
			}
		}()
		for _, cls := range m.GetPersistsByUid(uid) {
			clsList = append(clsList, m.acquireDeepCopyObject(cls))
		}
	}()

	if err != nil {
		return
	}

	for _, cls := range clsList {
		err = m.compareAndUpdate(session, cls)
		if err != nil {
			sentry.WithScope(func(scope *sentry.Scope) {
				tagtag := "SyncDataError" + "{{.DataName}}" 
				scope.SetTag("SyncDataError", "{{.DataName}}")
				scope.SetTag("transaction", "{{.DataName}}")
				scope.SetExtra(err.Error(),1)
				sentry.CaptureMessage(tagtag)
			})
		}
		if err != nil {
			return
		}
	}

	return

}
{{end}}
{{*/}}

{{if $.ArgsInfo.Save}}
{{if .HashIndexPk}}
	// compareAndUpdate 比较数据库，不相同则更新
	func (m *{{.DataName}}Manager) compareAndUpdate(session *xorm.Session, cls *{{.ArgsInfo.PersistPkgName}}.{{.DataName}},sentryDebug bool) (err error) {
		update := func(session *xorm.Session, cls *{{.ArgsInfo.PersistPkgName}}.{{.DataName}}, memData, dbData string) {
			log.Println("SyncData error. missing mark Mem. [sql error {{.DataName}}]", memData)
			log.Println("SyncData error. missing mark  Db. [sql error {{.DataName}}]", dbData)
			_, err = session.ID(core.NewPK({{.HashIndexPk.ClsPointKeys}})).AllCols().Update(cls)
			if err != nil {
				log.Println("SyncData update error.", err, "[sql error {{.DataName}}]", m.PersistSyncToString(&{{.DataName}}Sync{
					Data:   cls,
					Op:     E{{.DataName}}OpUpdate,
					BitSet: m.bitSetAll,
				}))
				return
			}
		}
		resetTimeNSec := func(clsMem, clsDb *{{.ArgsInfo.PersistPkgName}}.{{.DataName}}) {
			defer func() {
				if r := recover(); r != nil {
					log.Println("recovered in ", r)
					log.Println("stack: ", string(debug.Stack()))
				}
			}()
			typeF := reflect.TypeOf(*clsMem)
			valueMemF := reflect.ValueOf(clsMem).Elem()
			valueDbF := reflect.ValueOf(clsDb).Elem()
			for i := 0; i < typeF.NumField(); i++ {
				if typeF.Field(i).Type.Name() == "Time" {
					f := valueMemF.Field(i)
					if f.CanInterface() {
						v := time.Unix(f.Interface().(time.Time).Unix(), 0)
						f.Set(reflect.ValueOf(v))
					}
					vMem := valueMemF.Field(i).Interface().(time.Time)
					vDb := valueDbF.Field(i).Interface().(time.Time)
					if vMem.Equal(vDb) {
						f.Set(reflect.ValueOf(vDb))
					}
				}
			}
		}

		dbCls := &{{.ArgsInfo.PersistPkgName}}.{{.DataName}}{
				{{range $i, $col := .HashIndexPk.Cols}}
					{{$col}}: cls.{{$col}},
				{{end}}
		}
		var has bool
		has, err = session.Get(dbCls)
		if err != nil || !has {
			log.Println("SyncData query error.", err, "[sql error {{.DataName}}]", m.PersistSyncToString(&{{.DataName}}Sync{
				Data:   cls,
				Op:     0,
				BitSet: m.bitSetAll,
			}))
			return
		}
		memCls := m.Get{{.DataName}}By{{.HashIndexPk.Keys}}({{.HashIndexPk.ClsPointKeys}})
		if memCls != nil {
			resetTimeNSec(memCls, dbCls)
			memData :=  m.PersistSyncToString(&{{.DataName}}Sync{
				Data:   memCls,
				Op:     0,
				BitSet: m.bitSetAll,
			}) 
			dbData := m.PersistSyncToString(&{{.DataName}}Sync{
				Data:   dbCls,
				Op:     0,
				BitSet: m.bitSetAll,
			})
			// 数据库内存不一致
			if strings.Compare(memData, dbData) != 0 {
				if sentryDebug {
					func() {
						defer func(){
							memClsJson,_ := json.Marshal(&{{.DataName}}Sync{
								Data:   memCls,
								Op:     0,
								BitSet: m.bitSetAll,
							})
							dbClsJson,_ := json.Marshal(&{{.DataName}}Sync{
								Data:   dbCls,
								Op:     0,
								BitSet: m.bitSetAll,
							})
							sentry.WithScope(func(scope *sentry.Scope) {
								tag := "CompareError"+"{{.DataName}}"
								scope.SetTag(tag,"{{.DataName}}")
								scope.SetTag("transaction", "{{.DataName}}")
								scope.SetExtra("memClsJson", string(memClsJson))
								scope.SetExtra("dbClsJson", string(dbClsJson))
								sentry.CaptureMessage(tag)
							})
						}()	
					}()
				}
				update(session, memCls, memData, dbData)
			}
		}
		return
	}

{{end}}
{{end}}

{{if $.ArgsInfo.Save}}
	// SyncData 全部内存数据写入数据库, 本接口耗时长,仅用于停服后.  补救没有标记写回数据(只处理未标记数据,New Delete不存在漏写)
	func (m *{{.DataName}}Manager) SyncData(wg *sync.WaitGroup,sentryDebug bool) (err error) {
		defer wg.Done()

		{{if .HashIndexPk}}
			session := m.engine.NewSession()
			defer session.Close()

			if sentryDebug {
				func() {
					defer func(){
						for _, cls := range m.GetAll() {
							updateErr := m.compareAndUpdate(session, cls,sentryDebug)
							if updateErr != nil {
								err = updateErr
							}
						}
						if err != nil {
							sentry.WithScope(func(scope *sentry.Scope) {
								tagtag := "SyncDataError" + "{{.DataName}}" 
								scope.SetTag("SyncDataError", "{{.DataName}}")
								scope.SetTag("transaction", "{{.DataName}}")
								scope.SetExtra(err.Error(),1)
								sentry.CaptureMessage(tagtag)
							})
						}
					}()	
				}()
			}else {
				for _, cls := range m.GetAll() {
					updateErr := m.compareAndUpdate(session, cls,sentryDebug)
					if updateErr != nil {
						err = updateErr
					}
				}
			}
			return
		{{else}}
			return
		{{end}}
	}
{{end}}

{{if $.ArgsInfo.Save}}
{{if .HashIndexUnload}}

	// SyncUserData 用户内存和数据库数据比较并更新, 不允许并发， 用于数据导出时，补救没有标记写回数据(只处理未标记数据,New Delete不存在漏写)
	// sentryDebug debug模式下启用sentry
	func (m *{{.DataName}}Manager) SyncUserData({{index .HashIndexUnload.Cols 0}} {{index .HashIndexUnload.Types 0}},sentryDebug bool) (err error) {
		session := m.engine.NewSession()
		defer session.Close()
		var clsList []*{{.ArgsInfo.PersistPkgName}}.{{.DataName}}

		// 业务代码必须保证，不使用正在导出的数据， 否则可能引发崩溃
		func() {
			defer func() {
				if r := recover(); r != nil {
					log.Println("recovered in ", r)
					log.Println("stack: ", string(debug.Stack()))
					err = errors.New("SyncUserData error")
				}
			}()

			{{if .HashIndexUnload.Unique}}
				cls := m.Get{{.DataName}}By{{index .HashIndexUnload.Cols 0}}({{index .HashIndexUnload.Cols 0}})
				if cls != nil {
					clsList = append(clsList, m.acquireDeepCopyObject(cls))
				}
			{{else}}
				for _, cls := range m.Get{{.DataName}}sBy{{index .HashIndexUnload.Cols 0}}({{index .HashIndexUnload.Cols 0}}) {
					clsList = append(clsList, m.acquireDeepCopyObject(cls))
				}
			{{end}}
		}()

		if err != nil {
			return
		}

		for _, cls := range clsList {
			err = m.compareAndUpdate(session, cls,sentryDebug)
			if sentryDebug {
				func() {
					defer func() {
						if err!= nil {
							sentry.WithScope(func(scope *sentry.Scope) {
								tagtag := "SyncDataError" + "{{.DataName}}" 
								scope.SetTag("SyncDataError", "{{.DataName}}")
								scope.SetTag("transaction", "{{.DataName}}")
								scope.SetExtra(err.Error(),1)
								sentry.CaptureMessage(tagtag)
							})
						}
					}()
				}()
			}
			if err != nil {
				return
			}
		}

		return

	}


{{end}}
{{end}}



{{/* object pool }}
// 使用pool优化时需要
{{if .ArgsInfo.OptimizeFlagUsePoolAndDisableDeleteUnload}}

type AccountGlobalObjectPool struct {
	pool []*AccountGlobal
	mu   sync.RWMutex
}

func (p *AccountGlobalObjectPool) Put(obj *AccountGlobal) int {
	p.mu.Lock()
	idx := len(p.pool)
	p.pool = append(p.pool, obj)
	p.mu.Unlock()
	return idx
}

func (p *AccountGlobalObjectPool) Get(idx int) (obj *AccountGlobal) {
	p.mu.RLock()
	if idx != -1 && idx < len(p.pool) {
		obj = p.pool[idx]
	}
	p.mu.RUnlock()
	return
}

func (p *AccountGlobalObjectPool) GetAll() (objList []*AccountGlobal) {
	p.mu.RLock()
	objList = p.pool[:]
	p.mu.RUnlock()
	return
}

func (p *AccountGlobalObjectPool) Clean() {
	p.mu.Lock()
	for i := 0; i < len(p.pool); i++ {
		p.pool[i] = nil
	}
	p.pool = nil
	p.mu.Unlock()
	return
}

type AccountGlobalObjectMapPool struct {
	pool [][]int
	mu   sync.RWMutex
}

func (p *AccountGlobalObjectMapPool) New(objIdx int) (poolIdx int) {
	p.mu.Lock()
	poolIdx = len(p.pool)
	p.pool = append(p.pool, []int{objIdx})
	p.mu.Unlock()
	return
}

func (p *AccountGlobalObjectMapPool) Put(poolIdx int, objIdx int) {
	// 主键保证了ObjectMapPool.put不会有重复的对象
	p.mu.Lock()
	if poolIdx != -1 && poolIdx < len(p.pool) {
		// ordered 支持删除时，需要依赖有序
		//mapPool := p.pool[poolIdx]
		//length := len(mapPool)
		//
		////leftmost := sort.Search(length, func(i int) bool {
		////	return mapPool[i] <= objIdx
		////})
		//
		//i, j := 0, length
		//for i < j {
		//	h := int(uint(i+j) >> 1) // avoid overflow when computing h
		//	// i ≤ h < j
		//	if !(mapPool[h] <= objIdx) {
		//		i = h + 1 // preserves f(i-1) == false
		//	} else {
		//		j = h // preserves f(j) == true
		//	}
		//}
		//// i == j, f(i-1) == false, and f(j) (= f(i)) == true  =>  answer is i.
		//leftmost := i
		//
		//if leftmost >= length {
		//	p.pool[poolIdx] = append(p.pool[poolIdx], objIdx)
		//} else {
		//	p.pool[poolIdx] = append(p.pool[poolIdx], 0)
		//	mapPool = p.pool[poolIdx]
		//	for i := length; i > leftmost; i-- {
		//		mapPool[i] = mapPool[i-1]
		//	}
		//	mapPool[leftmost] = objIdx
		//}

		//unordered
		p.pool[poolIdx] = append(p.pool[poolIdx], objIdx)
	}
	p.mu.Unlock()
	return
}

func (p *AccountGlobalObjectMapPool) Get(poolIdx int) (objIdxList []int) {
	p.mu.RLock()
	if poolIdx != -1 && poolIdx < len(p.pool) {
		for _, objIdx := range p.pool[poolIdx] {
			objIdxList = append(objIdxList, objIdx)
		}
	}
	p.mu.RUnlock()
	return
}

func (p *AccountGlobalObjectMapPool) GetAll() (objIdxList []int) {
	p.mu.RLock()
	for idx := 0; idx < len(p.pool); idx++ {
		for _, objIdx := range p.pool[idx] {
			objIdxList = append(objIdxList, objIdx)
		}
	}
	p.mu.RUnlock()
	return
}
func (p *AccountGlobalObjectMapPool) Clean() {
	p.mu.Lock()
	for i := 0; i < len(p.pool); i++ {
		p.pool[i] = nil
	}
	p.pool = nil
	p.mu.Unlock()
	return
}


{{end}}
{{*/}}



// object pool
{{if .ArgsInfo.OptimizeFlagUsePoolAndDisableDeleteUnload}}

	type {{.DataName}}ObjectPool struct {
		pool []*{{.ArgsInfo.PersistPkgName}}.{{.DataName}}
		mu   sync.RWMutex
	}

	func (p *{{.DataName}}ObjectPool) Put(obj *{{.ArgsInfo.PersistPkgName}}.{{.DataName}}) int {
		p.mu.Lock()
		idx := len(p.pool)
		p.pool = append(p.pool, obj)
		p.mu.Unlock()
		return idx
	}

	func (p *{{.DataName}}ObjectPool) Get(idx int) (obj *{{.ArgsInfo.PersistPkgName}}.{{.DataName}}) {
		p.mu.RLock()
		if idx != -1 && idx < len(p.pool) {
			obj = p.pool[idx]
		}
		p.mu.RUnlock()
		return
	}

	func (p *{{.DataName}}ObjectPool) GetAll() (objList []*{{.ArgsInfo.PersistPkgName}}.{{.DataName}}) {
		p.mu.RLock()
		objList = p.pool[:]
		p.mu.RUnlock()
		return
	}

	func (p *{{.DataName}}ObjectPool) Clean() {
		p.mu.Lock()
		for i := 0; i < len(p.pool); i++ {
			p.pool[i] = nil
		}
		p.pool = nil
		p.mu.Unlock()
		return
	}

	type {{.DataName}}ObjectMapPool struct {
		pool [][]int
		mu   sync.RWMutex
	}

	func (p *{{.DataName}}ObjectMapPool) New(objIdx int) (poolIdx int) {
		p.mu.Lock()
		poolIdx = len(p.pool)
		p.pool = append(p.pool, []int{objIdx})
		p.mu.Unlock()
		return
	}

	func (p *{{.DataName}}ObjectMapPool) Put(poolIdx int, objIdx int) {
		// 主键保证了ObjectMapPool.put不会有重复的对象
		p.mu.Lock()
		if poolIdx != -1 && poolIdx < len(p.pool) {
			// ordered 支持删除时，需要依赖有序
			//mapPool := p.pool[poolIdx]
			//length := len(mapPool)
			//
			////leftmost := sort.Search(length, func(i int) bool {
			////	return mapPool[i] <= objIdx
			////})
			//
			//i, j := 0, length
			//for i < j {
			//	h := int(uint(i+j) >> 1) // avoid overflow when computing h
			//	// i ≤ h < j
			//	if !(mapPool[h] <= objIdx) {
			//		i = h + 1 // preserves f(i-1) == false
			//	} else {
			//		j = h // preserves f(j) == true
			//	}
			//}
			//// i == j, f(i-1) == false, and f(j) (= f(i)) == true  =>  answer is i.
			//leftmost := i
			//
			//if leftmost >= length {
			//	p.pool[poolIdx] = append(p.pool[poolIdx], objIdx)
			//} else {
			//	p.pool[poolIdx] = append(p.pool[poolIdx], 0)
			//	mapPool = p.pool[poolIdx]
			//	for i := length; i > leftmost; i-- {
			//		mapPool[i] = mapPool[i-1]
			//	}
			//	mapPool[leftmost] = objIdx
			//}

			//unordered
			p.pool[poolIdx] = append(p.pool[poolIdx], objIdx)
		}
		p.mu.Unlock()
		return
	}

	func (p *{{.DataName}}ObjectMapPool) Get(poolIdx int) (objIdxList []int) {
		p.mu.RLock()
		if poolIdx != -1 && poolIdx < len(p.pool) {
			for _, objIdx := range p.pool[poolIdx] {
				objIdxList = append(objIdxList, objIdx)
			}
		}
		p.mu.RUnlock()
		return
	}

	func (p *{{.DataName}}ObjectMapPool) GetAll() (objIdxList []int) {
		p.mu.RLock()
		for idx := 0; idx < len(p.pool); idx++ {
			for _, objIdx := range p.pool[idx] {
				objIdxList = append(objIdxList, objIdx)
			}
		}
		p.mu.RUnlock()
		return
	}
	func (p *{{.DataName}}ObjectMapPool) Clean() {
		p.mu.Lock()
		for i := 0; i < len(p.pool); i++ {
			p.pool[i] = nil
		}
		p.pool = nil
		p.mu.Unlock()
		return
	}


{{end}}


{{if $.HaveRBTree}}


{{range $i, $v := .RBTreeIndexList}}
	type {{$.DataName}}RBTreeValue struct {
		{{range $ii, $vv := $v.Cols }}    {{index $v.Cols $ii}} {{index $v.Types $ii}}
		{{end}}
	}
{{end}}


type {{$.DataName}}RBTreeKey struct {
	Key   {{.DataName}}KeyTypeHash{{.HashIndexPk.Keys}}
	Value {{$.DataName}}RBTreeValue
}

func Get{{$.DataName}}OnlyKey(a {{$.DataName}}RBTreeKey) any{
	return a.Key
}

func Get{{$.DataName}}Value(a {{$.DataName}}RBTreeKey) any {
	return a.Value
}

var Less{{$.DataName}} func(a,b {{$.DataName}}RBTreeKey) bool



func (m *{{.DataName}}Manager) SetData(obj *{{$.ArgsInfo.PersistPkgName}}.{{$.DataName}}) {
	m.RBTree.Put({{$.DataName}}RBTreeKey{Key:{{.DataName}}KeyTypeHash{{.HashIndexPk.Keys}}{
		{{range $i, $col := .HashIndexPk.Cols}}
			{{$col}}: obj.{{$col}},
		{{end}}
	},Value: {{$.DataName}}RBTreeValue{
		{{range $i, $col := .IndexRBTreeValue.Cols}}
			{{$col}}: obj.{{$col}},
		{{end}}
	}})
}

func (m *{{.DataName}}Manager) RemoveData(obj *{{$.ArgsInfo.PersistPkgName}}.{{$.DataName}}) {
	m.RBTree.Remove({{$.DataName}}RBTreeKey{Key:{{.DataName}}KeyTypeHash{{.HashIndexPk.Keys}}{
		{{range $i, $col := .HashIndexPk.Cols}}
			{{$col}}: obj.{{$col}},
		{{end}}
	},Value: {{$.DataName}}RBTreeValue{
		{{range $i, $col := .IndexRBTreeValue.Cols}}
			{{$col}}: obj.{{$col}},
		{{end}}
	}})
}


// 创建红黑树
func (m *{{.DataName}}Manager) CreateRBTree(TreeCapacity int32,less func(a,b {{$.DataName}}RBTreeKey) bool) {
	Less{{$.DataName}} = less
	m.RBTree = rbtree.NewRBTree[{{$.DataName}}RBTreeKey](TreeCapacity, Less{{$.DataName}}, Get{{$.DataName}}OnlyKey, Get{{$.DataName}}Value)
	objs := m.GetAll()
	for _,obj := range objs {
		m.RBTree.Put({{$.DataName}}RBTreeKey{Key:{{.DataName}}KeyTypeHash{{.HashIndexPk.Keys}}{
			{{range $i, $col := .HashIndexPk.Cols}}
				{{$col}}: obj.{{$col}},
			{{end}}

		},Value: {{$.DataName}}RBTreeValue{
			{{range $i, $col := .IndexRBTreeValue.Cols}}
				{{$col}}: obj.{{$col}},
			{{end}}	

		}})
	}
}


func (m *{{.DataName}}Manager) FindDataByRange(start, num int32) (onlyKyeList []*{{.DataName}}KeyTypeHash{{.HashIndexPk.Keys}}, valueList []*{{$.DataName}}RBTreeValue) {
	onlyKyeList = make([]*{{.DataName}}KeyTypeHash{{.HashIndexPk.Keys}}, 0, num)
	valueList = make([]*{{$.DataName}}RBTreeValue, 0, num)
	keys := m.RBTree.FindKeysByRange(start, num)
	for _, key := range keys {
		onlyKyeList = append(onlyKyeList,&key.Key)
		valueList = append(valueList,&key.Value)
	}
	return
}

func (m *{{.DataName}}Manager) FindRankByData(obj *{{$.ArgsInfo.PersistPkgName}}.{{$.DataName}}) (rank int32) {
	rank = m.RBTree.FindRankByKey({{$.DataName}}RBTreeKey{
		Key:{{.DataName}}KeyTypeHash{{.HashIndexPk.Keys}}{

			{{range $i, $col := .HashIndexPk.Cols}}
				{{$col}}: obj.{{$col}},
			{{end}}
		},
		Value: {{$.DataName}}RBTreeValue{
			{{range $i, $col := .IndexRBTreeValue.Cols}}
				{{$col}}: obj.{{$col}},
			{{end}}

		},
	})
	return
}

// value 区间
func (m *{{.DataName}}Manager) FindRankByKeys(valueBegin, valueEnd {{$.DataName}}RBTreeKey, num int32) []*{{$.ArgsInfo.PersistPkgName}}.{{$.DataName}} {
	keys := m.RBTree.FindKeysBetween(valueBegin, valueEnd, num, true)
	var objList []*{{$.ArgsInfo.PersistPkgName}}.{{$.DataName}}
	for _, key := range keys {
		data := m.Get{{$.DataName}}sBy{{.DataName}}KeyTypeHash{{.HashIndexPk.Keys}}(key.Key)
		if data != nil {
			objList = append(objList, data)
		}	
	}
	return objList
}

// 查询大于等于key的节点数组
func (m *{{.DataName}}Manager) FindKeysBigger(num int32,valueBegin {{$.DataName}}RBTreeKey) []*{{$.ArgsInfo.PersistPkgName}}.{{$.DataName}} {
	keys := m.RBTree.FindKeysBigger(valueBegin, num, true)
	var objList []*{{$.ArgsInfo.PersistPkgName}}.{{$.DataName}}
	for _, key := range keys {
		data := m.Get{{$.DataName}}sBy{{.DataName}}KeyTypeHash{{.HashIndexPk.Keys}}(key.Key)
		if data != nil {
			objList = append(objList, data)
		}		
	}
	return objList
}

// 查询小于key的节点数组
func (m *{{.DataName}}Manager) FindKeysSmaller(num int32,valueEnd {{$.DataName}}RBTreeKey) []*{{$.ArgsInfo.PersistPkgName}}.{{$.DataName}} {
	keys := m.RBTree.FindKeysSmaller(valueEnd, num, true)
	var objList []*{{$.ArgsInfo.PersistPkgName}}.{{$.DataName}}
	for _, key := range keys {
		data := m.Get{{$.DataName}}sBy{{.DataName}}KeyTypeHash{{.HashIndexPk.Keys}}(key.Key)
		if data != nil {
			objList = append(objList, data)
		}
	}
	return objList
}

func (m *{{$.DataName}}Manager) Get{{$.DataName}}sBy{{.DataName}}KeyTypeHash{{.HashIndexPk.Keys}}(hashKey {{.DataName}}KeyTypeHash{{.HashIndexPk.Keys}}) *{{$.ArgsInfo.PersistPkgName}}.{{.DataName}} {
	if data, ok := m.hash{{.HashIndexPk.Keys}}.Load(hashKey); ok {
		return data 
	}
	return nil
} 


{{end}}

`
